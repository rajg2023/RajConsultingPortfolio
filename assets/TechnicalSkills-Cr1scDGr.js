import{r as Ye,R as cp,j as Gn}from"./index-93MUWU1e.js";/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const $c="132",o0={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},a0={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},hp=0,xc=1,up=2,l0=3,c0=0,Kc=1,dp=2,Ps=3,Vi=0,se=1,Wi=2,Qc=1,h0=2,In=0,Fs=1,yc=2,_c=3,vc=4,fp=5,Pi=100,pp=101,mp=102,bc=103,Mc=104,gp=200,xp=201,yp=202,_p=203,th=204,eh=205,vp=206,bp=207,Mp=208,wp=209,Sp=210,Tp=0,Ep=1,Ap=2,Aa=3,Lp=4,Cp=5,Rp=6,Pp=7,oo=0,Dp=1,Ip=2,ni=0,Fp=1,kp=2,Bp=3,Op=4,zp=5,Ha=300,er=301,nr=302,Or=303,zr=304,ir=306,ao=307,Nr=1e3,we=1001,Hr=1002,le=1003,La=1004,u0=1004,Ca=1005,d0=1005,he=1006,nh=1007,f0=1007,Qi=1008,p0=1008,Gi=1009,Np=1010,Hp=1011,Ur=1012,Up=1013,Cr=1014,Cn=1015,Bi=1016,Vp=1017,Wp=1018,Gp=1019,ks=1020,Xp=1021,Fn=1022,Fe=1023,qp=1024,Yp=1025,jp=Fe,Oi=1026,zs=1027,Jp=1028,Zp=1029,$p=1030,Kp=1031,Qp=1032,tm=1033,wc=33776,Sc=33777,Tc=33778,Ec=33779,Ac=35840,Lc=35841,Cc=35842,Rc=35843,em=36196,Pc=37492,Dc=37496,nm=37808,im=37809,sm=37810,rm=37811,om=37812,am=37813,lm=37814,cm=37815,hm=37816,um=37817,dm=37818,fm=37819,pm=37820,mm=37821,gm=36492,xm=37840,ym=37841,_m=37842,vm=37843,bm=37844,Mm=37845,wm=37846,Sm=37847,Tm=37848,Em=37849,Am=37850,Lm=37851,Cm=37852,Rm=37853,Pm=2200,Dm=2201,Im=2202,Vr=2300,Wr=2301,wa=2302,Di=2400,Ii=2401,Gr=2402,Ua=2500,ih=2501,Fm=0,m0=1,g0=2,ke=3e3,lo=3001,Va=3007,Wa=3002,km=3003,sh=3004,rh=3005,oh=3006,Bm=3200,Om=3201,ts=0,zm=1,x0=0,Sa=7680,y0=7681,_0=7682,v0=7683,b0=34055,M0=34056,w0=5386,S0=512,T0=513,E0=514,A0=515,L0=516,C0=517,R0=518,Nm=519,Ns=35044,Hs=35048,P0=35040,D0=35045,I0=35049,F0=35041,k0=35046,B0=35050,O0=35042,z0="100",Ic="300 es";class di{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[t]===void 0&&(n[t]=[]),n[t].indexOf(e)===-1&&n[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const n=this._listeners;return n[t]!==void 0&&n[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const i=this._listeners[t];if(i!==void 0){const r=i.indexOf(e);r!==-1&&i.splice(r,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const n=this._listeners[t.type];if(n!==void 0){t.target=this;const i=n.slice(0);for(let r=0,o=i.length;r<o;r++)i[r].call(this,t);t.target=null}}}const be=[];for(let s=0;s<256;s++)be[s]=(s<16?"0":"")+s.toString(16);let bo=1234567;const zi=Math.PI/180,Xr=180/Math.PI;function Ve(){const s=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(be[s&255]+be[s>>8&255]+be[s>>16&255]+be[s>>24&255]+"-"+be[t&255]+be[t>>8&255]+"-"+be[t>>16&15|64]+be[t>>24&255]+"-"+be[e&63|128]+be[e>>8&255]+"-"+be[e>>16&255]+be[e>>24&255]+be[n&255]+be[n>>8&255]+be[n>>16&255]+be[n>>24&255]).toUpperCase()}function Me(s,t,e){return Math.max(t,Math.min(e,s))}function ah(s,t){return(s%t+t)%t}function N0(s,t,e,n,i){return n+(s-t)*(i-n)/(e-t)}function H0(s,t,e){return s!==t?(e-s)/(t-s):0}function Rr(s,t,e){return(1-e)*s+e*t}function U0(s,t,e,n){return Rr(s,t,1-Math.exp(-e*n))}function V0(s,t=1){return t-Math.abs(ah(s,t*2)-t)}function W0(s,t,e){return s<=t?0:s>=e?1:(s=(s-t)/(e-t),s*s*(3-2*s))}function G0(s,t,e){return s<=t?0:s>=e?1:(s=(s-t)/(e-t),s*s*s*(s*(s*6-15)+10))}function X0(s,t){return s+Math.floor(Math.random()*(t-s+1))}function q0(s,t){return s+Math.random()*(t-s)}function Y0(s){return s*(.5-Math.random())}function j0(s){return s!==void 0&&(bo=s%2147483647),bo=bo*16807%2147483647,(bo-1)/2147483646}function J0(s){return s*zi}function Z0(s){return s*Xr}function Fc(s){return(s&s-1)===0&&s!==0}function Hm(s){return Math.pow(2,Math.ceil(Math.log(s)/Math.LN2))}function Um(s){return Math.pow(2,Math.floor(Math.log(s)/Math.LN2))}function $0(s,t,e,n,i){const r=Math.cos,o=Math.sin,a=r(e/2),l=o(e/2),c=r((t+n)/2),h=o((t+n)/2),u=r((t-n)/2),d=o((t-n)/2),f=r((n-t)/2),p=o((n-t)/2);switch(i){case"XYX":s.set(a*h,l*u,l*d,a*c);break;case"YZY":s.set(l*d,a*h,l*u,a*c);break;case"ZXZ":s.set(l*u,l*d,a*h,a*c);break;case"XZX":s.set(a*h,l*p,l*f,a*c);break;case"YXY":s.set(l*f,a*h,l*p,a*c);break;case"ZYZ":s.set(l*p,l*f,a*h,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}var _u=Object.freeze({__proto__:null,DEG2RAD:zi,RAD2DEG:Xr,generateUUID:Ve,clamp:Me,euclideanModulo:ah,mapLinear:N0,inverseLerp:H0,lerp:Rr,damp:U0,pingpong:V0,smoothstep:W0,smootherstep:G0,randInt:X0,randFloat:q0,randFloatSpread:Y0,seededRandom:j0,degToRad:J0,radToDeg:Z0,isPowerOfTwo:Fc,ceilPowerOfTwo:Hm,floorPowerOfTwo:Um,setQuaternionFromProperEuler:$0});class j{constructor(t=0,e=0){this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6],this.y=i[1]*e+i[4]*n+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),i=Math.sin(e),r=this.x-t.x,o=this.y-t.y;return this.x=r*n-o*i+t.x,this.y=r*i+o*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}j.prototype.isVector2=!0;class ue{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,i,r,o,a,l,c){const h=this.elements;return h[0]=t,h[1]=i,h[2]=a,h[3]=e,h[4]=r,h[5]=l,h[6]=n,h[7]=o,h[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,o=n[0],a=n[3],l=n[6],c=n[1],h=n[4],u=n[7],d=n[2],f=n[5],p=n[8],m=i[0],y=i[3],g=i[6],x=i[1],v=i[4],_=i[7],M=i[2],w=i[5],b=i[8];return r[0]=o*m+a*x+l*M,r[3]=o*y+a*v+l*w,r[6]=o*g+a*_+l*b,r[1]=c*m+h*x+u*M,r[4]=c*y+h*v+u*w,r[7]=c*g+h*_+u*b,r[2]=d*m+f*x+p*M,r[5]=d*y+f*v+p*w,r[8]=d*g+f*_+p*b,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],o=t[4],a=t[5],l=t[6],c=t[7],h=t[8];return e*o*h-e*a*c-n*r*h+n*a*l+i*r*c-i*o*l}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],o=t[4],a=t[5],l=t[6],c=t[7],h=t[8],u=h*o-a*c,d=a*l-h*r,f=c*r-o*l,p=e*u+n*d+i*f;if(p===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/p;return t[0]=u*m,t[1]=(i*c-h*n)*m,t[2]=(a*n-i*o)*m,t[3]=d*m,t[4]=(h*e-i*l)*m,t[5]=(i*r-a*e)*m,t[6]=f*m,t[7]=(n*l-c*e)*m,t[8]=(o*e-n*r)*m,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,i,r,o,a){const l=Math.cos(r),c=Math.sin(r);return this.set(n*l,n*c,-n*(l*o+c*a)+o+t,-i*c,i*l,-i*(-c*o+l*a)+a+e,0,0,1),this}scale(t,e){const n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=e,n[4]*=e,n[7]*=e,this}rotate(t){const e=Math.cos(t),n=Math.sin(t),i=this.elements,r=i[0],o=i[3],a=i[6],l=i[1],c=i[4],h=i[7];return i[0]=e*r+n*l,i[3]=e*o+n*c,i[6]=e*a+n*h,i[1]=-n*r+e*l,i[4]=-n*o+e*c,i[7]=-n*a+e*h,this}translate(t,e){const n=this.elements;return n[0]+=t*n[2],n[3]+=t*n[5],n[6]+=t*n[8],n[1]+=e*n[2],n[4]+=e*n[5],n[7]+=e*n[8],this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<9;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return new this.constructor().fromArray(this.elements)}}ue.prototype.isMatrix3=!0;let cs;class es{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement>"u")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{cs===void 0&&(cs=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),cs.width=t.width,cs.height=t.height;const n=cs.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=cs}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}}let K0=0;class fe extends di{constructor(t=fe.DEFAULT_IMAGE,e=fe.DEFAULT_MAPPING,n=we,i=we,r=he,o=Qi,a=Fe,l=Gi,c=1,h=ke){super(),Object.defineProperty(this,"id",{value:K0++}),this.uuid=Ve(),this.name="",this.image=t,this.mipmaps=[],this.mapping=e,this.wrapS=n,this.wrapT=i,this.magFilter=r,this.minFilter=o,this.anisotropy=c,this.format=a,this.internalFormat=null,this.type=l,this.offset=new j(0,0),this.repeat=new j(1,1),this.center=new j(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new ue,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=h,this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.image=t.image,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const i=this.image;if(i.uuid===void 0&&(i.uuid=Ve()),!e&&t.images[i.uuid]===void 0){let r;if(Array.isArray(i)){r=[];for(let o=0,a=i.length;o<a;o++)i[o].isDataTexture?r.push(vl(i[o].image)):r.push(vl(i[o]))}else r=vl(i);t.images[i.uuid]={uuid:i.uuid,url:r}}n.image=i.uuid}return e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==Ha)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case Nr:t.x=t.x-Math.floor(t.x);break;case we:t.x=t.x<0?0:1;break;case Hr:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case Nr:t.y=t.y-Math.floor(t.y);break;case we:t.y=t.y<0?0:1;break;case Hr:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&this.version++}}fe.DEFAULT_IMAGE=void 0;fe.DEFAULT_MAPPING=Ha;fe.prototype.isTexture=!0;function vl(s){return typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&s instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&s instanceof ImageBitmap?es.getDataURL(s):s.data?{data:Array.prototype.slice.call(s.data),width:s.width,height:s.height,type:s.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}class Xt{constructor(t=0,e=0,n=0,i=1){this.x=t,this.y=e,this.z=n,this.w=i}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,i){return this.x=t,this.y=e,this.z=n,this.w=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=this.w,o=t.elements;return this.x=o[0]*e+o[4]*n+o[8]*i+o[12]*r,this.y=o[1]*e+o[5]*n+o[9]*i+o[13]*r,this.z=o[2]*e+o[6]*n+o[10]*i+o[14]*r,this.w=o[3]*e+o[7]*n+o[11]*i+o[15]*r,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,i,r;const l=t.elements,c=l[0],h=l[4],u=l[8],d=l[1],f=l[5],p=l[9],m=l[2],y=l[6],g=l[10];if(Math.abs(h-d)<.01&&Math.abs(u-m)<.01&&Math.abs(p-y)<.01){if(Math.abs(h+d)<.1&&Math.abs(u+m)<.1&&Math.abs(p+y)<.1&&Math.abs(c+f+g-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;const v=(c+1)/2,_=(f+1)/2,M=(g+1)/2,w=(h+d)/4,b=(u+m)/4,E=(p+y)/4;return v>_&&v>M?v<.01?(n=0,i=.707106781,r=.707106781):(n=Math.sqrt(v),i=w/n,r=b/n):_>M?_<.01?(n=.707106781,i=0,r=.707106781):(i=Math.sqrt(_),n=w/i,r=E/i):M<.01?(n=.707106781,i=.707106781,r=0):(r=Math.sqrt(M),n=b/r,i=E/r),this.set(n,i,r,e),this}let x=Math.sqrt((y-p)*(y-p)+(u-m)*(u-m)+(d-h)*(d-h));return Math.abs(x)<.001&&(x=1),this.x=(y-p)/x,this.y=(u-m)/x,this.z=(d-h)/x,this.w=Math.acos((c+f+g-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}Xt.prototype.isVector4=!0;class nn extends di{constructor(t,e,n={}){super(),this.width=t,this.height=e,this.depth=1,this.scissor=new Xt(0,0,t,e),this.scissorTest=!1,this.viewport=new Xt(0,0,t,e),this.texture=new fe(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.image={width:t,height:e,depth:1},this.texture.generateMipmaps=n.generateMipmaps!==void 0?n.generateMipmaps:!1,this.texture.internalFormat=n.internalFormat!==void 0?n.internalFormat:null,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:he,this.depthBuffer=n.depthBuffer!==void 0?n.depthBuffer:!0,this.stencilBuffer=n.stencilBuffer!==void 0?n.stencilBuffer:!1,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null}setTexture(t){t.image={width:this.width,height:this.height,depth:this.depth},this.texture=t}setSize(t,e,n=1){(this.width!==t||this.height!==e||this.depth!==n)&&(this.width=t,this.height=e,this.depth=n,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.texture.image={...this.texture.image},this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}nn.prototype.isWebGLRenderTarget=!0;class Vm extends nn{constructor(t,e,n){super(t,e);const i=this.texture;this.texture=[];for(let r=0;r<n;r++)this.texture[r]=i.clone()}setSize(t,e,n=1){if(this.width!==t||this.height!==e||this.depth!==n){this.width=t,this.height=e,this.depth=n;for(let i=0,r=this.texture.length;i<r;i++)this.texture[i].image.width=t,this.texture[i].image.height=e,this.texture[i].image.depth=n;this.dispose()}return this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e),this}copy(t){this.dispose(),this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this.texture.length=0;for(let e=0,n=t.texture.length;e<n;e++)this.texture[e]=t.texture[e].clone();return this}}Vm.prototype.isWebGLMultipleRenderTargets=!0;class lh extends nn{constructor(t,e,n){super(t,e,n),this.samples=4}copy(t){return super.copy.call(this,t),this.samples=t.samples,this}}lh.prototype.isWebGLMultisampleRenderTarget=!0;class Se{constructor(t=0,e=0,n=0,i=1){this._x=t,this._y=e,this._z=n,this._w=i}static slerp(t,e,n,i){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(t,e,i)}static slerpFlat(t,e,n,i,r,o,a){let l=n[i+0],c=n[i+1],h=n[i+2],u=n[i+3];const d=r[o+0],f=r[o+1],p=r[o+2],m=r[o+3];if(a===0){t[e+0]=l,t[e+1]=c,t[e+2]=h,t[e+3]=u;return}if(a===1){t[e+0]=d,t[e+1]=f,t[e+2]=p,t[e+3]=m;return}if(u!==m||l!==d||c!==f||h!==p){let y=1-a;const g=l*d+c*f+h*p+u*m,x=g>=0?1:-1,v=1-g*g;if(v>Number.EPSILON){const M=Math.sqrt(v),w=Math.atan2(M,g*x);y=Math.sin(y*w)/M,a=Math.sin(a*w)/M}const _=a*x;if(l=l*y+d*_,c=c*y+f*_,h=h*y+p*_,u=u*y+m*_,y===1-a){const M=1/Math.sqrt(l*l+c*c+h*h+u*u);l*=M,c*=M,h*=M,u*=M}}t[e]=l,t[e+1]=c,t[e+2]=h,t[e+3]=u}static multiplyQuaternionsFlat(t,e,n,i,r,o){const a=n[i],l=n[i+1],c=n[i+2],h=n[i+3],u=r[o],d=r[o+1],f=r[o+2],p=r[o+3];return t[e]=a*p+h*u+l*f-c*d,t[e+1]=l*p+h*d+c*u-a*f,t[e+2]=c*p+h*f+a*d-l*u,t[e+3]=h*p-a*u-l*d-c*f,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!(t&&t.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=t._x,i=t._y,r=t._z,o=t._order,a=Math.cos,l=Math.sin,c=a(n/2),h=a(i/2),u=a(r/2),d=l(n/2),f=l(i/2),p=l(r/2);switch(o){case"XYZ":this._x=d*h*u+c*f*p,this._y=c*f*u-d*h*p,this._z=c*h*p+d*f*u,this._w=c*h*u-d*f*p;break;case"YXZ":this._x=d*h*u+c*f*p,this._y=c*f*u-d*h*p,this._z=c*h*p-d*f*u,this._w=c*h*u+d*f*p;break;case"ZXY":this._x=d*h*u-c*f*p,this._y=c*f*u+d*h*p,this._z=c*h*p+d*f*u,this._w=c*h*u-d*f*p;break;case"ZYX":this._x=d*h*u-c*f*p,this._y=c*f*u+d*h*p,this._z=c*h*p-d*f*u,this._w=c*h*u+d*f*p;break;case"YZX":this._x=d*h*u+c*f*p,this._y=c*f*u+d*h*p,this._z=c*h*p-d*f*u,this._w=c*h*u-d*f*p;break;case"XZY":this._x=d*h*u-c*f*p,this._y=c*f*u-d*h*p,this._z=c*h*p+d*f*u,this._w=c*h*u+d*f*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return e!==!1&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,i=Math.sin(n);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],i=e[4],r=e[8],o=e[1],a=e[5],l=e[9],c=e[2],h=e[6],u=e[10],d=n+a+u;if(d>0){const f=.5/Math.sqrt(d+1);this._w=.25/f,this._x=(h-l)*f,this._y=(r-c)*f,this._z=(o-i)*f}else if(n>a&&n>u){const f=2*Math.sqrt(1+n-a-u);this._w=(h-l)/f,this._x=.25*f,this._y=(i+o)/f,this._z=(r+c)/f}else if(a>u){const f=2*Math.sqrt(1+a-n-u);this._w=(r-c)/f,this._x=(i+o)/f,this._y=.25*f,this._z=(l+h)/f}else{const f=2*Math.sqrt(1+u-n-a);this._w=(o-i)/f,this._x=(r+c)/f,this._y=(l+h)/f,this._z=.25*f}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(Me(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(n===0)return this;const i=Math.min(1,e/n);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return e!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,i=t._y,r=t._z,o=t._w,a=e._x,l=e._y,c=e._z,h=e._w;return this._x=n*h+o*a+i*c-r*l,this._y=i*h+o*l+r*a-n*c,this._z=r*h+o*c+n*l-i*a,this._w=o*h-n*a-i*l-r*c,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const n=this._x,i=this._y,r=this._z,o=this._w;let a=o*t._w+n*t._x+i*t._y+r*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=o,this._x=n,this._y=i,this._z=r,this;const l=1-a*a;if(l<=Number.EPSILON){const f=1-e;return this._w=f*o+e*this._w,this._x=f*n+e*this._x,this._y=f*i+e*this._y,this._z=f*r+e*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),h=Math.atan2(c,a),u=Math.sin((1-e)*h)/c,d=Math.sin(e*h)/c;return this._w=o*u+this._w*d,this._x=n*u+this._x*d,this._y=i*u+this._y*d,this._z=r*u+this._z*d,this._onChangeCallback(),this}slerpQuaternions(t,e,n){this.copy(t).slerp(e,n)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}Se.prototype.isQuaternion=!0;class S{constructor(t=0,e=0,n=0){this.x=t,this.y=e,this.z=n}set(t,e,n){return n===void 0&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(vu.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(vu.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6]*i,this.y=r[1]*e+r[4]*n+r[7]*i,this.z=r[2]*e+r[5]*n+r[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=t.elements,o=1/(r[3]*e+r[7]*n+r[11]*i+r[15]);return this.x=(r[0]*e+r[4]*n+r[8]*i+r[12])*o,this.y=(r[1]*e+r[5]*n+r[9]*i+r[13])*o,this.z=(r[2]*e+r[6]*n+r[10]*i+r[14])*o,this}applyQuaternion(t){const e=this.x,n=this.y,i=this.z,r=t.x,o=t.y,a=t.z,l=t.w,c=l*e+o*i-a*n,h=l*n+a*e-r*i,u=l*i+r*n-o*e,d=-r*e-o*n-a*i;return this.x=c*l+d*-r+h*-a-u*-o,this.y=h*l+d*-o+u*-r-c*-a,this.z=u*l+d*-a+c*-o-h*-r,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[4]*n+r[8]*i,this.y=r[1]*e+r[5]*n+r[9]*i,this.z=r[2]*e+r[6]*n+r[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t,e){return e!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,i=t.y,r=t.z,o=e.x,a=e.y,l=e.z;return this.x=i*l-r*a,this.y=r*o-n*l,this.z=n*a-i*o,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return bl.copy(this).projectOnVector(t),this.sub(bl)}reflect(t){return this.sub(bl.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(Me(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return e*e+n*n+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const i=Math.sin(e)*t;return this.x=i*Math.sin(n),this.y=Math.cos(e)*t,this.z=i*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}S.prototype.isVector3=!0;const bl=new S,vu=new Se;class Ge{constructor(t=new S(1/0,1/0,1/0),e=new S(-1/0,-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,n=1/0,i=1/0,r=-1/0,o=-1/0,a=-1/0;for(let l=0,c=t.length;l<c;l+=3){const h=t[l],u=t[l+1],d=t[l+2];h<e&&(e=h),u<n&&(n=u),d<i&&(i=d),h>r&&(r=h),u>o&&(o=u),d>a&&(a=d)}return this.min.set(e,n,i),this.max.set(r,o,a),this}setFromBufferAttribute(t){let e=1/0,n=1/0,i=1/0,r=-1/0,o=-1/0,a=-1/0;for(let l=0,c=t.count;l<c;l++){const h=t.getX(l),u=t.getY(l),d=t.getZ(l);h<e&&(e=h),u<n&&(n=u),d<i&&(i=d),h>r&&(r=h),u>o&&(o=u),d>a&&(a=d)}return this.min.set(e,n,i),this.max.set(r,o,a),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=hr.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t){return this.makeEmpty(),this.expandByObject(t)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t){t.updateWorldMatrix(!1,!1);const e=t.geometry;e!==void 0&&(e.boundingBox===null&&e.computeBoundingBox(),Ml.copy(e.boundingBox),Ml.applyMatrix4(t.matrixWorld),this.union(Ml));const n=t.children;for(let i=0,r=n.length;i<r;i++)this.expandByObject(n[i]);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,hr),hr.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(ur),Mo.subVectors(this.max,ur),hs.subVectors(t.a,ur),us.subVectors(t.b,ur),ds.subVectors(t.c,ur),Xn.subVectors(us,hs),qn.subVectors(ds,us),_i.subVectors(hs,ds);let e=[0,-Xn.z,Xn.y,0,-qn.z,qn.y,0,-_i.z,_i.y,Xn.z,0,-Xn.x,qn.z,0,-qn.x,_i.z,0,-_i.x,-Xn.y,Xn.x,0,-qn.y,qn.x,0,-_i.y,_i.x,0];return!wl(e,hs,us,ds,Mo)||(e=[1,0,0,0,1,0,0,0,1],!wl(e,hs,us,ds,Mo))?!1:(wo.crossVectors(Xn,qn),e=[wo.x,wo.y,wo.z],wl(e,hs,us,ds,Mo))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return hr.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=this.getSize(hr).length()*.5,t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(vn[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),vn[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),vn[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),vn[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),vn[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),vn[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),vn[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),vn[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(vn),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}Ge.prototype.isBox3=!0;const vn=[new S,new S,new S,new S,new S,new S,new S,new S],hr=new S,Ml=new Ge,hs=new S,us=new S,ds=new S,Xn=new S,qn=new S,_i=new S,ur=new S,Mo=new S,wo=new S,vi=new S;function wl(s,t,e,n,i){for(let r=0,o=s.length-3;r<=o;r+=3){vi.fromArray(s,r);const a=i.x*Math.abs(vi.x)+i.y*Math.abs(vi.y)+i.z*Math.abs(vi.z),l=t.dot(vi),c=e.dot(vi),h=n.dot(vi);if(Math.max(-Math.max(l,c,h),Math.min(l,c,h))>a)return!1}return!0}const Q0=new Ge,bu=new S,Sl=new S,Tl=new S;class fi{constructor(t=new S,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;e!==void 0?n.copy(e):Q0.setFromPoints(t).getCenter(n);let i=0;for(let r=0,o=t.length;r<o;r++)i=Math.max(i,n.distanceToSquared(t[r]));return this.radius=Math.sqrt(i),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){Tl.subVectors(t,this.center);const e=Tl.lengthSq();if(e>this.radius*this.radius){const n=Math.sqrt(e),i=(n-this.radius)*.5;this.center.add(Tl.multiplyScalar(i/n)),this.radius+=i}return this}union(t){return Sl.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(bu.copy(t.center).add(Sl)),this.expandByPoint(bu.copy(t.center).sub(Sl)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const bn=new S,El=new S,So=new S,Yn=new S,Al=new S,To=new S,Ll=new S;class pi{constructor(t=new S,e=new S(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,bn)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=bn.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(bn.copy(this.direction).multiplyScalar(e).add(this.origin),bn.distanceToSquared(t))}distanceSqToSegment(t,e,n,i){El.copy(t).add(e).multiplyScalar(.5),So.copy(e).sub(t).normalize(),Yn.copy(this.origin).sub(El);const r=t.distanceTo(e)*.5,o=-this.direction.dot(So),a=Yn.dot(this.direction),l=-Yn.dot(So),c=Yn.lengthSq(),h=Math.abs(1-o*o);let u,d,f,p;if(h>0)if(u=o*l-a,d=o*a-l,p=r*h,u>=0)if(d>=-p)if(d<=p){const m=1/h;u*=m,d*=m,f=u*(u+o*d+2*a)+d*(o*u+d+2*l)+c}else d=r,u=Math.max(0,-(o*d+a)),f=-u*u+d*(d+2*l)+c;else d=-r,u=Math.max(0,-(o*d+a)),f=-u*u+d*(d+2*l)+c;else d<=-p?(u=Math.max(0,-(-o*r+a)),d=u>0?-r:Math.min(Math.max(-r,-l),r),f=-u*u+d*(d+2*l)+c):d<=p?(u=0,d=Math.min(Math.max(-r,-l),r),f=d*(d+2*l)+c):(u=Math.max(0,-(o*r+a)),d=u>0?r:Math.min(Math.max(-r,-l),r),f=-u*u+d*(d+2*l)+c);else d=o>0?-r:r,u=Math.max(0,-(o*d+a)),f=-u*u+d*(d+2*l)+c;return n&&n.copy(this.direction).multiplyScalar(u).add(this.origin),i&&i.copy(So).multiplyScalar(d).add(El),f}intersectSphere(t,e){bn.subVectors(t.center,this.origin);const n=bn.dot(this.direction),i=bn.dot(bn)-n*n,r=t.radius*t.radius;if(i>r)return null;const o=Math.sqrt(r-i),a=n-o,l=n+o;return a<0&&l<0?null:a<0?this.at(l,e):this.at(a,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return n===null?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,i,r,o,a,l;const c=1/this.direction.x,h=1/this.direction.y,u=1/this.direction.z,d=this.origin;return c>=0?(n=(t.min.x-d.x)*c,i=(t.max.x-d.x)*c):(n=(t.max.x-d.x)*c,i=(t.min.x-d.x)*c),h>=0?(r=(t.min.y-d.y)*h,o=(t.max.y-d.y)*h):(r=(t.max.y-d.y)*h,o=(t.min.y-d.y)*h),n>o||r>i||((r>n||n!==n)&&(n=r),(o<i||i!==i)&&(i=o),u>=0?(a=(t.min.z-d.z)*u,l=(t.max.z-d.z)*u):(a=(t.max.z-d.z)*u,l=(t.min.z-d.z)*u),n>l||a>i)||((a>n||n!==n)&&(n=a),(l<i||i!==i)&&(i=l),i<0)?null:this.at(n>=0?n:i,e)}intersectsBox(t){return this.intersectBox(t,bn)!==null}intersectTriangle(t,e,n,i,r){Al.subVectors(e,t),To.subVectors(n,t),Ll.crossVectors(Al,To);let o=this.direction.dot(Ll),a;if(o>0){if(i)return null;a=1}else if(o<0)a=-1,o=-o;else return null;Yn.subVectors(this.origin,t);const l=a*this.direction.dot(To.crossVectors(Yn,To));if(l<0)return null;const c=a*this.direction.dot(Al.cross(Yn));if(c<0||l+c>o)return null;const h=-a*Yn.dot(Ll);return h<0?null:this.at(h/o,r)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class ft{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,i,r,o,a,l,c,h,u,d,f,p,m,y){const g=this.elements;return g[0]=t,g[4]=e,g[8]=n,g[12]=i,g[1]=r,g[5]=o,g[9]=a,g[13]=l,g[2]=c,g[6]=h,g[10]=u,g[14]=d,g[3]=f,g[7]=p,g[11]=m,g[15]=y,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new ft().fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,i=1/fs.setFromMatrixColumn(t,0).length(),r=1/fs.setFromMatrixColumn(t,1).length(),o=1/fs.setFromMatrixColumn(t,2).length();return e[0]=n[0]*i,e[1]=n[1]*i,e[2]=n[2]*i,e[3]=0,e[4]=n[4]*r,e[5]=n[5]*r,e[6]=n[6]*r,e[7]=0,e[8]=n[8]*o,e[9]=n[9]*o,e[10]=n[10]*o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,n=t.x,i=t.y,r=t.z,o=Math.cos(n),a=Math.sin(n),l=Math.cos(i),c=Math.sin(i),h=Math.cos(r),u=Math.sin(r);if(t.order==="XYZ"){const d=o*h,f=o*u,p=a*h,m=a*u;e[0]=l*h,e[4]=-l*u,e[8]=c,e[1]=f+p*c,e[5]=d-m*c,e[9]=-a*l,e[2]=m-d*c,e[6]=p+f*c,e[10]=o*l}else if(t.order==="YXZ"){const d=l*h,f=l*u,p=c*h,m=c*u;e[0]=d+m*a,e[4]=p*a-f,e[8]=o*c,e[1]=o*u,e[5]=o*h,e[9]=-a,e[2]=f*a-p,e[6]=m+d*a,e[10]=o*l}else if(t.order==="ZXY"){const d=l*h,f=l*u,p=c*h,m=c*u;e[0]=d-m*a,e[4]=-o*u,e[8]=p+f*a,e[1]=f+p*a,e[5]=o*h,e[9]=m-d*a,e[2]=-o*c,e[6]=a,e[10]=o*l}else if(t.order==="ZYX"){const d=o*h,f=o*u,p=a*h,m=a*u;e[0]=l*h,e[4]=p*c-f,e[8]=d*c+m,e[1]=l*u,e[5]=m*c+d,e[9]=f*c-p,e[2]=-c,e[6]=a*l,e[10]=o*l}else if(t.order==="YZX"){const d=o*l,f=o*c,p=a*l,m=a*c;e[0]=l*h,e[4]=m-d*u,e[8]=p*u+f,e[1]=u,e[5]=o*h,e[9]=-a*h,e[2]=-c*h,e[6]=f*u+p,e[10]=d-m*u}else if(t.order==="XZY"){const d=o*l,f=o*c,p=a*l,m=a*c;e[0]=l*h,e[4]=-u,e[8]=c*h,e[1]=d*u+m,e[5]=o*h,e[9]=f*u-p,e[2]=p*u-f,e[6]=a*h,e[10]=m*u+d}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(ty,t,ey)}lookAt(t,e,n){const i=this.elements;return He.subVectors(t,e),He.lengthSq()===0&&(He.z=1),He.normalize(),jn.crossVectors(n,He),jn.lengthSq()===0&&(Math.abs(n.z)===1?He.x+=1e-4:He.z+=1e-4,He.normalize(),jn.crossVectors(n,He)),jn.normalize(),Eo.crossVectors(He,jn),i[0]=jn.x,i[4]=Eo.x,i[8]=He.x,i[1]=jn.y,i[5]=Eo.y,i[9]=He.y,i[2]=jn.z,i[6]=Eo.z,i[10]=He.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,o=n[0],a=n[4],l=n[8],c=n[12],h=n[1],u=n[5],d=n[9],f=n[13],p=n[2],m=n[6],y=n[10],g=n[14],x=n[3],v=n[7],_=n[11],M=n[15],w=i[0],b=i[4],E=i[8],P=i[12],R=i[1],C=i[5],U=i[9],k=i[13],B=i[2],O=i[6],F=i[10],N=i[14],Z=i[3],tt=i[7],dt=i[11],nt=i[15];return r[0]=o*w+a*R+l*B+c*Z,r[4]=o*b+a*C+l*O+c*tt,r[8]=o*E+a*U+l*F+c*dt,r[12]=o*P+a*k+l*N+c*nt,r[1]=h*w+u*R+d*B+f*Z,r[5]=h*b+u*C+d*O+f*tt,r[9]=h*E+u*U+d*F+f*dt,r[13]=h*P+u*k+d*N+f*nt,r[2]=p*w+m*R+y*B+g*Z,r[6]=p*b+m*C+y*O+g*tt,r[10]=p*E+m*U+y*F+g*dt,r[14]=p*P+m*k+y*N+g*nt,r[3]=x*w+v*R+_*B+M*Z,r[7]=x*b+v*C+_*O+M*tt,r[11]=x*E+v*U+_*F+M*dt,r[15]=x*P+v*k+_*N+M*nt,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],i=t[8],r=t[12],o=t[1],a=t[5],l=t[9],c=t[13],h=t[2],u=t[6],d=t[10],f=t[14],p=t[3],m=t[7],y=t[11],g=t[15];return p*(+r*l*u-i*c*u-r*a*d+n*c*d+i*a*f-n*l*f)+m*(+e*l*f-e*c*d+r*o*d-i*o*f+i*c*h-r*l*h)+y*(+e*c*u-e*a*f-r*o*u+n*o*f+r*a*h-n*c*h)+g*(-i*a*h-e*l*u+e*a*d+i*o*u-n*o*d+n*l*h)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],o=t[4],a=t[5],l=t[6],c=t[7],h=t[8],u=t[9],d=t[10],f=t[11],p=t[12],m=t[13],y=t[14],g=t[15],x=u*y*c-m*d*c+m*l*f-a*y*f-u*l*g+a*d*g,v=p*d*c-h*y*c-p*l*f+o*y*f+h*l*g-o*d*g,_=h*m*c-p*u*c+p*a*f-o*m*f-h*a*g+o*u*g,M=p*u*l-h*m*l-p*a*d+o*m*d+h*a*y-o*u*y,w=e*x+n*v+i*_+r*M;if(w===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const b=1/w;return t[0]=x*b,t[1]=(m*d*r-u*y*r-m*i*f+n*y*f+u*i*g-n*d*g)*b,t[2]=(a*y*r-m*l*r+m*i*c-n*y*c-a*i*g+n*l*g)*b,t[3]=(u*l*r-a*d*r-u*i*c+n*d*c+a*i*f-n*l*f)*b,t[4]=v*b,t[5]=(h*y*r-p*d*r+p*i*f-e*y*f-h*i*g+e*d*g)*b,t[6]=(p*l*r-o*y*r-p*i*c+e*y*c+o*i*g-e*l*g)*b,t[7]=(o*d*r-h*l*r+h*i*c-e*d*c-o*i*f+e*l*f)*b,t[8]=_*b,t[9]=(p*u*r-h*m*r-p*n*f+e*m*f+h*n*g-e*u*g)*b,t[10]=(o*m*r-p*a*r+p*n*c-e*m*c-o*n*g+e*a*g)*b,t[11]=(h*a*r-o*u*r-h*n*c+e*u*c+o*n*f-e*a*f)*b,t[12]=M*b,t[13]=(h*m*i-p*u*i+p*n*d-e*m*d-h*n*y+e*u*y)*b,t[14]=(p*a*i-o*m*i-p*n*l+e*m*l+o*n*y-e*a*y)*b,t[15]=(o*u*i-h*a*i+h*n*l-e*u*l-o*n*d+e*a*d)*b,this}scale(t){const e=this.elements,n=t.x,i=t.y,r=t.z;return e[0]*=n,e[4]*=i,e[8]*=r,e[1]*=n,e[5]*=i,e[9]*=r,e[2]*=n,e[6]*=i,e[10]*=r,e[3]*=n,e[7]*=i,e[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,i))}makeTranslation(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),i=Math.sin(e),r=1-n,o=t.x,a=t.y,l=t.z,c=r*o,h=r*a;return this.set(c*o+n,c*a-i*l,c*l+i*a,0,c*a+i*l,h*a+n,h*l-i*o,0,c*l-i*a,h*l+i*o,r*l*l+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,i,r,o){return this.set(1,n,r,0,t,1,o,0,e,i,1,0,0,0,0,1),this}compose(t,e,n){const i=this.elements,r=e._x,o=e._y,a=e._z,l=e._w,c=r+r,h=o+o,u=a+a,d=r*c,f=r*h,p=r*u,m=o*h,y=o*u,g=a*u,x=l*c,v=l*h,_=l*u,M=n.x,w=n.y,b=n.z;return i[0]=(1-(m+g))*M,i[1]=(f+_)*M,i[2]=(p-v)*M,i[3]=0,i[4]=(f-_)*w,i[5]=(1-(d+g))*w,i[6]=(y+x)*w,i[7]=0,i[8]=(p+v)*b,i[9]=(y-x)*b,i[10]=(1-(d+m))*b,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,n){const i=this.elements;let r=fs.set(i[0],i[1],i[2]).length();const o=fs.set(i[4],i[5],i[6]).length(),a=fs.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),t.x=i[12],t.y=i[13],t.z=i[14],Ze.copy(this);const c=1/r,h=1/o,u=1/a;return Ze.elements[0]*=c,Ze.elements[1]*=c,Ze.elements[2]*=c,Ze.elements[4]*=h,Ze.elements[5]*=h,Ze.elements[6]*=h,Ze.elements[8]*=u,Ze.elements[9]*=u,Ze.elements[10]*=u,e.setFromRotationMatrix(Ze),n.x=r,n.y=o,n.z=a,this}makePerspective(t,e,n,i,r,o){o===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,l=2*r/(e-t),c=2*r/(n-i),h=(e+t)/(e-t),u=(n+i)/(n-i),d=-(o+r)/(o-r),f=-2*o*r/(o-r);return a[0]=l,a[4]=0,a[8]=h,a[12]=0,a[1]=0,a[5]=c,a[9]=u,a[13]=0,a[2]=0,a[6]=0,a[10]=d,a[14]=f,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(t,e,n,i,r,o){const a=this.elements,l=1/(e-t),c=1/(n-i),h=1/(o-r),u=(e+t)*l,d=(n+i)*c,f=(o+r)*h;return a[0]=2*l,a[4]=0,a[8]=0,a[12]=-u,a[1]=0,a[5]=2*c,a[9]=0,a[13]=-d,a[2]=0,a[6]=0,a[10]=-2*h,a[14]=-f,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<16;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}ft.prototype.isMatrix4=!0;const fs=new S,Ze=new ft,ty=new S(0,0,0),ey=new S(1,1,1),jn=new S,Eo=new S,He=new S,Mu=new ft,wu=new Se;class ns{constructor(t=0,e=0,n=0,i=ns.DefaultOrder){this._x=t,this._y=e,this._z=n,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,i=this._order){return this._x=t,this._y=e,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,n=!0){const i=t.elements,r=i[0],o=i[4],a=i[8],l=i[1],c=i[5],h=i[9],u=i[2],d=i[6],f=i[10];switch(e){case"XYZ":this._y=Math.asin(Me(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-h,f),this._z=Math.atan2(-o,r)):(this._x=Math.atan2(d,c),this._z=0);break;case"YXZ":this._x=Math.asin(-Me(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(a,f),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-u,r),this._z=0);break;case"ZXY":this._x=Math.asin(Me(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-u,f),this._z=Math.atan2(-o,c)):(this._y=0,this._z=Math.atan2(l,r));break;case"ZYX":this._y=Math.asin(-Me(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(d,f),this._z=Math.atan2(l,r)):(this._x=0,this._z=Math.atan2(-o,c));break;case"YZX":this._z=Math.asin(Me(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-h,c),this._y=Math.atan2(-u,r)):(this._x=0,this._y=Math.atan2(a,f));break;case"XZY":this._z=Math.asin(-Me(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(d,c),this._y=Math.atan2(a,r)):(this._x=Math.atan2(-h,f),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,n===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return Mu.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Mu,e,n)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return wu.setFromEuler(this),this.setFromQuaternion(wu,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}toVector3(t){return t?t.set(this._x,this._y,this._z):new S(this._x,this._y,this._z)}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}ns.prototype.isEuler=!0;ns.DefaultOrder="XYZ";ns.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class ch{constructor(){this.mask=1}set(t){this.mask=1<<t|0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!==0}}let ny=0;const Su=new S,ps=new Se,Mn=new ft,Ao=new S,dr=new S,iy=new S,sy=new Se,Tu=new S(1,0,0),Eu=new S(0,1,0),Au=new S(0,0,1),ry={type:"added"},Lu={type:"removed"};class It extends di{constructor(){super(),Object.defineProperty(this,"id",{value:ny++}),this.uuid=Ve(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=It.DefaultUp.clone();const t=new S,e=new ns,n=new Se,i=new S(1,1,1);function r(){n.setFromEuler(e,!1)}function o(){e.setFromQuaternion(n,void 0,!1)}e._onChange(r),n._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new ft},normalMatrix:{value:new ue}}),this.matrix=new ft,this.matrixWorld=new ft,this.matrixAutoUpdate=It.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new ch,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return ps.setFromAxisAngle(t,e),this.quaternion.multiply(ps),this}rotateOnWorldAxis(t,e){return ps.setFromAxisAngle(t,e),this.quaternion.premultiply(ps),this}rotateX(t){return this.rotateOnAxis(Tu,t)}rotateY(t){return this.rotateOnAxis(Eu,t)}rotateZ(t){return this.rotateOnAxis(Au,t)}translateOnAxis(t,e){return Su.copy(t).applyQuaternion(this.quaternion),this.position.add(Su.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(Tu,t)}translateY(t){return this.translateOnAxis(Eu,t)}translateZ(t){return this.translateOnAxis(Au,t)}localToWorld(t){return t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return t.applyMatrix4(Mn.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?Ao.copy(t):Ao.set(t,e,n);const i=this.parent;this.updateWorldMatrix(!0,!1),dr.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Mn.lookAt(dr,Ao,this.up):Mn.lookAt(Ao,dr,this.up),this.quaternion.setFromRotationMatrix(Mn),i&&(Mn.extractRotation(i.matrixWorld),ps.setFromRotationMatrix(Mn),this.quaternion.premultiply(ps.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.parent!==null&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(ry)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(Lu)),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(Lu)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),Mn.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),Mn.multiply(t.parent.matrixWorld)),t.applyMatrix4(Mn),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,i=this.children.length;n<i;n++){const o=this.children[n].getObjectByProperty(t,e);if(o!==void 0)return o}}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(dr,t,iy),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(dr,sy,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].updateMatrixWorld(t)}updateWorldMatrix(t,e){const n=this.parent;if(t===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),e===!0){const i=this.children;for(let r=0,o=i.length;r<o;r++)i[r].updateWorldMatrix(!1,!0)}}toJSON(t){const e=t===void 0||typeof t=="string",n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON()));function r(a,l){return a[l.uuid]===void 0&&(a[l.uuid]=l.toJSON(t)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&(i.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(t.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const l=a.shapes;if(Array.isArray(l))for(let c=0,h=l.length;c<h;c++){const u=l[c];r(t.shapes,u)}else r(t.shapes,l)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let l=0,c=this.material.length;l<c;l++)a.push(r(t.materials,this.material[l]));i.material=a}else i.material=r(t.materials,this.material);if(this.children.length>0){i.children=[];for(let a=0;a<this.children.length;a++)i.children.push(this.children[a].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let a=0;a<this.animations.length;a++){const l=this.animations[a];i.animations.push(r(t.animations,l))}}if(e){const a=o(t.geometries),l=o(t.materials),c=o(t.textures),h=o(t.images),u=o(t.shapes),d=o(t.skeletons),f=o(t.animations);a.length>0&&(n.geometries=a),l.length>0&&(n.materials=l),c.length>0&&(n.textures=c),h.length>0&&(n.images=h),u.length>0&&(n.shapes=u),d.length>0&&(n.skeletons=d),f.length>0&&(n.animations=f)}return n.object=i,n;function o(a){const l=[];for(const c in a){const h=a[c];delete h.metadata,l.push(h)}return l}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let n=0;n<t.children.length;n++){const i=t.children[n];this.add(i.clone())}return this}}It.DefaultUp=new S(0,1,0);It.DefaultMatrixAutoUpdate=!0;It.prototype.isObject3D=!0;const $e=new S,wn=new S,Cl=new S,Sn=new S,ms=new S,gs=new S,Cu=new S,Rl=new S,Pl=new S,Dl=new S;class re{constructor(t=new S,e=new S,n=new S){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,i){i.subVectors(n,e),$e.subVectors(t,e),i.cross($e);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(t,e,n,i,r){$e.subVectors(i,e),wn.subVectors(n,e),Cl.subVectors(t,e);const o=$e.dot($e),a=$e.dot(wn),l=$e.dot(Cl),c=wn.dot(wn),h=wn.dot(Cl),u=o*c-a*a;if(u===0)return r.set(-2,-1,-1);const d=1/u,f=(c*l-a*h)*d,p=(o*h-a*l)*d;return r.set(1-f-p,p,f)}static containsPoint(t,e,n,i){return this.getBarycoord(t,e,n,i,Sn),Sn.x>=0&&Sn.y>=0&&Sn.x+Sn.y<=1}static getUV(t,e,n,i,r,o,a,l){return this.getBarycoord(t,e,n,i,Sn),l.set(0,0),l.addScaledVector(r,Sn.x),l.addScaledVector(o,Sn.y),l.addScaledVector(a,Sn.z),l}static isFrontFacing(t,e,n,i){return $e.subVectors(n,e),wn.subVectors(t,e),$e.cross(wn).dot(i)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,i){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[i]),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return $e.subVectors(this.c,this.b),wn.subVectors(this.a,this.b),$e.cross(wn).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return re.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return re.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,i,r){return re.getUV(t,this.a,this.b,this.c,e,n,i,r)}containsPoint(t){return re.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return re.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const n=this.a,i=this.b,r=this.c;let o,a;ms.subVectors(i,n),gs.subVectors(r,n),Rl.subVectors(t,n);const l=ms.dot(Rl),c=gs.dot(Rl);if(l<=0&&c<=0)return e.copy(n);Pl.subVectors(t,i);const h=ms.dot(Pl),u=gs.dot(Pl);if(h>=0&&u<=h)return e.copy(i);const d=l*u-h*c;if(d<=0&&l>=0&&h<=0)return o=l/(l-h),e.copy(n).addScaledVector(ms,o);Dl.subVectors(t,r);const f=ms.dot(Dl),p=gs.dot(Dl);if(p>=0&&f<=p)return e.copy(r);const m=f*c-l*p;if(m<=0&&c>=0&&p<=0)return a=c/(c-p),e.copy(n).addScaledVector(gs,a);const y=h*p-f*u;if(y<=0&&u-h>=0&&f-p>=0)return Cu.subVectors(r,i),a=(u-h)/(u-h+(f-p)),e.copy(i).addScaledVector(Cu,a);const g=1/(y+m+d);return o=m*g,a=d*g,e.copy(n).addScaledVector(ms,o).addScaledVector(gs,a)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let oy=0;class ye extends di{constructor(){super(),Object.defineProperty(this,"id",{value:oy++}),this.uuid=Ve(),this.name="",this.type="Material",this.fog=!0,this.blending=Fs,this.side=Vi,this.vertexColors=!1,this.opacity=1,this.format=Fe,this.transparent=!1,this.blendSrc=th,this.blendDst=eh,this.blendEquation=Pi,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=Aa,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Nm,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Sa,this.stencilZFail=Sa,this.stencilZPass=Sa,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBuild(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const n=t[e];if(n===void 0){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if(e==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===Qc;continue}const i=this[e];if(i===void 0){console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.");continue}i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[e]=n}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheenTint&&this.sheenTint.isColor&&(n.sheenTint=this.sheenTint.getHex()),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularTint&&this.specularTint.isColor&&(n.specularTint=this.specularTint.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularTintMap&&this.specularTintMap.isTexture&&(n.specularTintMap=this.specularTintMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationTint!==void 0&&(n.attenuationTint=this.attenuationTint.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==Fs&&(n.blending=this.blending),this.side!==Vi&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.format!==Fe&&(n.format=this.format),this.transparent===!0&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(n.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=this.flatShading),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData);function i(r){const o=[];for(const a in r){const l=r[a];delete l.metadata,o.push(l)}return o}if(e){const r=i(t.textures),o=i(t.images);r.length>0&&(n.textures=r),o.length>0&&(n.images=o)}return n}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.fog=t.fog,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.format=t.format,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(e!==null){const i=e.length;n=new Array(i);for(let r=0;r!==i;++r)n[r]=e[r].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}}ye.prototype.isMaterial=!0;const Wm={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Ke={h:0,s:0,l:0},Lo={h:0,s:0,l:0};function Il(s,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?s+(t-s)*6*e:e<1/2?t:e<2/3?s+(t-s)*6*(2/3-e):s}function Fl(s){return s<.04045?s*.0773993808:Math.pow(s*.9478672986+.0521327014,2.4)}function kl(s){return s<.0031308?s*12.92:1.055*Math.pow(s,.41666)-.055}let it=class{constructor(t,e,n){return e===void 0&&n===void 0?this.set(t):this.setRGB(t,e,n)}set(t){return t&&t.isColor?this.copy(t):typeof t=="number"?this.setHex(t):typeof t=="string"&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,this}setRGB(t,e,n){return this.r=t,this.g=e,this.b=n,this}setHSL(t,e,n){if(t=ah(t,1),e=Me(e,0,1),n=Me(n,0,1),e===0)this.r=this.g=this.b=n;else{const i=n<=.5?n*(1+e):n+e-n*e,r=2*n-i;this.r=Il(r,i,t+1/3),this.g=Il(r,i,t),this.b=Il(r,i,t-1/3)}return this}setStyle(t){function e(i){i!==void 0&&parseFloat(i)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let i;const r=n[1],o=n[2];switch(r){case"rgb":case"rgba":if(i=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(i[1],10))/255,this.g=Math.min(255,parseInt(i[2],10))/255,this.b=Math.min(255,parseInt(i[3],10))/255,e(i[4]),this;if(i=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(i[1],10))/100,this.g=Math.min(100,parseInt(i[2],10))/100,this.b=Math.min(100,parseInt(i[3],10))/100,e(i[4]),this;break;case"hsl":case"hsla":if(i=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)){const a=parseFloat(i[1])/360,l=parseInt(i[2],10)/100,c=parseInt(i[3],10)/100;return e(i[4]),this.setHSL(a,l,c)}break}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(t)){const i=n[1],r=i.length;if(r===3)return this.r=parseInt(i.charAt(0)+i.charAt(0),16)/255,this.g=parseInt(i.charAt(1)+i.charAt(1),16)/255,this.b=parseInt(i.charAt(2)+i.charAt(2),16)/255,this;if(r===6)return this.r=parseInt(i.charAt(0)+i.charAt(1),16)/255,this.g=parseInt(i.charAt(2)+i.charAt(3),16)/255,this.b=parseInt(i.charAt(4)+i.charAt(5),16)/255,this}return t&&t.length>0?this.setColorName(t):this}setColorName(t){const e=Wm[t.toLowerCase()];return e!==void 0?this.setHex(e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copyGammaToLinear(t,e=2){return this.r=Math.pow(t.r,e),this.g=Math.pow(t.g,e),this.b=Math.pow(t.b,e),this}copyLinearToGamma(t,e=2){const n=e>0?1/e:1;return this.r=Math.pow(t.r,n),this.g=Math.pow(t.g,n),this.b=Math.pow(t.b,n),this}convertGammaToLinear(t){return this.copyGammaToLinear(this,t),this}convertLinearToGamma(t){return this.copyLinearToGamma(this,t),this}copySRGBToLinear(t){return this.r=Fl(t.r),this.g=Fl(t.g),this.b=Fl(t.b),this}copyLinearToSRGB(t){return this.r=kl(t.r),this.g=kl(t.g),this.b=kl(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(t){const e=this.r,n=this.g,i=this.b,r=Math.max(e,n,i),o=Math.min(e,n,i);let a,l;const c=(o+r)/2;if(o===r)a=0,l=0;else{const h=r-o;switch(l=c<=.5?h/(r+o):h/(2-r-o),r){case e:a=(n-i)/h+(n<i?6:0);break;case n:a=(i-e)/h+2;break;case i:a=(e-n)/h+4;break}a/=6}return t.h=a,t.s=l,t.l=c,t}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(t,e,n){return this.getHSL(Ke),Ke.h+=t,Ke.s+=e,Ke.l+=n,this.setHSL(Ke.h,Ke.s,Ke.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(Ke),t.getHSL(Lo);const n=Rr(Ke.h,Lo.h,e),i=Rr(Ke.s,Lo.s,e),r=Rr(Ke.l,Lo.l,e);return this.setHSL(n,i,r),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),t.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}};it.NAMES=Wm;it.prototype.isColor=!0;it.prototype.r=1;it.prototype.g=1;it.prototype.b=1;class Nn extends ye{constructor(t){super(),this.type="MeshBasicMaterial",this.color=new it(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=oo,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}Nn.prototype.isMeshBasicMaterial=!0;const Yt=new S,Co=new j;class Nt{constructor(t,e,n){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=n===!0,this.usage=Ns,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[t+i]=e.array[n+i];return this}copyArray(t){return this.array.set(t),this}copyColorsArray(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let o=t[i];o===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),o=new it),e[n++]=o.r,e[n++]=o.g,e[n++]=o.b}return this}copyVector2sArray(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let o=t[i];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),o=new j),e[n++]=o.x,e[n++]=o.y}return this}copyVector3sArray(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let o=t[i];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),o=new S),e[n++]=o.x,e[n++]=o.y,e[n++]=o.z}return this}copyVector4sArray(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let o=t[i];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",i),o=new Xt),e[n++]=o.x,e[n++]=o.y,e[n++]=o.z,e[n++]=o.w}return this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,n=this.count;e<n;e++)Co.fromBufferAttribute(this,e),Co.applyMatrix3(t),this.setXY(e,Co.x,Co.y);else if(this.itemSize===3)for(let e=0,n=this.count;e<n;e++)Yt.fromBufferAttribute(this,e),Yt.applyMatrix3(t),this.setXYZ(e,Yt.x,Yt.y,Yt.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)Yt.x=this.getX(e),Yt.y=this.getY(e),Yt.z=this.getZ(e),Yt.applyMatrix4(t),this.setXYZ(e,Yt.x,Yt.y,Yt.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)Yt.x=this.getX(e),Yt.y=this.getY(e),Yt.z=this.getZ(e),Yt.applyNormalMatrix(t),this.setXYZ(e,Yt.x,Yt.y,Yt.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)Yt.x=this.getX(e),Yt.y=this.getY(e),Yt.z=this.getZ(e),Yt.transformDirection(t),this.setXYZ(e,Yt.x,Yt.y,Yt.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){return this.array[t*this.itemSize]}setX(t,e){return this.array[t*this.itemSize]=e,this}getY(t){return this.array[t*this.itemSize+1]}setY(t,e){return this.array[t*this.itemSize+1]=e,this}getZ(t){return this.array[t*this.itemSize+2]}setZ(t,e){return this.array[t*this.itemSize+2]=e,this}getW(t){return this.array[t*this.itemSize+3]}setW(t,e){return this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,i){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this}setXYZW(t,e,n,i,r){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this.array[t+3]=r,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==Ns&&(t.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(t.updateRange=this.updateRange),t}}Nt.prototype.isBufferAttribute=!0;class Gm extends Nt{constructor(t,e,n){super(new Int8Array(t),e,n)}}class Xm extends Nt{constructor(t,e,n){super(new Uint8Array(t),e,n)}}class qm extends Nt{constructor(t,e,n){super(new Uint8ClampedArray(t),e,n)}}class Ym extends Nt{constructor(t,e,n){super(new Int16Array(t),e,n)}}class Ga extends Nt{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class jm extends Nt{constructor(t,e,n){super(new Int32Array(t),e,n)}}class Xa extends Nt{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class Jm extends Nt{constructor(t,e,n){super(new Uint16Array(t),e,n)}}Jm.prototype.isFloat16BufferAttribute=!0;class at extends Nt{constructor(t,e,n){super(new Float32Array(t),e,n)}}class Zm extends Nt{constructor(t,e,n){super(new Float64Array(t),e,n)}}function $m(s){if(s.length===0)return-1/0;let t=s[0];for(let e=1,n=s.length;e<n;++e)s[e]>t&&(t=s[e]);return t}const ay={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function Ds(s,t){return new ay[s](t)}let ly=0;const Xe=new ft,Bl=new It,xs=new S,Ue=new Ge,fr=new Ge,me=new S;class bt extends di{constructor(){super(),Object.defineProperty(this,"id",{value:ly++}),this.uuid=Ve(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new($m(t)>65535?Xa:Ga)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const r=new ue().getNormalMatrix(t);n.applyNormalMatrix(r),n.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(t),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return Xe.makeRotationFromQuaternion(t),this.applyMatrix4(Xe),this}rotateX(t){return Xe.makeRotationX(t),this.applyMatrix4(Xe),this}rotateY(t){return Xe.makeRotationY(t),this.applyMatrix4(Xe),this}rotateZ(t){return Xe.makeRotationZ(t),this.applyMatrix4(Xe),this}translate(t,e,n){return Xe.makeTranslation(t,e,n),this.applyMatrix4(Xe),this}scale(t,e,n){return Xe.makeScale(t,e,n),this.applyMatrix4(Xe),this}lookAt(t){return Bl.lookAt(t),Bl.updateMatrix(),this.applyMatrix4(Bl.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(xs).negate(),this.translate(xs.x,xs.y,xs.z),this}setFromPoints(t){const e=[];for(let n=0,i=t.length;n<i;n++){const r=t[n];e.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new at(e,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Ge);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new S(-1/0,-1/0,-1/0),new S(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let n=0,i=e.length;n<i;n++){const r=e[n];Ue.setFromBufferAttribute(r),this.morphTargetsRelative?(me.addVectors(this.boundingBox.min,Ue.min),this.boundingBox.expandByPoint(me),me.addVectors(this.boundingBox.max,Ue.max),this.boundingBox.expandByPoint(me)):(this.boundingBox.expandByPoint(Ue.min),this.boundingBox.expandByPoint(Ue.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new fi);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new S,1/0);return}if(t){const n=this.boundingSphere.center;if(Ue.setFromBufferAttribute(t),e)for(let r=0,o=e.length;r<o;r++){const a=e[r];fr.setFromBufferAttribute(a),this.morphTargetsRelative?(me.addVectors(Ue.min,fr.min),Ue.expandByPoint(me),me.addVectors(Ue.max,fr.max),Ue.expandByPoint(me)):(Ue.expandByPoint(fr.min),Ue.expandByPoint(fr.max))}Ue.getCenter(n);let i=0;for(let r=0,o=t.count;r<o;r++)me.fromBufferAttribute(t,r),i=Math.max(i,n.distanceToSquared(me));if(e)for(let r=0,o=e.length;r<o;r++){const a=e[r],l=this.morphTargetsRelative;for(let c=0,h=a.count;c<h;c++)me.fromBufferAttribute(a,c),l&&(xs.fromBufferAttribute(t,c),me.add(xs)),i=Math.max(i,n.distanceToSquared(me))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=t.array,i=e.position.array,r=e.normal.array,o=e.uv.array,a=i.length/3;e.tangent===void 0&&this.setAttribute("tangent",new Nt(new Float32Array(4*a),4));const l=e.tangent.array,c=[],h=[];for(let R=0;R<a;R++)c[R]=new S,h[R]=new S;const u=new S,d=new S,f=new S,p=new j,m=new j,y=new j,g=new S,x=new S;function v(R,C,U){u.fromArray(i,R*3),d.fromArray(i,C*3),f.fromArray(i,U*3),p.fromArray(o,R*2),m.fromArray(o,C*2),y.fromArray(o,U*2),d.sub(u),f.sub(u),m.sub(p),y.sub(p);const k=1/(m.x*y.y-y.x*m.y);isFinite(k)&&(g.copy(d).multiplyScalar(y.y).addScaledVector(f,-m.y).multiplyScalar(k),x.copy(f).multiplyScalar(m.x).addScaledVector(d,-y.x).multiplyScalar(k),c[R].add(g),c[C].add(g),c[U].add(g),h[R].add(x),h[C].add(x),h[U].add(x))}let _=this.groups;_.length===0&&(_=[{start:0,count:n.length}]);for(let R=0,C=_.length;R<C;++R){const U=_[R],k=U.start,B=U.count;for(let O=k,F=k+B;O<F;O+=3)v(n[O+0],n[O+1],n[O+2])}const M=new S,w=new S,b=new S,E=new S;function P(R){b.fromArray(r,R*3),E.copy(b);const C=c[R];M.copy(C),M.sub(b.multiplyScalar(b.dot(C))).normalize(),w.crossVectors(E,C);const k=w.dot(h[R])<0?-1:1;l[R*4]=M.x,l[R*4+1]=M.y,l[R*4+2]=M.z,l[R*4+3]=k}for(let R=0,C=_.length;R<C;++R){const U=_[R],k=U.start,B=U.count;for(let O=k,F=k+B;O<F;O+=3)P(n[O+0]),P(n[O+1]),P(n[O+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new Nt(new Float32Array(e.count*3),3),this.setAttribute("normal",n);else for(let d=0,f=n.count;d<f;d++)n.setXYZ(d,0,0,0);const i=new S,r=new S,o=new S,a=new S,l=new S,c=new S,h=new S,u=new S;if(t)for(let d=0,f=t.count;d<f;d+=3){const p=t.getX(d+0),m=t.getX(d+1),y=t.getX(d+2);i.fromBufferAttribute(e,p),r.fromBufferAttribute(e,m),o.fromBufferAttribute(e,y),h.subVectors(o,r),u.subVectors(i,r),h.cross(u),a.fromBufferAttribute(n,p),l.fromBufferAttribute(n,m),c.fromBufferAttribute(n,y),a.add(h),l.add(h),c.add(h),n.setXYZ(p,a.x,a.y,a.z),n.setXYZ(m,l.x,l.y,l.z),n.setXYZ(y,c.x,c.y,c.z)}else for(let d=0,f=e.count;d<f;d+=3)i.fromBufferAttribute(e,d+0),r.fromBufferAttribute(e,d+1),o.fromBufferAttribute(e,d+2),h.subVectors(o,r),u.subVectors(i,r),h.cross(u),n.setXYZ(d+0,h.x,h.y,h.z),n.setXYZ(d+1,h.x,h.y,h.z),n.setXYZ(d+2,h.x,h.y,h.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(t,e){if(!(t&&t.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);return}e===void 0&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const i in n){if(t.attributes[i]===void 0)continue;const o=n[i].array,a=t.attributes[i],l=a.array,c=a.itemSize*e,h=Math.min(l.length,o.length-c);for(let u=0,d=c;u<h;u++,d++)o[d]=l[u]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)me.fromBufferAttribute(t,e),me.normalize(),t.setXYZ(e,me.x,me.y,me.z)}toNonIndexed(){function t(a,l){const c=a.array,h=a.itemSize,u=a.normalized,d=new c.constructor(l.length*h);let f=0,p=0;for(let m=0,y=l.length;m<y;m++){a.isInterleavedBufferAttribute?f=l[m]*a.data.stride+a.offset:f=l[m]*h;for(let g=0;g<h;g++)d[p++]=c[f++]}return new Nt(d,h,u)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new bt,n=this.index.array,i=this.attributes;for(const a in i){const l=i[a],c=t(l,n);e.setAttribute(a,c)}const r=this.morphAttributes;for(const a in r){const l=[],c=r[a];for(let h=0,u=c.length;h<u;h++){const d=c[h],f=t(d,n);l.push(f)}e.morphAttributes[a]=l}e.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,l=o.length;a<l;a++){const c=o[a];e.addGroup(c.start,c.count,c.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(t[c]=l[c]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const l in n){const c=n[l];t.data.attributes[l]=c.toJSON(t.data)}const i={};let r=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],h=[];for(let u=0,d=c.length;u<d;u++){const f=c[u];h.push(f.toJSON(t.data))}h.length>0&&(i[l]=h,r=!0)}r&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(t.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(t.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),t}clone(){return new bt().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;n!==null&&this.setIndex(n.clone(e));const i=t.attributes;for(const c in i){const h=i[c];this.setAttribute(c,h.clone(e))}const r=t.morphAttributes;for(const c in r){const h=[],u=r[c];for(let d=0,f=u.length;d<f;d++)h.push(u[d].clone(e));this.morphAttributes[c]=h}this.morphTargetsRelative=t.morphTargetsRelative;const o=t.groups;for(let c=0,h=o.length;c<h;c++){const u=o[c];this.addGroup(u.start,u.count,u.materialIndex)}const a=t.boundingBox;a!==null&&(this.boundingBox=a.clone());const l=t.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}bt.prototype.isBufferGeometry=!0;const Ru=new ft,ys=new pi,Ol=new fi,Jn=new S,Zn=new S,$n=new S,zl=new S,Nl=new S,Hl=new S,Ro=new S,Po=new S,Do=new S,Io=new j,Fo=new j,ko=new j,Ul=new S,Bo=new S;class ce extends It{constructor(t=new bt,e=new Nn){super(),this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=i.length;r<o;r++){const a=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(t,e){const n=this.geometry,i=this.material,r=this.matrixWorld;if(i===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),Ol.copy(n.boundingSphere),Ol.applyMatrix4(r),t.ray.intersectsSphere(Ol)===!1)||(Ru.copy(r).invert(),ys.copy(t.ray).applyMatrix4(Ru),n.boundingBox!==null&&ys.intersectsBox(n.boundingBox)===!1))return;let o;if(n.isBufferGeometry){const a=n.index,l=n.attributes.position,c=n.morphAttributes.position,h=n.morphTargetsRelative,u=n.attributes.uv,d=n.attributes.uv2,f=n.groups,p=n.drawRange;if(a!==null)if(Array.isArray(i))for(let m=0,y=f.length;m<y;m++){const g=f[m],x=i[g.materialIndex],v=Math.max(g.start,p.start),_=Math.min(g.start+g.count,p.start+p.count);for(let M=v,w=_;M<w;M+=3){const b=a.getX(M),E=a.getX(M+1),P=a.getX(M+2);o=Oo(this,x,t,ys,l,c,h,u,d,b,E,P),o&&(o.faceIndex=Math.floor(M/3),o.face.materialIndex=g.materialIndex,e.push(o))}}else{const m=Math.max(0,p.start),y=Math.min(a.count,p.start+p.count);for(let g=m,x=y;g<x;g+=3){const v=a.getX(g),_=a.getX(g+1),M=a.getX(g+2);o=Oo(this,i,t,ys,l,c,h,u,d,v,_,M),o&&(o.faceIndex=Math.floor(g/3),e.push(o))}}else if(l!==void 0)if(Array.isArray(i))for(let m=0,y=f.length;m<y;m++){const g=f[m],x=i[g.materialIndex],v=Math.max(g.start,p.start),_=Math.min(g.start+g.count,p.start+p.count);for(let M=v,w=_;M<w;M+=3){const b=M,E=M+1,P=M+2;o=Oo(this,x,t,ys,l,c,h,u,d,b,E,P),o&&(o.faceIndex=Math.floor(M/3),o.face.materialIndex=g.materialIndex,e.push(o))}}else{const m=Math.max(0,p.start),y=Math.min(l.count,p.start+p.count);for(let g=m,x=y;g<x;g+=3){const v=g,_=g+1,M=g+2;o=Oo(this,i,t,ys,l,c,h,u,d,v,_,M),o&&(o.faceIndex=Math.floor(g/3),e.push(o))}}}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}ce.prototype.isMesh=!0;function cy(s,t,e,n,i,r,o,a){let l;if(t.side===se?l=n.intersectTriangle(o,r,i,!0,a):l=n.intersectTriangle(i,r,o,t.side!==Wi,a),l===null)return null;Bo.copy(a),Bo.applyMatrix4(s.matrixWorld);const c=e.ray.origin.distanceTo(Bo);return c<e.near||c>e.far?null:{distance:c,point:Bo.clone(),object:s}}function Oo(s,t,e,n,i,r,o,a,l,c,h,u){Jn.fromBufferAttribute(i,c),Zn.fromBufferAttribute(i,h),$n.fromBufferAttribute(i,u);const d=s.morphTargetInfluences;if(r&&d){Ro.set(0,0,0),Po.set(0,0,0),Do.set(0,0,0);for(let p=0,m=r.length;p<m;p++){const y=d[p],g=r[p];y!==0&&(zl.fromBufferAttribute(g,c),Nl.fromBufferAttribute(g,h),Hl.fromBufferAttribute(g,u),o?(Ro.addScaledVector(zl,y),Po.addScaledVector(Nl,y),Do.addScaledVector(Hl,y)):(Ro.addScaledVector(zl.sub(Jn),y),Po.addScaledVector(Nl.sub(Zn),y),Do.addScaledVector(Hl.sub($n),y)))}Jn.add(Ro),Zn.add(Po),$n.add(Do)}s.isSkinnedMesh&&(s.boneTransform(c,Jn),s.boneTransform(h,Zn),s.boneTransform(u,$n));const f=cy(s,t,e,n,Jn,Zn,$n,Ul);if(f){a&&(Io.fromBufferAttribute(a,c),Fo.fromBufferAttribute(a,h),ko.fromBufferAttribute(a,u),f.uv=re.getUV(Ul,Jn,Zn,$n,Io,Fo,ko,new j)),l&&(Io.fromBufferAttribute(l,c),Fo.fromBufferAttribute(l,h),ko.fromBufferAttribute(l,u),f.uv2=re.getUV(Ul,Jn,Zn,$n,Io,Fo,ko,new j));const p={a:c,b:h,c:u,normal:new S,materialIndex:0};re.getNormal(Jn,Zn,$n,p.normal),f.face=p}return f}class kn extends bt{constructor(t=1,e=1,n=1,i=1,r=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:i,heightSegments:r,depthSegments:o};const a=this;i=Math.floor(i),r=Math.floor(r),o=Math.floor(o);const l=[],c=[],h=[],u=[];let d=0,f=0;p("z","y","x",-1,-1,n,e,t,o,r,0),p("z","y","x",1,-1,n,e,-t,o,r,1),p("x","z","y",1,1,t,n,e,i,o,2),p("x","z","y",1,-1,t,n,-e,i,o,3),p("x","y","z",1,-1,t,e,n,i,r,4),p("x","y","z",-1,-1,t,e,-n,i,r,5),this.setIndex(l),this.setAttribute("position",new at(c,3)),this.setAttribute("normal",new at(h,3)),this.setAttribute("uv",new at(u,2));function p(m,y,g,x,v,_,M,w,b,E,P){const R=_/b,C=M/E,U=_/2,k=M/2,B=w/2,O=b+1,F=E+1;let N=0,Z=0;const tt=new S;for(let dt=0;dt<F;dt++){const nt=dt*C-k;for(let _t=0;_t<O;_t++){const X=_t*R-U;tt[m]=X*x,tt[y]=nt*v,tt[g]=B,c.push(tt.x,tt.y,tt.z),tt[m]=0,tt[y]=0,tt[g]=w>0?1:-1,h.push(tt.x,tt.y,tt.z),u.push(_t/b),u.push(1-dt/E),N+=1}}for(let dt=0;dt<E;dt++)for(let nt=0;nt<b;nt++){const _t=d+nt+O*dt,X=d+nt+O*(dt+1),K=d+(nt+1)+O*(dt+1),lt=d+(nt+1)+O*dt;l.push(_t,X,lt),l.push(X,K,lt),Z+=6}a.addGroup(f,Z,P),f+=Z,d+=N}}static fromJSON(t){return new kn(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function Us(s){const t={};for(const e in s){t[e]={};for(const n in s[e]){const i=s[e][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?t[e][n]=i.clone():Array.isArray(i)?t[e][n]=i.slice():t[e][n]=i}}return t}function Ae(s){const t={};for(let e=0;e<s.length;e++){const n=Us(s[e]);for(const i in n)t[i]=n[i]}return t}const Km={clone:Us,merge:Ae};var hy=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,uy=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class Bn extends ye{constructor(t){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=hy,this.fragmentShader=uy,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,t!==void 0&&(t.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=Us(t.uniforms),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const i in this.uniforms){const o=this.uniforms[i].value;o&&o.isTexture?e.uniforms[i]={type:"t",value:o.toJSON(t).uuid}:o&&o.isColor?e.uniforms[i]={type:"c",value:o.getHex()}:o&&o.isVector2?e.uniforms[i]={type:"v2",value:o.toArray()}:o&&o.isVector3?e.uniforms[i]={type:"v3",value:o.toArray()}:o&&o.isVector4?e.uniforms[i]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?e.uniforms[i]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?e.uniforms[i]={type:"m4",value:o.toArray()}:e.uniforms[i]={value:o}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const n={};for(const i in this.extensions)this.extensions[i]===!0&&(n[i]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}Bn.prototype.isShaderMaterial=!0;class co extends It{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new ft,this.projectionMatrix=new ft,this.projectionMatrixInverse=new ft}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}co.prototype.isCamera=!0;class ge extends co{constructor(t=50,e=1,n=.1,i=2e3){super(),this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=Xr*2*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(zi*.5*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return Xr*2*Math.atan(Math.tan(zi*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,n,i,r,o){this.aspect=t/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(zi*.5*this.fov)/this.zoom,n=2*e,i=this.aspect*n,r=-.5*i;const o=this.view;if(this.view!==null&&this.view.enabled){const l=o.fullWidth,c=o.fullHeight;r+=o.offsetX*i/l,e-=o.offsetY*n/c,i*=o.width/l,n*=o.height/c}const a=this.filmOffset;a!==0&&(r+=t*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,e,e-n,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}ge.prototype.isPerspectiveCamera=!0;const _s=90,vs=1;class qa extends It{constructor(t,e,n){if(super(),this.type="CubeCamera",n.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=n;const i=new ge(_s,vs,t,e);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new S(1,0,0)),this.add(i);const r=new ge(_s,vs,t,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new S(-1,0,0)),this.add(r);const o=new ge(_s,vs,t,e);o.layers=this.layers,o.up.set(0,0,1),o.lookAt(new S(0,1,0)),this.add(o);const a=new ge(_s,vs,t,e);a.layers=this.layers,a.up.set(0,0,-1),a.lookAt(new S(0,-1,0)),this.add(a);const l=new ge(_s,vs,t,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new S(0,0,1)),this.add(l);const c=new ge(_s,vs,t,e);c.layers=this.layers,c.up.set(0,-1,0),c.lookAt(new S(0,0,-1)),this.add(c)}update(t,e){this.parent===null&&this.updateMatrixWorld();const n=this.renderTarget,[i,r,o,a,l,c]=this.children,h=t.xr.enabled,u=t.getRenderTarget();t.xr.enabled=!1;const d=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0),t.render(e,i),t.setRenderTarget(n,1),t.render(e,r),t.setRenderTarget(n,2),t.render(e,o),t.setRenderTarget(n,3),t.render(e,a),t.setRenderTarget(n,4),t.render(e,l),n.texture.generateMipmaps=d,t.setRenderTarget(n,5),t.render(e,c),t.setRenderTarget(u),t.xr.enabled=h}}class sr extends fe{constructor(t,e,n,i,r,o,a,l,c,h){t=t!==void 0?t:[],e=e!==void 0?e:er,a=a!==void 0?a:Fn,super(t,e,n,i,r,o,a,l,c,h),this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}sr.prototype.isCubeTexture=!0;class Ya extends nn{constructor(t,e,n){Number.isInteger(e)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),e=n),super(t,t,e),e=e||{},this.texture=new sr(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=e.generateMipmaps!==void 0?e.generateMipmaps:!1,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:he,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.format=Fe,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new kn(5,5,5),r=new Bn({name:"CubemapFromEquirect",uniforms:Us(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:se,blending:In});r.uniforms.tEquirect.value=e;const o=new ce(i,r),a=e.minFilter;return e.minFilter===Qi&&(e.minFilter=he),new qa(1,10,this).update(t,o),e.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(t,e,n,i){const r=t.getRenderTarget();for(let o=0;o<6;o++)t.setRenderTarget(this,o),t.clear(e,n,i);t.setRenderTarget(r)}}Ya.prototype.isWebGLCubeRenderTarget=!0;const Vl=new S,dy=new S,fy=new ue;class fn{constructor(t=new S(1,0,0),e=0){this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,i){return this.normal.set(t,e,n),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const i=Vl.subVectors(n,e).cross(dy.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){const n=t.delta(Vl),i=this.normal.dot(n);if(i===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const r=-(t.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:e.copy(n).multiplyScalar(r).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||fy.getNormalMatrix(t),i=this.coplanarPoint(Vl).applyMatrix4(t),r=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}fn.prototype.isPlane=!0;const bs=new fi,zo=new S;class ho{constructor(t=new fn,e=new fn,n=new fn,i=new fn,r=new fn,o=new fn){this.planes=[t,e,n,i,r,o]}set(t,e,n,i,r,o){const a=this.planes;return a[0].copy(t),a[1].copy(e),a[2].copy(n),a[3].copy(i),a[4].copy(r),a[5].copy(o),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t){const e=this.planes,n=t.elements,i=n[0],r=n[1],o=n[2],a=n[3],l=n[4],c=n[5],h=n[6],u=n[7],d=n[8],f=n[9],p=n[10],m=n[11],y=n[12],g=n[13],x=n[14],v=n[15];return e[0].setComponents(a-i,u-l,m-d,v-y).normalize(),e[1].setComponents(a+i,u+l,m+d,v+y).normalize(),e[2].setComponents(a+r,u+c,m+f,v+g).normalize(),e[3].setComponents(a-r,u-c,m-f,v-g).normalize(),e[4].setComponents(a-o,u-h,m-p,v-x).normalize(),e[5].setComponents(a+o,u+h,m+p,v+x).normalize(),this}intersectsObject(t){const e=t.geometry;return e.boundingSphere===null&&e.computeBoundingSphere(),bs.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(bs)}intersectsSprite(t){return bs.center.set(0,0,0),bs.radius=.7071067811865476,bs.applyMatrix4(t.matrixWorld),this.intersectsSphere(bs)}intersectsSphere(t){const e=this.planes,n=t.center,i=-t.radius;for(let r=0;r<6;r++)if(e[r].distanceToPoint(n)<i)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const i=e[n];if(zo.x=i.normal.x>0?t.max.x:t.min.x,zo.y=i.normal.y>0?t.max.y:t.min.y,zo.z=i.normal.z>0?t.max.z:t.min.z,i.distanceToPoint(zo)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function Qm(){let s=null,t=!1,e=null,n=null;function i(r,o){e(r,o),n=s.requestAnimationFrame(i)}return{start:function(){t!==!0&&e!==null&&(n=s.requestAnimationFrame(i),t=!0)},stop:function(){s.cancelAnimationFrame(n),t=!1},setAnimationLoop:function(r){e=r},setContext:function(r){s=r}}}function py(s,t){const e=t.isWebGL2,n=new WeakMap;function i(c,h){const u=c.array,d=c.usage,f=s.createBuffer();s.bindBuffer(h,f),s.bufferData(h,u,d),c.onUploadCallback();let p=5126;return u instanceof Float32Array?p=5126:u instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):u instanceof Uint16Array?c.isFloat16BufferAttribute?e?p=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):p=5123:u instanceof Int16Array?p=5122:u instanceof Uint32Array?p=5125:u instanceof Int32Array?p=5124:u instanceof Int8Array?p=5120:(u instanceof Uint8Array||u instanceof Uint8ClampedArray)&&(p=5121),{buffer:f,type:p,bytesPerElement:u.BYTES_PER_ELEMENT,version:c.version}}function r(c,h,u){const d=h.array,f=h.updateRange;s.bindBuffer(u,c),f.count===-1?s.bufferSubData(u,0,d):(e?s.bufferSubData(u,f.offset*d.BYTES_PER_ELEMENT,d,f.offset,f.count):s.bufferSubData(u,f.offset*d.BYTES_PER_ELEMENT,d.subarray(f.offset,f.offset+f.count)),f.count=-1)}function o(c){return c.isInterleavedBufferAttribute&&(c=c.data),n.get(c)}function a(c){c.isInterleavedBufferAttribute&&(c=c.data);const h=n.get(c);h&&(s.deleteBuffer(h.buffer),n.delete(c))}function l(c,h){if(c.isGLBufferAttribute){const d=n.get(c);(!d||d.version<c.version)&&n.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);const u=n.get(c);u===void 0?n.set(c,i(c,h)):u.version<c.version&&(r(u.buffer,c,h),u.version=c.version)}return{get:o,remove:a,update:l}}class Xi extends bt{constructor(t=1,e=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:i};const r=t/2,o=e/2,a=Math.floor(n),l=Math.floor(i),c=a+1,h=l+1,u=t/a,d=e/l,f=[],p=[],m=[],y=[];for(let g=0;g<h;g++){const x=g*d-o;for(let v=0;v<c;v++){const _=v*u-r;p.push(_,-x,0),m.push(0,0,1),y.push(v/a),y.push(1-g/l)}}for(let g=0;g<l;g++)for(let x=0;x<a;x++){const v=x+c*g,_=x+c*(g+1),M=x+1+c*(g+1),w=x+1+c*g;f.push(v,_,w),f.push(_,M,w)}this.setIndex(f),this.setAttribute("position",new at(p,3)),this.setAttribute("normal",new at(m,3)),this.setAttribute("uv",new at(y,2))}static fromJSON(t){return new Xi(t.width,t.height,t.widthSegments,t.heightSegments)}}var my=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,gy=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,xy=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,yy=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,_y=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,vy=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,by="vec3 transformed = vec3( position );",My=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,wy=`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotVH = saturate( dot( geometry.viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float NoH ) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float NoV, float NoL ) {
	return saturate( 1.0 / ( 4.0 * ( NoL + NoV - NoL * NoV ) ) );
}
vec3 BRDF_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`,Sy=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,Ty=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,Ey=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,Ay=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,Ly=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,Cy=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,Ry=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,Py=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,Dy=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,Iy=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,Fy=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,ky=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,By=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,Oy=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,zy=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,Ny=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,Hy="gl_FragColor = linearToOutputTexel( gl_FragColor );",Uy=`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,Vy=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
		envColor = envMapTexelToLinear( envColor );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,Wy=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,Gy=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,Xy=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,qy=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,Yy=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,jy=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,Jy=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,Zy=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,$y=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,Ky=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		lightMapIrradiance *= PI;
	#endif
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,Qy=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,t_=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`,e_=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,n_=`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getIBLIrradiance( const in GeometricContext geometry ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec;
			#ifdef ENVMAP_MODE_REFLECTION
				reflectVec = reflect( - viewDir, normal );
				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			#else
				reflectVec = refract( - viewDir, normal, refractionRatio );
			#endif
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,i_=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,s_=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,r_=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,o_=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,a_=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularTintFactor = specularTint;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARTINTMAP
			specularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularTintFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenTint = sheenTint;
#endif`,l_=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenTint;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += irradiance * BRDF_Sheen( material.roughness, directLight.direction, geometry, material.sheenTint );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,c_=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,h_=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,u_=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,d_=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,f_=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,p_=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,m_=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,g_=`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,x_=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,y_=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,__=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,v_=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,b_=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,M_=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`,w_=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,S_=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`,T_=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,E_=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,A_=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,L_=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,C_=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,R_=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,P_=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,D_=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,I_=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,F_=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,k_=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,B_=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,O_=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,z_=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,N_=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,H_=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,U_=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,V_=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,W_=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,G_=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,X_=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,q_=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,Y_=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,j_=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,J_=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,Z_=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,$_=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,K_=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,Q_=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,tv=`#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationTint, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = transmission.a;
#endif`,ev=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationTint;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( float roughness, float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef TEXTURE_LOD_EXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,
		vec3 attenuationColor, float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,nv=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,iv=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,sv=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,rv=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,ov=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,av=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,lv=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,cv=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,hv=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,uv=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,dv=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,fv=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,pv=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,mv=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,gv=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,xv=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,yv=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,_v=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,vv=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,bv=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Mv=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,wv=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Sv=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Tv=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Ev=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,Av=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,Lv=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,Cv=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Rv=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Pv=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularTint;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARTINTMAP
		uniform sampler2D specularTintMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenTint;
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Dv=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,Iv=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Fv=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,kv=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Bv=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,Ov=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,zv=`#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Nv=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,Hv=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`;const Dt={alphamap_fragment:my,alphamap_pars_fragment:gy,alphatest_fragment:xy,alphatest_pars_fragment:yy,aomap_fragment:_y,aomap_pars_fragment:vy,begin_vertex:by,beginnormal_vertex:My,bsdfs:wy,bumpmap_pars_fragment:Sy,clipping_planes_fragment:Ty,clipping_planes_pars_fragment:Ey,clipping_planes_pars_vertex:Ay,clipping_planes_vertex:Ly,color_fragment:Cy,color_pars_fragment:Ry,color_pars_vertex:Py,color_vertex:Dy,common:Iy,cube_uv_reflection_fragment:Fy,defaultnormal_vertex:ky,displacementmap_pars_vertex:By,displacementmap_vertex:Oy,emissivemap_fragment:zy,emissivemap_pars_fragment:Ny,encodings_fragment:Hy,encodings_pars_fragment:Uy,envmap_fragment:Vy,envmap_common_pars_fragment:Wy,envmap_pars_fragment:Gy,envmap_pars_vertex:Xy,envmap_physical_pars_fragment:n_,envmap_vertex:qy,fog_vertex:Yy,fog_pars_vertex:jy,fog_fragment:Jy,fog_pars_fragment:Zy,gradientmap_pars_fragment:$y,lightmap_fragment:Ky,lightmap_pars_fragment:Qy,lights_lambert_vertex:t_,lights_pars_begin:e_,lights_toon_fragment:i_,lights_toon_pars_fragment:s_,lights_phong_fragment:r_,lights_phong_pars_fragment:o_,lights_physical_fragment:a_,lights_physical_pars_fragment:l_,lights_fragment_begin:c_,lights_fragment_maps:h_,lights_fragment_end:u_,logdepthbuf_fragment:d_,logdepthbuf_pars_fragment:f_,logdepthbuf_pars_vertex:p_,logdepthbuf_vertex:m_,map_fragment:g_,map_pars_fragment:x_,map_particle_fragment:y_,map_particle_pars_fragment:__,metalnessmap_fragment:v_,metalnessmap_pars_fragment:b_,morphnormal_vertex:M_,morphtarget_pars_vertex:w_,morphtarget_vertex:S_,normal_fragment_begin:T_,normal_fragment_maps:E_,normal_pars_fragment:A_,normal_pars_vertex:L_,normal_vertex:C_,normalmap_pars_fragment:R_,clearcoat_normal_fragment_begin:P_,clearcoat_normal_fragment_maps:D_,clearcoat_pars_fragment:I_,output_fragment:F_,packing:k_,premultiplied_alpha_fragment:B_,project_vertex:O_,dithering_fragment:z_,dithering_pars_fragment:N_,roughnessmap_fragment:H_,roughnessmap_pars_fragment:U_,shadowmap_pars_fragment:V_,shadowmap_pars_vertex:W_,shadowmap_vertex:G_,shadowmask_pars_fragment:X_,skinbase_vertex:q_,skinning_pars_vertex:Y_,skinning_vertex:j_,skinnormal_vertex:J_,specularmap_fragment:Z_,specularmap_pars_fragment:$_,tonemapping_fragment:K_,tonemapping_pars_fragment:Q_,transmission_fragment:tv,transmission_pars_fragment:ev,uv_pars_fragment:nv,uv_pars_vertex:iv,uv_vertex:sv,uv2_pars_fragment:rv,uv2_pars_vertex:ov,uv2_vertex:av,worldpos_vertex:lv,background_frag:cv,background_vert:hv,cube_frag:uv,cube_vert:dv,depth_frag:fv,depth_vert:pv,distanceRGBA_frag:mv,distanceRGBA_vert:gv,equirect_frag:xv,equirect_vert:yv,linedashed_frag:_v,linedashed_vert:vv,meshbasic_frag:bv,meshbasic_vert:Mv,meshlambert_frag:wv,meshlambert_vert:Sv,meshmatcap_frag:Tv,meshmatcap_vert:Ev,meshnormal_frag:Av,meshnormal_vert:Lv,meshphong_frag:Cv,meshphong_vert:Rv,meshphysical_frag:Pv,meshphysical_vert:Dv,meshtoon_frag:Iv,meshtoon_vert:Fv,points_frag:kv,points_vert:Bv,shadow_frag:Ov,shadow_vert:zv,sprite_frag:Nv,sprite_vert:Hv},et={common:{diffuse:{value:new it(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new ue},uv2Transform:{value:new ue},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new j(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new it(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new it(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new ue}},sprite:{diffuse:{value:new it(16777215)},opacity:{value:1},center:{value:new j(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new ue}}},tn={basic:{uniforms:Ae([et.common,et.specularmap,et.envmap,et.aomap,et.lightmap,et.fog]),vertexShader:Dt.meshbasic_vert,fragmentShader:Dt.meshbasic_frag},lambert:{uniforms:Ae([et.common,et.specularmap,et.envmap,et.aomap,et.lightmap,et.emissivemap,et.fog,et.lights,{emissive:{value:new it(0)}}]),vertexShader:Dt.meshlambert_vert,fragmentShader:Dt.meshlambert_frag},phong:{uniforms:Ae([et.common,et.specularmap,et.envmap,et.aomap,et.lightmap,et.emissivemap,et.bumpmap,et.normalmap,et.displacementmap,et.fog,et.lights,{emissive:{value:new it(0)},specular:{value:new it(1118481)},shininess:{value:30}}]),vertexShader:Dt.meshphong_vert,fragmentShader:Dt.meshphong_frag},standard:{uniforms:Ae([et.common,et.envmap,et.aomap,et.lightmap,et.emissivemap,et.bumpmap,et.normalmap,et.displacementmap,et.roughnessmap,et.metalnessmap,et.fog,et.lights,{emissive:{value:new it(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Dt.meshphysical_vert,fragmentShader:Dt.meshphysical_frag},toon:{uniforms:Ae([et.common,et.aomap,et.lightmap,et.emissivemap,et.bumpmap,et.normalmap,et.displacementmap,et.gradientmap,et.fog,et.lights,{emissive:{value:new it(0)}}]),vertexShader:Dt.meshtoon_vert,fragmentShader:Dt.meshtoon_frag},matcap:{uniforms:Ae([et.common,et.bumpmap,et.normalmap,et.displacementmap,et.fog,{matcap:{value:null}}]),vertexShader:Dt.meshmatcap_vert,fragmentShader:Dt.meshmatcap_frag},points:{uniforms:Ae([et.points,et.fog]),vertexShader:Dt.points_vert,fragmentShader:Dt.points_frag},dashed:{uniforms:Ae([et.common,et.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Dt.linedashed_vert,fragmentShader:Dt.linedashed_frag},depth:{uniforms:Ae([et.common,et.displacementmap]),vertexShader:Dt.depth_vert,fragmentShader:Dt.depth_frag},normal:{uniforms:Ae([et.common,et.bumpmap,et.normalmap,et.displacementmap,{opacity:{value:1}}]),vertexShader:Dt.meshnormal_vert,fragmentShader:Dt.meshnormal_frag},sprite:{uniforms:Ae([et.sprite,et.fog]),vertexShader:Dt.sprite_vert,fragmentShader:Dt.sprite_frag},background:{uniforms:{uvTransform:{value:new ue},t2D:{value:null}},vertexShader:Dt.background_vert,fragmentShader:Dt.background_frag},cube:{uniforms:Ae([et.envmap,{opacity:{value:1}}]),vertexShader:Dt.cube_vert,fragmentShader:Dt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Dt.equirect_vert,fragmentShader:Dt.equirect_frag},distanceRGBA:{uniforms:Ae([et.common,et.displacementmap,{referencePosition:{value:new S},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Dt.distanceRGBA_vert,fragmentShader:Dt.distanceRGBA_frag},shadow:{uniforms:Ae([et.lights,et.fog,{color:{value:new it(0)},opacity:{value:1}}]),vertexShader:Dt.shadow_vert,fragmentShader:Dt.shadow_frag}};tn.physical={uniforms:Ae([tn.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new j(1,1)},clearcoatNormalMap:{value:null},sheenTint:{value:new it(0)},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new j},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationTint:{value:new it(0)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularTint:{value:new it(1,1,1)},specularTintMap:{value:null}}]),vertexShader:Dt.meshphysical_vert,fragmentShader:Dt.meshphysical_frag};function Uv(s,t,e,n,i){const r=new it(0);let o=0,a,l,c=null,h=0,u=null;function d(p,m){let y=!1,g=m.isScene===!0?m.background:null;g&&g.isTexture&&(g=t.get(g));const x=s.xr,v=x.getSession&&x.getSession();v&&v.environmentBlendMode==="additive"&&(g=null),g===null?f(r,o):g&&g.isColor&&(f(g,1),y=!0),(s.autoClear||y)&&s.clear(s.autoClearColor,s.autoClearDepth,s.autoClearStencil),g&&(g.isCubeTexture||g.mapping===ir)?(l===void 0&&(l=new ce(new kn(1,1,1),new Bn({name:"BackgroundCubeMaterial",uniforms:Us(tn.cube.uniforms),vertexShader:tn.cube.vertexShader,fragmentShader:tn.cube.fragmentShader,side:se,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),l.geometry.deleteAttribute("uv"),l.onBeforeRender=function(_,M,w){this.matrixWorld.copyPosition(w.matrixWorld)},Object.defineProperty(l.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),n.update(l)),l.material.uniforms.envMap.value=g,l.material.uniforms.flipEnvMap.value=g.isCubeTexture&&g.isRenderTargetTexture===!1?-1:1,(c!==g||h!==g.version||u!==s.toneMapping)&&(l.material.needsUpdate=!0,c=g,h=g.version,u=s.toneMapping),p.unshift(l,l.geometry,l.material,0,0,null)):g&&g.isTexture&&(a===void 0&&(a=new ce(new Xi(2,2),new Bn({name:"BackgroundMaterial",uniforms:Us(tn.background.uniforms),vertexShader:tn.background.vertexShader,fragmentShader:tn.background.fragmentShader,side:Vi,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),Object.defineProperty(a.material,"map",{get:function(){return this.uniforms.t2D.value}}),n.update(a)),a.material.uniforms.t2D.value=g,g.matrixAutoUpdate===!0&&g.updateMatrix(),a.material.uniforms.uvTransform.value.copy(g.matrix),(c!==g||h!==g.version||u!==s.toneMapping)&&(a.material.needsUpdate=!0,c=g,h=g.version,u=s.toneMapping),p.unshift(a,a.geometry,a.material,0,0,null))}function f(p,m){e.buffers.color.setClear(p.r,p.g,p.b,m,i)}return{getClearColor:function(){return r},setClearColor:function(p,m=1){r.set(p),o=m,f(r,o)},getClearAlpha:function(){return o},setClearAlpha:function(p){o=p,f(r,o)},render:d}}function Vv(s,t,e,n){const i=s.getParameter(34921),r=n.isWebGL2?null:t.get("OES_vertex_array_object"),o=n.isWebGL2||r!==null,a={},l=m(null);let c=l;function h(k,B,O,F,N){let Z=!1;if(o){const tt=p(F,O,B);c!==tt&&(c=tt,d(c.object)),Z=y(F,N),Z&&g(F,N)}else{const tt=B.wireframe===!0;(c.geometry!==F.id||c.program!==O.id||c.wireframe!==tt)&&(c.geometry=F.id,c.program=O.id,c.wireframe=tt,Z=!0)}k.isInstancedMesh===!0&&(Z=!0),N!==null&&e.update(N,34963),Z&&(b(k,B,O,F),N!==null&&s.bindBuffer(34963,e.get(N).buffer))}function u(){return n.isWebGL2?s.createVertexArray():r.createVertexArrayOES()}function d(k){return n.isWebGL2?s.bindVertexArray(k):r.bindVertexArrayOES(k)}function f(k){return n.isWebGL2?s.deleteVertexArray(k):r.deleteVertexArrayOES(k)}function p(k,B,O){const F=O.wireframe===!0;let N=a[k.id];N===void 0&&(N={},a[k.id]=N);let Z=N[B.id];Z===void 0&&(Z={},N[B.id]=Z);let tt=Z[F];return tt===void 0&&(tt=m(u()),Z[F]=tt),tt}function m(k){const B=[],O=[],F=[];for(let N=0;N<i;N++)B[N]=0,O[N]=0,F[N]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:B,enabledAttributes:O,attributeDivisors:F,object:k,attributes:{},index:null}}function y(k,B){const O=c.attributes,F=k.attributes;let N=0;for(const Z in F){const tt=O[Z],dt=F[Z];if(tt===void 0||tt.attribute!==dt||tt.data!==dt.data)return!0;N++}return c.attributesNum!==N||c.index!==B}function g(k,B){const O={},F=k.attributes;let N=0;for(const Z in F){const tt=F[Z],dt={};dt.attribute=tt,tt.data&&(dt.data=tt.data),O[Z]=dt,N++}c.attributes=O,c.attributesNum=N,c.index=B}function x(){const k=c.newAttributes;for(let B=0,O=k.length;B<O;B++)k[B]=0}function v(k){_(k,0)}function _(k,B){const O=c.newAttributes,F=c.enabledAttributes,N=c.attributeDivisors;O[k]=1,F[k]===0&&(s.enableVertexAttribArray(k),F[k]=1),N[k]!==B&&((n.isWebGL2?s:t.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](k,B),N[k]=B)}function M(){const k=c.newAttributes,B=c.enabledAttributes;for(let O=0,F=B.length;O<F;O++)B[O]!==k[O]&&(s.disableVertexAttribArray(O),B[O]=0)}function w(k,B,O,F,N,Z){n.isWebGL2===!0&&(O===5124||O===5125)?s.vertexAttribIPointer(k,B,O,N,Z):s.vertexAttribPointer(k,B,O,F,N,Z)}function b(k,B,O,F){if(n.isWebGL2===!1&&(k.isInstancedMesh||F.isInstancedBufferGeometry)&&t.get("ANGLE_instanced_arrays")===null)return;x();const N=F.attributes,Z=O.getAttributes(),tt=B.defaultAttributeValues;for(const dt in Z){const nt=Z[dt];if(nt.location>=0){let _t=N[dt];if(_t===void 0&&(dt==="instanceMatrix"&&k.instanceMatrix&&(_t=k.instanceMatrix),dt==="instanceColor"&&k.instanceColor&&(_t=k.instanceColor)),_t!==void 0){const X=_t.normalized,K=_t.itemSize,lt=e.get(_t);if(lt===void 0)continue;const H=lt.buffer,vt=lt.type,Tt=lt.bytesPerElement;if(_t.isInterleavedBufferAttribute){const ut=_t.data,pt=ut.stride,Ct=_t.offset;if(ut&&ut.isInstancedInterleavedBuffer){for(let G=0;G<nt.locationSize;G++)_(nt.location+G,ut.meshPerAttribute);k.isInstancedMesh!==!0&&F._maxInstanceCount===void 0&&(F._maxInstanceCount=ut.meshPerAttribute*ut.count)}else for(let G=0;G<nt.locationSize;G++)v(nt.location+G);s.bindBuffer(34962,H);for(let G=0;G<nt.locationSize;G++)w(nt.location+G,K/nt.locationSize,vt,X,pt*Tt,(Ct+K/nt.locationSize*G)*Tt)}else{if(_t.isInstancedBufferAttribute){for(let ut=0;ut<nt.locationSize;ut++)_(nt.location+ut,_t.meshPerAttribute);k.isInstancedMesh!==!0&&F._maxInstanceCount===void 0&&(F._maxInstanceCount=_t.meshPerAttribute*_t.count)}else for(let ut=0;ut<nt.locationSize;ut++)v(nt.location+ut);s.bindBuffer(34962,H);for(let ut=0;ut<nt.locationSize;ut++)w(nt.location+ut,K/nt.locationSize,vt,X,K*Tt,K/nt.locationSize*ut*Tt)}}else if(tt!==void 0){const X=tt[dt];if(X!==void 0)switch(X.length){case 2:s.vertexAttrib2fv(nt.location,X);break;case 3:s.vertexAttrib3fv(nt.location,X);break;case 4:s.vertexAttrib4fv(nt.location,X);break;default:s.vertexAttrib1fv(nt.location,X)}}}}M()}function E(){C();for(const k in a){const B=a[k];for(const O in B){const F=B[O];for(const N in F)f(F[N].object),delete F[N];delete B[O]}delete a[k]}}function P(k){if(a[k.id]===void 0)return;const B=a[k.id];for(const O in B){const F=B[O];for(const N in F)f(F[N].object),delete F[N];delete B[O]}delete a[k.id]}function R(k){for(const B in a){const O=a[B];if(O[k.id]===void 0)continue;const F=O[k.id];for(const N in F)f(F[N].object),delete F[N];delete O[k.id]}}function C(){U(),c!==l&&(c=l,d(c.object))}function U(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:h,reset:C,resetDefaultState:U,dispose:E,releaseStatesOfGeometry:P,releaseStatesOfProgram:R,initAttributes:x,enableAttribute:v,disableUnusedAttributes:M}}function Wv(s,t,e,n){const i=n.isWebGL2;let r;function o(c){r=c}function a(c,h){s.drawArrays(r,c,h),e.update(h,r,1)}function l(c,h,u){if(u===0)return;let d,f;if(i)d=s,f="drawArraysInstanced";else if(d=t.get("ANGLE_instanced_arrays"),f="drawArraysInstancedANGLE",d===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}d[f](r,c,h,u),e.update(h,r,u)}this.setMode=o,this.render=a,this.renderInstances=l}function Gv(s,t,e){let n;function i(){if(n!==void 0)return n;if(t.has("EXT_texture_filter_anisotropic")===!0){const b=t.get("EXT_texture_filter_anisotropic");n=s.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n}function r(b){if(b==="highp"){if(s.getShaderPrecisionFormat(35633,36338).precision>0&&s.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";b="mediump"}return b==="mediump"&&s.getShaderPrecisionFormat(35633,36337).precision>0&&s.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext<"u"&&s instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext<"u"&&s instanceof WebGL2ComputeRenderingContext;let a=e.precision!==void 0?e.precision:"highp";const l=r(a);l!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",l,"instead."),a=l);const c=o||t.has("WEBGL_draw_buffers"),h=e.logarithmicDepthBuffer===!0,u=s.getParameter(34930),d=s.getParameter(35660),f=s.getParameter(3379),p=s.getParameter(34076),m=s.getParameter(34921),y=s.getParameter(36347),g=s.getParameter(36348),x=s.getParameter(36349),v=d>0,_=o||t.has("OES_texture_float"),M=v&&_,w=o?s.getParameter(36183):0;return{isWebGL2:o,drawBuffers:c,getMaxAnisotropy:i,getMaxPrecision:r,precision:a,logarithmicDepthBuffer:h,maxTextures:u,maxVertexTextures:d,maxTextureSize:f,maxCubemapSize:p,maxAttributes:m,maxVertexUniforms:y,maxVaryings:g,maxFragmentUniforms:x,vertexTextures:v,floatFragmentTextures:_,floatVertexTextures:M,maxSamples:w}}function Xv(s){const t=this;let e=null,n=0,i=!1,r=!1;const o=new fn,a=new ue,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(u,d,f){const p=u.length!==0||d||n!==0||i;return i=d,e=h(u,f,0),n=u.length,p},this.beginShadows=function(){r=!0,h(null)},this.endShadows=function(){r=!1,c()},this.setState=function(u,d,f){const p=u.clippingPlanes,m=u.clipIntersection,y=u.clipShadows,g=s.get(u);if(!i||p===null||p.length===0||r&&!y)r?h(null):c();else{const x=r?0:n,v=x*4;let _=g.clippingState||null;l.value=_,_=h(p,d,v,f);for(let M=0;M!==v;++M)_[M]=e[M];g.clippingState=_,this.numIntersection=m?this.numPlanes:0,this.numPlanes+=x}};function c(){l.value!==e&&(l.value=e,l.needsUpdate=n>0),t.numPlanes=n,t.numIntersection=0}function h(u,d,f,p){const m=u!==null?u.length:0;let y=null;if(m!==0){if(y=l.value,p!==!0||y===null){const g=f+m*4,x=d.matrixWorldInverse;a.getNormalMatrix(x),(y===null||y.length<g)&&(y=new Float32Array(g));for(let v=0,_=f;v!==m;++v,_+=4)o.copy(u[v]).applyMatrix4(x,a),o.normal.toArray(y,_),y[_+3]=o.constant}l.value=y,l.needsUpdate=!0}return t.numPlanes=m,t.numIntersection=0,y}}function qv(s){let t=new WeakMap;function e(o,a){return a===Or?o.mapping=er:a===zr&&(o.mapping=nr),o}function n(o){if(o&&o.isTexture&&o.isRenderTargetTexture===!1){const a=o.mapping;if(a===Or||a===zr)if(t.has(o)){const l=t.get(o).texture;return e(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const c=s.getRenderTarget(),h=new Ya(l.height/2);return h.fromEquirectangularTexture(s,o),t.set(o,h),s.setRenderTarget(c),o.addEventListener("dispose",i),e(h.texture,o.mapping)}else return null}}return o}function i(o){const a=o.target;a.removeEventListener("dispose",i);const l=t.get(a);l!==void 0&&(t.delete(a),l.dispose())}function r(){t=new WeakMap}return{get:n,dispose:r}}class uo extends co{constructor(t=-1,e=1,n=1,i=-1,r=.1,o=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=i,this.near=r,this.far=o,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,n,i,r,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=n-t,o=n+t,a=i+e,l=i-e;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,h=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=c*this.view.offsetX,o=r+c*this.view.width,a-=h*this.view.offsetY,l=a-h*this.view.height}this.projectionMatrix.makeOrthographic(r,o,a,l,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}uo.prototype.isOrthographicCamera=!0;class rr extends Bn{constructor(t){super(t),this.type="RawShaderMaterial"}}rr.prototype.isRawShaderMaterial=!0;const Bs=4,ii=8,un=Math.pow(2,ii),tg=[.125,.215,.35,.446,.526,.582],eg=ii-Bs+1+tg.length,Ms=20,pn={[ke]:0,[lo]:1,[Wa]:2,[sh]:3,[rh]:4,[oh]:5,[Va]:6},Wl=new uo,{_lodPlanes:pr,_sizeLods:Pu,_sigmas:No}=jv(),Du=new it;let Gl=null;const Li=(1+Math.sqrt(5))/2,ws=1/Li,Iu=[new S(1,1,1),new S(-1,1,1),new S(1,1,-1),new S(-1,1,-1),new S(0,Li,ws),new S(0,Li,-ws),new S(ws,0,Li),new S(-ws,0,Li),new S(Li,ws,0),new S(-Li,ws,0)];class ng{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._blurMaterial=Jv(Ms),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,n=.1,i=100){Gl=this._renderer.getRenderTarget();const r=this._allocateTargets();return this._sceneToCubeUV(t,n,i,r),e>0&&this._blur(r,0,0,e),this._applyPMREM(r),this._cleanup(r),r}fromEquirectangular(t){return this._fromTexture(t)}fromCubemap(t){return this._fromTexture(t)}compileCubemapShader(){this._cubemapShader===null&&(this._cubemapShader=Bu(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){this._equirectShader===null&&(this._equirectShader=ku(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let t=0;t<pr.length;t++)pr[t].dispose()}_cleanup(t){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(Gl),t.scissorTest=!1,Ho(t,0,0,t.width,t.height)}_fromTexture(t){Gl=this._renderer.getRenderTarget();const e=this._allocateTargets(t);return this._textureToCubeUV(t,e),this._applyPMREM(e),this._cleanup(e),e}_allocateTargets(t){const e={magFilter:le,minFilter:le,generateMipmaps:!1,type:Gi,format:jp,encoding:Yv(t)?t.encoding:Wa,depthBuffer:!1},n=Fu(e);return n.depthBuffer=!t,this._pingPongRenderTarget=Fu(e),n}_compileMaterial(t){const e=new ce(pr[0],t);this._renderer.compile(e,Wl)}_sceneToCubeUV(t,e,n,i){const a=new ge(90,1,e,n),l=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],h=this._renderer,u=h.autoClear,d=h.outputEncoding,f=h.toneMapping;h.getClearColor(Du),h.toneMapping=ni,h.outputEncoding=ke,h.autoClear=!1;const p=new Nn({name:"PMREM.Background",side:se,depthWrite:!1,depthTest:!1}),m=new ce(new kn,p);let y=!1;const g=t.background;g?g.isColor&&(p.color.copy(g),t.background=null,y=!0):(p.color.copy(Du),y=!0);for(let x=0;x<6;x++){const v=x%3;v==0?(a.up.set(0,l[x],0),a.lookAt(c[x],0,0)):v==1?(a.up.set(0,0,l[x]),a.lookAt(0,c[x],0)):(a.up.set(0,l[x],0),a.lookAt(0,0,c[x])),Ho(i,v*un,x>2?un:0,un,un),h.setRenderTarget(i),y&&h.render(m,a),h.render(t,a)}m.geometry.dispose(),m.material.dispose(),h.toneMapping=f,h.outputEncoding=d,h.autoClear=u,t.background=g}_textureToCubeUV(t,e){const n=this._renderer;t.isCubeTexture?this._cubemapShader==null&&(this._cubemapShader=Bu()):this._equirectShader==null&&(this._equirectShader=ku());const i=t.isCubeTexture?this._cubemapShader:this._equirectShader,r=new ce(pr[0],i),o=i.uniforms;o.envMap.value=t,t.isCubeTexture||o.texelSize.value.set(1/t.image.width,1/t.image.height),o.inputEncoding.value=pn[t.encoding],o.outputEncoding.value=pn[e.texture.encoding],Ho(e,0,0,3*un,2*un),n.setRenderTarget(e),n.render(r,Wl)}_applyPMREM(t){const e=this._renderer,n=e.autoClear;e.autoClear=!1;for(let i=1;i<eg;i++){const r=Math.sqrt(No[i]*No[i]-No[i-1]*No[i-1]),o=Iu[(i-1)%Iu.length];this._blur(t,i-1,i,r,o)}e.autoClear=n}_blur(t,e,n,i,r){const o=this._pingPongRenderTarget;this._halfBlur(t,o,e,n,i,"latitudinal",r),this._halfBlur(o,t,n,n,i,"longitudinal",r)}_halfBlur(t,e,n,i,r,o,a){const l=this._renderer,c=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const h=3,u=new ce(pr[i],c),d=c.uniforms,f=Pu[n]-1,p=isFinite(r)?Math.PI/(2*f):2*Math.PI/(2*Ms-1),m=r/p,y=isFinite(r)?1+Math.floor(h*m):Ms;y>Ms&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${y} samples when the maximum is set to ${Ms}`);const g=[];let x=0;for(let w=0;w<Ms;++w){const b=w/m,E=Math.exp(-b*b/2);g.push(E),w==0?x+=E:w<y&&(x+=2*E)}for(let w=0;w<g.length;w++)g[w]=g[w]/x;d.envMap.value=t.texture,d.samples.value=y,d.weights.value=g,d.latitudinal.value=o==="latitudinal",a&&(d.poleAxis.value=a),d.dTheta.value=p,d.mipInt.value=ii-n,d.inputEncoding.value=pn[t.texture.encoding],d.outputEncoding.value=pn[t.texture.encoding];const v=Pu[i],_=3*Math.max(0,un-2*v),M=(i===0?0:2*un)+2*v*(i>ii-Bs?i-ii+Bs:0);Ho(e,_,M,3*v,2*v),l.setRenderTarget(e),l.render(u,Wl)}}function Yv(s){return s===void 0||s.type!==Gi?!1:s.encoding===ke||s.encoding===lo||s.encoding===Va}function jv(){const s=[],t=[],e=[];let n=ii;for(let i=0;i<eg;i++){const r=Math.pow(2,n);t.push(r);let o=1/r;i>ii-Bs?o=tg[i-ii+Bs-1]:i==0&&(o=0),e.push(o);const a=1/(r-1),l=-a/2,c=1+a/2,h=[l,l,c,l,c,c,l,l,c,c,l,c],u=6,d=6,f=3,p=2,m=1,y=new Float32Array(f*d*u),g=new Float32Array(p*d*u),x=new Float32Array(m*d*u);for(let _=0;_<u;_++){const M=_%3*2/3-1,w=_>2?0:-1,b=[M,w,0,M+2/3,w,0,M+2/3,w+1,0,M,w,0,M+2/3,w+1,0,M,w+1,0];y.set(b,f*d*_),g.set(h,p*d*_);const E=[_,_,_,_,_,_];x.set(E,m*d*_)}const v=new bt;v.setAttribute("position",new Nt(y,f)),v.setAttribute("uv",new Nt(g,p)),v.setAttribute("faceIndex",new Nt(x,m)),s.push(v),n>Bs&&n--}return{_lodPlanes:s,_sizeLods:t,_sigmas:e}}function Fu(s){const t=new nn(3*un,3*un,s);return t.texture.mapping=ir,t.texture.name="PMREM.cubeUv",t.scissorTest=!0,t}function Ho(s,t,e,n,i){s.viewport.set(t,e,n,i),s.scissor.set(t,e,n,i)}function Jv(s){const t=new Float32Array(s),e=new S(0,1,0);return new rr({name:"SphericalGaussianBlur",defines:{n:s},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:t},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:e},inputEncoding:{value:pn[ke]},outputEncoding:{value:pn[ke]}},vertexShader:hh(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${uh()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:In,depthTest:!1,depthWrite:!1})}function ku(){const s=new j(1,1);return new rr({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:s},inputEncoding:{value:pn[ke]},outputEncoding:{value:pn[ke]}},vertexShader:hh(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${uh()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:In,depthTest:!1,depthWrite:!1})}function Bu(){return new rr({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:pn[ke]},outputEncoding:{value:pn[ke]}},vertexShader:hh(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${uh()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:In,depthTest:!1,depthWrite:!1})}function hh(){return`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function uh(){return`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`}function Zv(s){let t=new WeakMap,e=null;function n(a){if(a&&a.isTexture&&a.isRenderTargetTexture===!1){const l=a.mapping,c=l===Or||l===zr,h=l===er||l===nr;if(c||h){if(t.has(a))return t.get(a).texture;{const u=a.image;if(c&&u&&u.height>0||h&&u&&i(u)){const d=s.getRenderTarget();e===null&&(e=new ng(s));const f=c?e.fromEquirectangular(a):e.fromCubemap(a);return t.set(a,f),s.setRenderTarget(d),a.addEventListener("dispose",r),f.texture}else return null}}}return a}function i(a){let l=0;const c=6;for(let h=0;h<c;h++)a[h]!==void 0&&l++;return l===c}function r(a){const l=a.target;l.removeEventListener("dispose",r);const c=t.get(l);c!==void 0&&(t.delete(l),c.dispose())}function o(){t=new WeakMap,e!==null&&(e.dispose(),e=null)}return{get:n,dispose:o}}function $v(s){const t={};function e(n){if(t[n]!==void 0)return t[n];let i;switch(n){case"WEBGL_depth_texture":i=s.getExtension("WEBGL_depth_texture")||s.getExtension("MOZ_WEBGL_depth_texture")||s.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=s.getExtension("EXT_texture_filter_anisotropic")||s.getExtension("MOZ_EXT_texture_filter_anisotropic")||s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=s.getExtension("WEBGL_compressed_texture_s3tc")||s.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=s.getExtension("WEBGL_compressed_texture_pvrtc")||s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=s.getExtension(n)}return t[n]=i,i}return{has:function(n){return e(n)!==null},init:function(n){n.isWebGL2?e("EXT_color_buffer_float"):(e("WEBGL_depth_texture"),e("OES_texture_float"),e("OES_texture_half_float"),e("OES_texture_half_float_linear"),e("OES_standard_derivatives"),e("OES_element_index_uint"),e("OES_vertex_array_object"),e("ANGLE_instanced_arrays")),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float")},get:function(n){const i=e(n);return i===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),i}}}function Kv(s,t,e,n){const i={},r=new WeakMap;function o(u){const d=u.target;d.index!==null&&t.remove(d.index);for(const p in d.attributes)t.remove(d.attributes[p]);d.removeEventListener("dispose",o),delete i[d.id];const f=r.get(d);f&&(t.remove(f),r.delete(d)),n.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,e.memory.geometries--}function a(u,d){return i[d.id]===!0||(d.addEventListener("dispose",o),i[d.id]=!0,e.memory.geometries++),d}function l(u){const d=u.attributes;for(const p in d)t.update(d[p],34962);const f=u.morphAttributes;for(const p in f){const m=f[p];for(let y=0,g=m.length;y<g;y++)t.update(m[y],34962)}}function c(u){const d=[],f=u.index,p=u.attributes.position;let m=0;if(f!==null){const x=f.array;m=f.version;for(let v=0,_=x.length;v<_;v+=3){const M=x[v+0],w=x[v+1],b=x[v+2];d.push(M,w,w,b,b,M)}}else{const x=p.array;m=p.version;for(let v=0,_=x.length/3-1;v<_;v+=3){const M=v+0,w=v+1,b=v+2;d.push(M,w,w,b,b,M)}}const y=new($m(d)>65535?Xa:Ga)(d,1);y.version=m;const g=r.get(u);g&&t.remove(g),r.set(u,y)}function h(u){const d=r.get(u);if(d){const f=u.index;f!==null&&d.version<f.version&&c(u)}else c(u);return r.get(u)}return{get:a,update:l,getWireframeAttribute:h}}function Qv(s,t,e,n){const i=n.isWebGL2;let r;function o(d){r=d}let a,l;function c(d){a=d.type,l=d.bytesPerElement}function h(d,f){s.drawElements(r,f,a,d*l),e.update(f,r,1)}function u(d,f,p){if(p===0)return;let m,y;if(i)m=s,y="drawElementsInstanced";else if(m=t.get("ANGLE_instanced_arrays"),y="drawElementsInstancedANGLE",m===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}m[y](r,f,a,d*l,p),e.update(f,r,p)}this.setMode=o,this.setIndex=c,this.render=h,this.renderInstances=u}function tb(s){const t={geometries:0,textures:0},e={frame:0,calls:0,triangles:0,points:0,lines:0};function n(r,o,a){switch(e.calls++,o){case 4:e.triangles+=a*(r/3);break;case 1:e.lines+=a*(r/2);break;case 3:e.lines+=a*(r-1);break;case 2:e.lines+=a*r;break;case 0:e.points+=a*r;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function i(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0}return{memory:t,render:e,programs:null,autoReset:!0,reset:i,update:n}}function eb(s,t){return s[0]-t[0]}function nb(s,t){return Math.abs(t[1])-Math.abs(s[1])}function ib(s){const t={},e=new Float32Array(8),n=[];for(let r=0;r<8;r++)n[r]=[r,0];function i(r,o,a,l){const c=r.morphTargetInfluences,h=c===void 0?0:c.length;let u=t[o.id];if(u===void 0||u.length!==h){u=[];for(let y=0;y<h;y++)u[y]=[y,0];t[o.id]=u}for(let y=0;y<h;y++){const g=u[y];g[0]=y,g[1]=c[y]}u.sort(nb);for(let y=0;y<8;y++)y<h&&u[y][1]?(n[y][0]=u[y][0],n[y][1]=u[y][1]):(n[y][0]=Number.MAX_SAFE_INTEGER,n[y][1]=0);n.sort(eb);const d=o.morphAttributes.position,f=o.morphAttributes.normal;let p=0;for(let y=0;y<8;y++){const g=n[y],x=g[0],v=g[1];x!==Number.MAX_SAFE_INTEGER&&v?(d&&o.getAttribute("morphTarget"+y)!==d[x]&&o.setAttribute("morphTarget"+y,d[x]),f&&o.getAttribute("morphNormal"+y)!==f[x]&&o.setAttribute("morphNormal"+y,f[x]),e[y]=v,p+=v):(d&&o.hasAttribute("morphTarget"+y)===!0&&o.deleteAttribute("morphTarget"+y),f&&o.hasAttribute("morphNormal"+y)===!0&&o.deleteAttribute("morphNormal"+y),e[y]=0)}const m=o.morphTargetsRelative?1:1-p;l.getUniforms().setValue(s,"morphTargetBaseInfluence",m),l.getUniforms().setValue(s,"morphTargetInfluences",e)}return{update:i}}function sb(s,t,e,n){let i=new WeakMap;function r(l){const c=n.render.frame,h=l.geometry,u=t.get(l,h);return i.get(u)!==c&&(t.update(u),i.set(u,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),e.update(l.instanceMatrix,34962),l.instanceColor!==null&&e.update(l.instanceColor,34962)),u}function o(){i=new WeakMap}function a(l){const c=l.target;c.removeEventListener("dispose",a),e.remove(c.instanceMatrix),c.instanceColor!==null&&e.remove(c.instanceColor)}return{update:r,dispose:o}}class dh extends fe{constructor(t=null,e=1,n=1,i=1){super(null),this.image={data:t,width:e,height:n,depth:i},this.magFilter=le,this.minFilter=le,this.wrapR=we,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}dh.prototype.isDataTexture2DArray=!0;class fh extends fe{constructor(t=null,e=1,n=1,i=1){super(null),this.image={data:t,width:e,height:n,depth:i},this.magFilter=le,this.minFilter=le,this.wrapR=we,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}fh.prototype.isDataTexture3D=!0;const ig=new fe,rb=new dh,ob=new fh,sg=new sr,Ou=[],zu=[],Nu=new Float32Array(16),Hu=new Float32Array(9),Uu=new Float32Array(4);function or(s,t,e){const n=s[0];if(n<=0||n>0)return s;const i=t*e;let r=Ou[i];if(r===void 0&&(r=new Float32Array(i),Ou[i]=r),t!==0){n.toArray(r,0);for(let o=1,a=0;o!==t;++o)a+=e,s[o].toArray(r,a)}return r}function Be(s,t){if(s.length!==t.length)return!1;for(let e=0,n=s.length;e<n;e++)if(s[e]!==t[e])return!1;return!0}function Pe(s,t){for(let e=0,n=t.length;e<n;e++)s[e]=t[e]}function rg(s,t){let e=zu[t];e===void 0&&(e=new Int32Array(t),zu[t]=e);for(let n=0;n!==t;++n)e[n]=s.allocateTextureUnit();return e}function ab(s,t){const e=this.cache;e[0]!==t&&(s.uniform1f(this.addr,t),e[0]=t)}function lb(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(s.uniform2f(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(Be(e,t))return;s.uniform2fv(this.addr,t),Pe(e,t)}}function cb(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(s.uniform3f(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else if(t.r!==void 0)(e[0]!==t.r||e[1]!==t.g||e[2]!==t.b)&&(s.uniform3f(this.addr,t.r,t.g,t.b),e[0]=t.r,e[1]=t.g,e[2]=t.b);else{if(Be(e,t))return;s.uniform3fv(this.addr,t),Pe(e,t)}}function hb(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(s.uniform4f(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(Be(e,t))return;s.uniform4fv(this.addr,t),Pe(e,t)}}function ub(s,t){const e=this.cache,n=t.elements;if(n===void 0){if(Be(e,t))return;s.uniformMatrix2fv(this.addr,!1,t),Pe(e,t)}else{if(Be(e,n))return;Uu.set(n),s.uniformMatrix2fv(this.addr,!1,Uu),Pe(e,n)}}function db(s,t){const e=this.cache,n=t.elements;if(n===void 0){if(Be(e,t))return;s.uniformMatrix3fv(this.addr,!1,t),Pe(e,t)}else{if(Be(e,n))return;Hu.set(n),s.uniformMatrix3fv(this.addr,!1,Hu),Pe(e,n)}}function fb(s,t){const e=this.cache,n=t.elements;if(n===void 0){if(Be(e,t))return;s.uniformMatrix4fv(this.addr,!1,t),Pe(e,t)}else{if(Be(e,n))return;Nu.set(n),s.uniformMatrix4fv(this.addr,!1,Nu),Pe(e,n)}}function pb(s,t){const e=this.cache;e[0]!==t&&(s.uniform1i(this.addr,t),e[0]=t)}function mb(s,t){const e=this.cache;Be(e,t)||(s.uniform2iv(this.addr,t),Pe(e,t))}function gb(s,t){const e=this.cache;Be(e,t)||(s.uniform3iv(this.addr,t),Pe(e,t))}function xb(s,t){const e=this.cache;Be(e,t)||(s.uniform4iv(this.addr,t),Pe(e,t))}function yb(s,t){const e=this.cache;e[0]!==t&&(s.uniform1ui(this.addr,t),e[0]=t)}function _b(s,t){const e=this.cache;Be(e,t)||(s.uniform2uiv(this.addr,t),Pe(e,t))}function vb(s,t){const e=this.cache;Be(e,t)||(s.uniform3uiv(this.addr,t),Pe(e,t))}function bb(s,t){const e=this.cache;Be(e,t)||(s.uniform4uiv(this.addr,t),Pe(e,t))}function Mb(s,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),e.safeSetTexture2D(t||ig,i)}function wb(s,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),e.setTexture3D(t||ob,i)}function Sb(s,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),e.safeSetTextureCube(t||sg,i)}function Tb(s,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),e.setTexture2DArray(t||rb,i)}function Eb(s){switch(s){case 5126:return ab;case 35664:return lb;case 35665:return cb;case 35666:return hb;case 35674:return ub;case 35675:return db;case 35676:return fb;case 5124:case 35670:return pb;case 35667:case 35671:return mb;case 35668:case 35672:return gb;case 35669:case 35673:return xb;case 5125:return yb;case 36294:return _b;case 36295:return vb;case 36296:return bb;case 35678:case 36198:case 36298:case 36306:case 35682:return Mb;case 35679:case 36299:case 36307:return wb;case 35680:case 36300:case 36308:case 36293:return Sb;case 36289:case 36303:case 36311:case 36292:return Tb}}function Ab(s,t){s.uniform1fv(this.addr,t)}function Lb(s,t){const e=or(t,this.size,2);s.uniform2fv(this.addr,e)}function Cb(s,t){const e=or(t,this.size,3);s.uniform3fv(this.addr,e)}function Rb(s,t){const e=or(t,this.size,4);s.uniform4fv(this.addr,e)}function Pb(s,t){const e=or(t,this.size,4);s.uniformMatrix2fv(this.addr,!1,e)}function Db(s,t){const e=or(t,this.size,9);s.uniformMatrix3fv(this.addr,!1,e)}function Ib(s,t){const e=or(t,this.size,16);s.uniformMatrix4fv(this.addr,!1,e)}function Fb(s,t){s.uniform1iv(this.addr,t)}function kb(s,t){s.uniform2iv(this.addr,t)}function Bb(s,t){s.uniform3iv(this.addr,t)}function Ob(s,t){s.uniform4iv(this.addr,t)}function zb(s,t){s.uniform1uiv(this.addr,t)}function Nb(s,t){s.uniform2uiv(this.addr,t)}function Hb(s,t){s.uniform3uiv(this.addr,t)}function Ub(s,t){s.uniform4uiv(this.addr,t)}function Vb(s,t,e){const n=t.length,i=rg(e,n);s.uniform1iv(this.addr,i);for(let r=0;r!==n;++r)e.safeSetTexture2D(t[r]||ig,i[r])}function Wb(s,t,e){const n=t.length,i=rg(e,n);s.uniform1iv(this.addr,i);for(let r=0;r!==n;++r)e.safeSetTextureCube(t[r]||sg,i[r])}function Gb(s){switch(s){case 5126:return Ab;case 35664:return Lb;case 35665:return Cb;case 35666:return Rb;case 35674:return Pb;case 35675:return Db;case 35676:return Ib;case 5124:case 35670:return Fb;case 35667:case 35671:return kb;case 35668:case 35672:return Bb;case 35669:case 35673:return Ob;case 5125:return zb;case 36294:return Nb;case 36295:return Hb;case 36296:return Ub;case 35678:case 36198:case 36298:case 36306:case 35682:return Vb;case 35680:case 36300:case 36308:case 36293:return Wb}}function Xb(s,t,e){this.id=s,this.addr=e,this.cache=[],this.setValue=Eb(t.type)}function og(s,t,e){this.id=s,this.addr=e,this.cache=[],this.size=t.size,this.setValue=Gb(t.type)}og.prototype.updateCache=function(s){const t=this.cache;s instanceof Float32Array&&t.length!==s.length&&(this.cache=new Float32Array(s.length)),Pe(t,s)};function ag(s){this.id=s,this.seq=[],this.map={}}ag.prototype.setValue=function(s,t,e){const n=this.seq;for(let i=0,r=n.length;i!==r;++i){const o=n[i];o.setValue(s,t[o.id],e)}};const Xl=/(\w+)(\])?(\[|\.)?/g;function Vu(s,t){s.seq.push(t),s.map[t.id]=t}function qb(s,t,e){const n=s.name,i=n.length;for(Xl.lastIndex=0;;){const r=Xl.exec(n),o=Xl.lastIndex;let a=r[1];const l=r[2]==="]",c=r[3];if(l&&(a=a|0),c===void 0||c==="["&&o+2===i){Vu(e,c===void 0?new Xb(a,s,t):new og(a,s,t));break}else{let u=e.map[a];u===void 0&&(u=new ag(a),Vu(e,u)),e=u}}}function si(s,t){this.seq=[],this.map={};const e=s.getProgramParameter(t,35718);for(let n=0;n<e;++n){const i=s.getActiveUniform(t,n),r=s.getUniformLocation(t,i.name);qb(i,r,this)}}si.prototype.setValue=function(s,t,e,n){const i=this.map[t];i!==void 0&&i.setValue(s,e,n)};si.prototype.setOptional=function(s,t,e){const n=t[e];n!==void 0&&this.setValue(s,e,n)};si.upload=function(s,t,e,n){for(let i=0,r=t.length;i!==r;++i){const o=t[i],a=e[o.id];a.needsUpdate!==!1&&o.setValue(s,a.value,n)}};si.seqWithValue=function(s,t){const e=[];for(let n=0,i=s.length;n!==i;++n){const r=s[n];r.id in t&&e.push(r)}return e};function Wu(s,t,e){const n=s.createShader(t);return s.shaderSource(n,e),s.compileShader(n),n}let Yb=0;function jb(s){const t=s.split(`
`);for(let e=0;e<t.length;e++)t[e]=e+1+": "+t[e];return t.join(`
`)}function lg(s){switch(s){case ke:return["Linear","( value )"];case lo:return["sRGB","( value )"];case Wa:return["RGBE","( value )"];case sh:return["RGBM","( value, 7.0 )"];case rh:return["RGBM","( value, 16.0 )"];case oh:return["RGBD","( value, 256.0 )"];case Va:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case km:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",s),["Linear","( value )"]}}function Gu(s,t,e){const n=s.getShaderParameter(t,35713),i=s.getShaderInfoLog(t).trim();return n&&i===""?"":e.toUpperCase()+`

`+i+`

`+jb(s.getShaderSource(t))}function Ss(s,t){const e=lg(t);return"vec4 "+s+"( vec4 value ) { return "+e[0]+"ToLinear"+e[1]+"; }"}function Jb(s,t){const e=lg(t);return"vec4 "+s+"( vec4 value ) { return LinearTo"+e[0]+e[1]+"; }"}function Zb(s,t){let e;switch(t){case Fp:e="Linear";break;case kp:e="Reinhard";break;case Bp:e="OptimizedCineon";break;case Op:e="ACESFilmic";break;case zp:e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),e="Linear"}return"vec3 "+s+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}function $b(s){return[s.extensionDerivatives||s.envMapCubeUV||s.bumpMap||s.tangentSpaceNormalMap||s.clearcoatNormalMap||s.flatShading||s.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(s.extensionFragDepth||s.logarithmicDepthBuffer)&&s.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",s.extensionDrawBuffers&&s.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(s.extensionShaderTextureLOD||s.envMap||s.transmission)&&s.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Tr).join(`
`)}function Kb(s){const t=[];for(const e in s){const n=s[e];n!==!1&&t.push("#define "+e+" "+n)}return t.join(`
`)}function Qb(s,t){const e={},n=s.getProgramParameter(t,35721);for(let i=0;i<n;i++){const r=s.getActiveAttrib(t,i),o=r.name;let a=1;r.type===35674&&(a=2),r.type===35675&&(a=3),r.type===35676&&(a=4),e[o]={type:r.type,location:s.getAttribLocation(t,o),locationSize:a}}return e}function Tr(s){return s!==""}function Xu(s,t){return s.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function qu(s,t){return s.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const tM=/^[ \t]*#include +<([\w\d./]+)>/gm;function kc(s){return s.replace(tM,eM)}function eM(s,t){const e=Dt[t];if(e===void 0)throw new Error("Can not resolve #include <"+t+">");return kc(e)}const nM=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,iM=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Yu(s){return s.replace(iM,cg).replace(nM,sM)}function sM(s,t,e,n){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),cg(s,t,e,n)}function cg(s,t,e,n){let i="";for(let r=parseInt(t);r<parseInt(e);r++)i+=n.replace(/\[\s*i\s*\]/g,"[ "+r+" ]").replace(/UNROLLED_LOOP_INDEX/g,r);return i}function ju(s){let t="precision "+s.precision+` float;
precision `+s.precision+" int;";return s.precision==="highp"?t+=`
#define HIGH_PRECISION`:s.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:s.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}function rM(s){let t="SHADOWMAP_TYPE_BASIC";return s.shadowMapType===Kc?t="SHADOWMAP_TYPE_PCF":s.shadowMapType===dp?t="SHADOWMAP_TYPE_PCF_SOFT":s.shadowMapType===Ps&&(t="SHADOWMAP_TYPE_VSM"),t}function oM(s){let t="ENVMAP_TYPE_CUBE";if(s.envMap)switch(s.envMapMode){case er:case nr:t="ENVMAP_TYPE_CUBE";break;case ir:case ao:t="ENVMAP_TYPE_CUBE_UV";break}return t}function aM(s){let t="ENVMAP_MODE_REFLECTION";if(s.envMap)switch(s.envMapMode){case nr:case ao:t="ENVMAP_MODE_REFRACTION";break}return t}function lM(s){let t="ENVMAP_BLENDING_NONE";if(s.envMap)switch(s.combine){case oo:t="ENVMAP_BLENDING_MULTIPLY";break;case Dp:t="ENVMAP_BLENDING_MIX";break;case Ip:t="ENVMAP_BLENDING_ADD";break}return t}function cM(s,t,e,n){const i=s.getContext(),r=e.defines;let o=e.vertexShader,a=e.fragmentShader;const l=rM(e),c=oM(e),h=aM(e),u=lM(e),d=s.gammaFactor>0?s.gammaFactor:1,f=e.isWebGL2?"":$b(e),p=Kb(r),m=i.createProgram();let y,g,x=e.glslVersion?"#version "+e.glslVersion+`
`:"";e.isRawShaderMaterial?(y=[p].filter(Tr).join(`
`),y.length>0&&(y+=`
`),g=[f,p].filter(Tr).join(`
`),g.length>0&&(g+=`
`)):(y=[ju(e),"#define SHADER_NAME "+e.shaderName,p,e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+d,"#define MAX_BONES "+e.maxBones,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+h:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.displacementMap&&e.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",e.specularTintMap?"#define USE_SPECULARTINTMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.useVertexTexture?"#define BONE_TEXTURE":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&e.flatShading===!1?"#define USE_MORPHNORMALS":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+l:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Tr).join(`
`),g=[f,ju(e),"#define SHADER_NAME "+e.shaderName,p,"#define GAMMA_FACTOR "+d,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+c:"",e.envMap?"#define "+h:"",e.envMap?"#define "+u:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoat?"#define USE_CLEARCOAT":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",e.specularTintMap?"#define USE_SPECULARTINTMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaTest?"#define USE_ALPHATEST":"",e.sheenTint?"#define USE_SHEEN":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+l:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(e.extensionShaderTextureLOD||e.envMap)&&e.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==ni?"#define TONE_MAPPING":"",e.toneMapping!==ni?Dt.tonemapping_pars_fragment:"",e.toneMapping!==ni?Zb("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",e.format===Fn?"#define OPAQUE":"",Dt.encodings_pars_fragment,e.map?Ss("mapTexelToLinear",e.mapEncoding):"",e.matcap?Ss("matcapTexelToLinear",e.matcapEncoding):"",e.envMap?Ss("envMapTexelToLinear",e.envMapEncoding):"",e.emissiveMap?Ss("emissiveMapTexelToLinear",e.emissiveMapEncoding):"",e.specularTintMap?Ss("specularTintMapTexelToLinear",e.specularTintMapEncoding):"",e.lightMap?Ss("lightMapTexelToLinear",e.lightMapEncoding):"",Jb("linearToOutputTexel",e.outputEncoding),e.depthPacking?"#define DEPTH_PACKING "+e.depthPacking:"",`
`].filter(Tr).join(`
`)),o=kc(o),o=Xu(o,e),o=qu(o,e),a=kc(a),a=Xu(a,e),a=qu(a,e),o=Yu(o),a=Yu(a),e.isWebGL2&&e.isRawShaderMaterial!==!0&&(x=`#version 300 es
`,y=["#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+y,g=["#define varying in",e.glslVersion===Ic?"":"out highp vec4 pc_fragColor;",e.glslVersion===Ic?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+g);const v=x+y+o,_=x+g+a,M=Wu(i,35633,v),w=Wu(i,35632,_);if(i.attachShader(m,M),i.attachShader(m,w),e.index0AttributeName!==void 0?i.bindAttribLocation(m,0,e.index0AttributeName):e.morphTargets===!0&&i.bindAttribLocation(m,0,"position"),i.linkProgram(m),s.debug.checkShaderErrors){const P=i.getProgramInfoLog(m).trim(),R=i.getShaderInfoLog(M).trim(),C=i.getShaderInfoLog(w).trim();let U=!0,k=!0;if(i.getProgramParameter(m,35714)===!1){U=!1;const B=Gu(i,M,"vertex"),O=Gu(i,w,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(m,35715)+`

Program Info Log: `+P+`
`+B+`
`+O)}else P!==""?console.warn("THREE.WebGLProgram: Program Info Log:",P):(R===""||C==="")&&(k=!1);k&&(this.diagnostics={runnable:U,programLog:P,vertexShader:{log:R,prefix:y},fragmentShader:{log:C,prefix:g}})}i.deleteShader(M),i.deleteShader(w);let b;this.getUniforms=function(){return b===void 0&&(b=new si(i,m)),b};let E;return this.getAttributes=function(){return E===void 0&&(E=Qb(i,m)),E},this.destroy=function(){n.releaseStatesOfProgram(this),i.deleteProgram(m),this.program=void 0},this.name=e.shaderName,this.id=Yb++,this.cacheKey=t,this.usedTimes=1,this.program=m,this.vertexShader=M,this.fragmentShader=w,this}function hM(s,t,e,n,i,r,o){const a=[],l=i.isWebGL2,c=i.logarithmicDepthBuffer,h=i.floatVertexTextures,u=i.maxVertexUniforms,d=i.vertexTextures;let f=i.precision;const p={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},m=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoat","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","specularIntensityMap","specularTintMap","specularTintMapEncoding","roughnessMap","metalnessMap","gradientMap","alphaMap","alphaTest","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","format","sheenTint","transmission","transmissionMap","thicknessMap"];function y(b){const P=b.skeleton.bones;if(h)return 1024;{const C=Math.floor((u-20)/4),U=Math.min(C,P.length);return U<P.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+P.length+" bones. This GPU supports "+U+"."),0):U}}function g(b){let E;return b&&b.isTexture?E=b.encoding:b&&b.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),E=b.texture.encoding):E=ke,E}function x(b,E,P,R,C){const U=R.fog,k=b.isMeshStandardMaterial?R.environment:null,B=(b.isMeshStandardMaterial?e:t).get(b.envMap||k),O=p[b.type],F=C.isSkinnedMesh?y(C):0;b.precision!==null&&(f=i.getMaxPrecision(b.precision),f!==b.precision&&console.warn("THREE.WebGLProgram.getParameters:",b.precision,"not supported, using",f,"instead."));let N,Z;if(O){const X=tn[O];N=X.vertexShader,Z=X.fragmentShader}else N=b.vertexShader,Z=b.fragmentShader;const tt=s.getRenderTarget(),dt=b.alphaTest>0,nt=b.clearcoat>0;return{isWebGL2:l,shaderID:O,shaderName:b.type,vertexShader:N,fragmentShader:Z,defines:b.defines,isRawShaderMaterial:b.isRawShaderMaterial===!0,glslVersion:b.glslVersion,precision:f,instancing:C.isInstancedMesh===!0,instancingColor:C.isInstancedMesh===!0&&C.instanceColor!==null,supportsVertexTextures:d,outputEncoding:tt!==null?g(tt.texture):s.outputEncoding,map:!!b.map,mapEncoding:g(b.map),matcap:!!b.matcap,matcapEncoding:g(b.matcap),envMap:!!B,envMapMode:B&&B.mapping,envMapEncoding:g(B),envMapCubeUV:!!B&&(B.mapping===ir||B.mapping===ao),lightMap:!!b.lightMap,lightMapEncoding:g(b.lightMap),aoMap:!!b.aoMap,emissiveMap:!!b.emissiveMap,emissiveMapEncoding:g(b.emissiveMap),bumpMap:!!b.bumpMap,normalMap:!!b.normalMap,objectSpaceNormalMap:b.normalMapType===zm,tangentSpaceNormalMap:b.normalMapType===ts,clearcoat:nt,clearcoatMap:nt&&!!b.clearcoatMap,clearcoatRoughnessMap:nt&&!!b.clearcoatRoughnessMap,clearcoatNormalMap:nt&&!!b.clearcoatNormalMap,displacementMap:!!b.displacementMap,roughnessMap:!!b.roughnessMap,metalnessMap:!!b.metalnessMap,specularMap:!!b.specularMap,specularIntensityMap:!!b.specularIntensityMap,specularTintMap:!!b.specularTintMap,specularTintMapEncoding:g(b.specularTintMap),alphaMap:!!b.alphaMap,alphaTest:dt,gradientMap:!!b.gradientMap,sheenTint:!!b.sheenTint&&(b.sheenTint.r>0||b.sheenTint.g>0||b.sheenTint.b>0),transmission:b.transmission>0,transmissionMap:!!b.transmissionMap,thicknessMap:!!b.thicknessMap,combine:b.combine,vertexTangents:!!b.normalMap&&!!C.geometry&&!!C.geometry.attributes.tangent,vertexColors:b.vertexColors,vertexAlphas:b.vertexColors===!0&&!!C.geometry&&!!C.geometry.attributes.color&&C.geometry.attributes.color.itemSize===4,vertexUvs:!!b.map||!!b.bumpMap||!!b.normalMap||!!b.specularMap||!!b.alphaMap||!!b.emissiveMap||!!b.roughnessMap||!!b.metalnessMap||!!b.clearcoatMap||!!b.clearcoatRoughnessMap||!!b.clearcoatNormalMap||!!b.displacementMap||!!b.transmissionMap||!!b.thicknessMap||!!b.specularIntensityMap||!!b.specularTintMap,uvsVertexOnly:!(b.map||b.bumpMap||b.normalMap||b.specularMap||b.alphaMap||b.emissiveMap||b.roughnessMap||b.metalnessMap||b.clearcoatNormalMap||b.transmission>0||b.transmissionMap||b.thicknessMap||b.specularIntensityMap||b.specularTintMap)&&!!b.displacementMap,fog:!!U,useFog:b.fog,fogExp2:U&&U.isFogExp2,flatShading:!!b.flatShading,sizeAttenuation:b.sizeAttenuation,logarithmicDepthBuffer:c,skinning:C.isSkinnedMesh===!0&&F>0,maxBones:F,useVertexTexture:h,morphTargets:!!C.geometry&&!!C.geometry.morphAttributes.position,morphNormals:!!C.geometry&&!!C.geometry.morphAttributes.normal,numDirLights:E.directional.length,numPointLights:E.point.length,numSpotLights:E.spot.length,numRectAreaLights:E.rectArea.length,numHemiLights:E.hemi.length,numDirLightShadows:E.directionalShadowMap.length,numPointLightShadows:E.pointShadowMap.length,numSpotLightShadows:E.spotShadowMap.length,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,format:b.format,dithering:b.dithering,shadowMapEnabled:s.shadowMap.enabled&&P.length>0,shadowMapType:s.shadowMap.type,toneMapping:b.toneMapped?s.toneMapping:ni,physicallyCorrectLights:s.physicallyCorrectLights,premultipliedAlpha:b.premultipliedAlpha,doubleSided:b.side===Wi,flipSided:b.side===se,depthPacking:b.depthPacking!==void 0?b.depthPacking:!1,index0AttributeName:b.index0AttributeName,extensionDerivatives:b.extensions&&b.extensions.derivatives,extensionFragDepth:b.extensions&&b.extensions.fragDepth,extensionDrawBuffers:b.extensions&&b.extensions.drawBuffers,extensionShaderTextureLOD:b.extensions&&b.extensions.shaderTextureLOD,rendererExtensionFragDepth:l||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:l||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:l||n.has("EXT_shader_texture_lod"),customProgramCacheKey:b.customProgramCacheKey()}}function v(b){const E=[];if(b.shaderID?E.push(b.shaderID):(E.push(b.fragmentShader),E.push(b.vertexShader)),b.defines!==void 0)for(const P in b.defines)E.push(P),E.push(b.defines[P]);if(b.isRawShaderMaterial===!1){for(let P=0;P<m.length;P++)E.push(b[m[P]]);E.push(s.outputEncoding),E.push(s.gammaFactor)}return E.push(b.customProgramCacheKey),E.join()}function _(b){const E=p[b.type];let P;if(E){const R=tn[E];P=Km.clone(R.uniforms)}else P=b.uniforms;return P}function M(b,E){let P;for(let R=0,C=a.length;R<C;R++){const U=a[R];if(U.cacheKey===E){P=U,++P.usedTimes;break}}return P===void 0&&(P=new cM(s,E,b,r),a.push(P)),P}function w(b){if(--b.usedTimes===0){const E=a.indexOf(b);a[E]=a[a.length-1],a.pop(),b.destroy()}}return{getParameters:x,getProgramCacheKey:v,getUniforms:_,acquireProgram:M,releaseProgram:w,programs:a}}function uM(){let s=new WeakMap;function t(r){let o=s.get(r);return o===void 0&&(o={},s.set(r,o)),o}function e(r){s.delete(r)}function n(r,o,a){s.get(r)[o]=a}function i(){s=new WeakMap}return{get:t,remove:e,update:n,dispose:i}}function dM(s,t){return s.groupOrder!==t.groupOrder?s.groupOrder-t.groupOrder:s.renderOrder!==t.renderOrder?s.renderOrder-t.renderOrder:s.program!==t.program?s.program.id-t.program.id:s.material.id!==t.material.id?s.material.id-t.material.id:s.z!==t.z?s.z-t.z:s.id-t.id}function Ju(s,t){return s.groupOrder!==t.groupOrder?s.groupOrder-t.groupOrder:s.renderOrder!==t.renderOrder?s.renderOrder-t.renderOrder:s.z!==t.z?t.z-s.z:s.id-t.id}function Zu(s){const t=[];let e=0;const n=[],i=[],r=[],o={id:-1};function a(){e=0,n.length=0,i.length=0,r.length=0}function l(f,p,m,y,g,x){let v=t[e];const _=s.get(m);return v===void 0?(v={id:f.id,object:f,geometry:p,material:m,program:_.program||o,groupOrder:y,renderOrder:f.renderOrder,z:g,group:x},t[e]=v):(v.id=f.id,v.object=f,v.geometry=p,v.material=m,v.program=_.program||o,v.groupOrder=y,v.renderOrder=f.renderOrder,v.z=g,v.group=x),e++,v}function c(f,p,m,y,g,x){const v=l(f,p,m,y,g,x);m.transmission>0?i.push(v):m.transparent===!0?r.push(v):n.push(v)}function h(f,p,m,y,g,x){const v=l(f,p,m,y,g,x);m.transmission>0?i.unshift(v):m.transparent===!0?r.unshift(v):n.unshift(v)}function u(f,p){n.length>1&&n.sort(f||dM),i.length>1&&i.sort(p||Ju),r.length>1&&r.sort(p||Ju)}function d(){for(let f=e,p=t.length;f<p;f++){const m=t[f];if(m.id===null)break;m.id=null,m.object=null,m.geometry=null,m.material=null,m.program=null,m.group=null}}return{opaque:n,transmissive:i,transparent:r,init:a,push:c,unshift:h,finish:d,sort:u}}function fM(s){let t=new WeakMap;function e(i,r){let o;return t.has(i)===!1?(o=new Zu(s),t.set(i,[o])):r>=t.get(i).length?(o=new Zu(s),t.get(i).push(o)):o=t.get(i)[r],o}function n(){t=new WeakMap}return{get:e,dispose:n}}function pM(){const s={};return{get:function(t){if(s[t.id]!==void 0)return s[t.id];let e;switch(t.type){case"DirectionalLight":e={direction:new S,color:new it};break;case"SpotLight":e={position:new S,direction:new S,color:new it,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new S,color:new it,distance:0,decay:0};break;case"HemisphereLight":e={direction:new S,skyColor:new it,groundColor:new it};break;case"RectAreaLight":e={color:new it,position:new S,halfWidth:new S,halfHeight:new S};break}return s[t.id]=e,e}}}function mM(){const s={};return{get:function(t){if(s[t.id]!==void 0)return s[t.id];let e;switch(t.type){case"DirectionalLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new j};break;case"SpotLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new j};break;case"PointLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new j,shadowCameraNear:1,shadowCameraFar:1e3};break}return s[t.id]=e,e}}}let gM=0;function xM(s,t){return(t.castShadow?1:0)-(s.castShadow?1:0)}function yM(s,t){const e=new pM,n=mM(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let h=0;h<9;h++)i.probe.push(new S);const r=new S,o=new ft,a=new ft;function l(h,u){let d=0,f=0,p=0;for(let P=0;P<9;P++)i.probe[P].set(0,0,0);let m=0,y=0,g=0,x=0,v=0,_=0,M=0,w=0;h.sort(xM);const b=u!==!0?Math.PI:1;for(let P=0,R=h.length;P<R;P++){const C=h[P],U=C.color,k=C.intensity,B=C.distance,O=C.shadow&&C.shadow.map?C.shadow.map.texture:null;if(C.isAmbientLight)d+=U.r*k*b,f+=U.g*k*b,p+=U.b*k*b;else if(C.isLightProbe)for(let F=0;F<9;F++)i.probe[F].addScaledVector(C.sh.coefficients[F],k);else if(C.isDirectionalLight){const F=e.get(C);if(F.color.copy(C.color).multiplyScalar(C.intensity*b),C.castShadow){const N=C.shadow,Z=n.get(C);Z.shadowBias=N.bias,Z.shadowNormalBias=N.normalBias,Z.shadowRadius=N.radius,Z.shadowMapSize=N.mapSize,i.directionalShadow[m]=Z,i.directionalShadowMap[m]=O,i.directionalShadowMatrix[m]=C.shadow.matrix,_++}i.directional[m]=F,m++}else if(C.isSpotLight){const F=e.get(C);if(F.position.setFromMatrixPosition(C.matrixWorld),F.color.copy(U).multiplyScalar(k*b),F.distance=B,F.coneCos=Math.cos(C.angle),F.penumbraCos=Math.cos(C.angle*(1-C.penumbra)),F.decay=C.decay,C.castShadow){const N=C.shadow,Z=n.get(C);Z.shadowBias=N.bias,Z.shadowNormalBias=N.normalBias,Z.shadowRadius=N.radius,Z.shadowMapSize=N.mapSize,i.spotShadow[g]=Z,i.spotShadowMap[g]=O,i.spotShadowMatrix[g]=C.shadow.matrix,w++}i.spot[g]=F,g++}else if(C.isRectAreaLight){const F=e.get(C);F.color.copy(U).multiplyScalar(k),F.halfWidth.set(C.width*.5,0,0),F.halfHeight.set(0,C.height*.5,0),i.rectArea[x]=F,x++}else if(C.isPointLight){const F=e.get(C);if(F.color.copy(C.color).multiplyScalar(C.intensity*b),F.distance=C.distance,F.decay=C.decay,C.castShadow){const N=C.shadow,Z=n.get(C);Z.shadowBias=N.bias,Z.shadowNormalBias=N.normalBias,Z.shadowRadius=N.radius,Z.shadowMapSize=N.mapSize,Z.shadowCameraNear=N.camera.near,Z.shadowCameraFar=N.camera.far,i.pointShadow[y]=Z,i.pointShadowMap[y]=O,i.pointShadowMatrix[y]=C.shadow.matrix,M++}i.point[y]=F,y++}else if(C.isHemisphereLight){const F=e.get(C);F.skyColor.copy(C.color).multiplyScalar(k*b),F.groundColor.copy(C.groundColor).multiplyScalar(k*b),i.hemi[v]=F,v++}}x>0&&(t.isWebGL2||s.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=et.LTC_FLOAT_1,i.rectAreaLTC2=et.LTC_FLOAT_2):s.has("OES_texture_half_float_linear")===!0?(i.rectAreaLTC1=et.LTC_HALF_1,i.rectAreaLTC2=et.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=d,i.ambient[1]=f,i.ambient[2]=p;const E=i.hash;(E.directionalLength!==m||E.pointLength!==y||E.spotLength!==g||E.rectAreaLength!==x||E.hemiLength!==v||E.numDirectionalShadows!==_||E.numPointShadows!==M||E.numSpotShadows!==w)&&(i.directional.length=m,i.spot.length=g,i.rectArea.length=x,i.point.length=y,i.hemi.length=v,i.directionalShadow.length=_,i.directionalShadowMap.length=_,i.pointShadow.length=M,i.pointShadowMap.length=M,i.spotShadow.length=w,i.spotShadowMap.length=w,i.directionalShadowMatrix.length=_,i.pointShadowMatrix.length=M,i.spotShadowMatrix.length=w,E.directionalLength=m,E.pointLength=y,E.spotLength=g,E.rectAreaLength=x,E.hemiLength=v,E.numDirectionalShadows=_,E.numPointShadows=M,E.numSpotShadows=w,i.version=gM++)}function c(h,u){let d=0,f=0,p=0,m=0,y=0;const g=u.matrixWorldInverse;for(let x=0,v=h.length;x<v;x++){const _=h[x];if(_.isDirectionalLight){const M=i.directional[d];M.direction.setFromMatrixPosition(_.matrixWorld),r.setFromMatrixPosition(_.target.matrixWorld),M.direction.sub(r),M.direction.transformDirection(g),d++}else if(_.isSpotLight){const M=i.spot[p];M.position.setFromMatrixPosition(_.matrixWorld),M.position.applyMatrix4(g),M.direction.setFromMatrixPosition(_.matrixWorld),r.setFromMatrixPosition(_.target.matrixWorld),M.direction.sub(r),M.direction.transformDirection(g),p++}else if(_.isRectAreaLight){const M=i.rectArea[m];M.position.setFromMatrixPosition(_.matrixWorld),M.position.applyMatrix4(g),a.identity(),o.copy(_.matrixWorld),o.premultiply(g),a.extractRotation(o),M.halfWidth.set(_.width*.5,0,0),M.halfHeight.set(0,_.height*.5,0),M.halfWidth.applyMatrix4(a),M.halfHeight.applyMatrix4(a),m++}else if(_.isPointLight){const M=i.point[f];M.position.setFromMatrixPosition(_.matrixWorld),M.position.applyMatrix4(g),f++}else if(_.isHemisphereLight){const M=i.hemi[y];M.direction.setFromMatrixPosition(_.matrixWorld),M.direction.transformDirection(g),M.direction.normalize(),y++}}}return{setup:l,setupView:c,state:i}}function $u(s,t){const e=new yM(s,t),n=[],i=[];function r(){n.length=0,i.length=0}function o(u){n.push(u)}function a(u){i.push(u)}function l(u){e.setup(n,u)}function c(u){e.setupView(n,u)}return{init:r,state:{lightsArray:n,shadowsArray:i,lights:e},setupLights:l,setupLightsView:c,pushLight:o,pushShadow:a}}function _M(s,t){let e=new WeakMap;function n(r,o=0){let a;return e.has(r)===!1?(a=new $u(s,t),e.set(r,[a])):o>=e.get(r).length?(a=new $u(s,t),e.get(r).push(a)):a=e.get(r)[o],a}function i(){e=new WeakMap}return{get:n,dispose:i}}class ja extends ye{constructor(t){super(),this.type="MeshDepthMaterial",this.depthPacking=Bm,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}ja.prototype.isMeshDepthMaterial=!0;class Ja extends ye{constructor(t){super(),this.type="MeshDistanceMaterial",this.referencePosition=new S,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}Ja.prototype.isMeshDistanceMaterial=!0;var vM=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
uniform float samples;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`,bM=`void main() {
	gl_Position = vec4( position, 1.0 );
}`;function hg(s,t,e){let n=new ho;const i=new j,r=new j,o=new Xt,a=new ja({depthPacking:Om}),l=new Ja,c={},h=e.maxTextureSize,u={0:se,1:Vi,2:Wi},d=new Bn({uniforms:{shadow_pass:{value:null},resolution:{value:new j},radius:{value:4},samples:{value:8}},vertexShader:bM,fragmentShader:vM}),f=d.clone();f.defines.HORIZONTAL_PASS=1;const p=new bt;p.setAttribute("position",new Nt(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const m=new ce(p,d),y=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=Kc,this.render=function(_,M,w){if(y.enabled===!1||y.autoUpdate===!1&&y.needsUpdate===!1||_.length===0)return;const b=s.getRenderTarget(),E=s.getActiveCubeFace(),P=s.getActiveMipmapLevel(),R=s.state;R.setBlending(In),R.buffers.color.setClear(1,1,1,1),R.buffers.depth.setTest(!0),R.setScissorTest(!1);for(let C=0,U=_.length;C<U;C++){const k=_[C],B=k.shadow;if(B===void 0){console.warn("THREE.WebGLShadowMap:",k,"has no shadow.");continue}if(B.autoUpdate===!1&&B.needsUpdate===!1)continue;i.copy(B.mapSize);const O=B.getFrameExtents();if(i.multiply(O),r.copy(B.mapSize),(i.x>h||i.y>h)&&(i.x>h&&(r.x=Math.floor(h/O.x),i.x=r.x*O.x,B.mapSize.x=r.x),i.y>h&&(r.y=Math.floor(h/O.y),i.y=r.y*O.y,B.mapSize.y=r.y)),B.map===null&&!B.isPointLightShadow&&this.type===Ps){const N={minFilter:he,magFilter:he,format:Fe};B.map=new nn(i.x,i.y,N),B.map.texture.name=k.name+".shadowMap",B.mapPass=new nn(i.x,i.y,N),B.camera.updateProjectionMatrix()}if(B.map===null){const N={minFilter:le,magFilter:le,format:Fe};B.map=new nn(i.x,i.y,N),B.map.texture.name=k.name+".shadowMap",B.camera.updateProjectionMatrix()}s.setRenderTarget(B.map),s.clear();const F=B.getViewportCount();for(let N=0;N<F;N++){const Z=B.getViewport(N);o.set(r.x*Z.x,r.y*Z.y,r.x*Z.z,r.y*Z.w),R.viewport(o),B.updateMatrices(k,N),n=B.getFrustum(),v(M,w,B.camera,k,this.type)}!B.isPointLightShadow&&this.type===Ps&&g(B,w),B.needsUpdate=!1}y.needsUpdate=!1,s.setRenderTarget(b,E,P)};function g(_,M){const w=t.update(m);d.uniforms.shadow_pass.value=_.map.texture,d.uniforms.resolution.value=_.mapSize,d.uniforms.radius.value=_.radius,d.uniforms.samples.value=_.blurSamples,s.setRenderTarget(_.mapPass),s.clear(),s.renderBufferDirect(M,null,w,d,m,null),f.uniforms.shadow_pass.value=_.mapPass.texture,f.uniforms.resolution.value=_.mapSize,f.uniforms.radius.value=_.radius,f.uniforms.samples.value=_.blurSamples,s.setRenderTarget(_.map),s.clear(),s.renderBufferDirect(M,null,w,f,m,null)}function x(_,M,w,b,E,P,R){let C=null;const U=b.isPointLight===!0?_.customDistanceMaterial:_.customDepthMaterial;if(U!==void 0?C=U:C=b.isPointLight===!0?l:a,s.localClippingEnabled&&w.clipShadows===!0&&w.clippingPlanes.length!==0||w.displacementMap&&w.displacementScale!==0||w.alphaMap&&w.alphaTest>0){const k=C.uuid,B=w.uuid;let O=c[k];O===void 0&&(O={},c[k]=O);let F=O[B];F===void 0&&(F=C.clone(),O[B]=F),C=F}return C.visible=w.visible,C.wireframe=w.wireframe,R===Ps?C.side=w.shadowSide!==null?w.shadowSide:w.side:C.side=w.shadowSide!==null?w.shadowSide:u[w.side],C.alphaMap=w.alphaMap,C.alphaTest=w.alphaTest,C.clipShadows=w.clipShadows,C.clippingPlanes=w.clippingPlanes,C.clipIntersection=w.clipIntersection,C.displacementMap=w.displacementMap,C.displacementScale=w.displacementScale,C.displacementBias=w.displacementBias,C.wireframeLinewidth=w.wireframeLinewidth,C.linewidth=w.linewidth,b.isPointLight===!0&&C.isMeshDistanceMaterial===!0&&(C.referencePosition.setFromMatrixPosition(b.matrixWorld),C.nearDistance=E,C.farDistance=P),C}function v(_,M,w,b,E){if(_.visible===!1)return;if(_.layers.test(M.layers)&&(_.isMesh||_.isLine||_.isPoints)&&(_.castShadow||_.receiveShadow&&E===Ps)&&(!_.frustumCulled||n.intersectsObject(_))){_.modelViewMatrix.multiplyMatrices(w.matrixWorldInverse,_.matrixWorld);const C=t.update(_),U=_.material;if(Array.isArray(U)){const k=C.groups;for(let B=0,O=k.length;B<O;B++){const F=k[B],N=U[F.materialIndex];if(N&&N.visible){const Z=x(_,C,N,b,w.near,w.far,E);s.renderBufferDirect(w,null,C,Z,_,F)}}}else if(U.visible){const k=x(_,C,U,b,w.near,w.far,E);s.renderBufferDirect(w,null,C,k,_,null)}}const R=_.children;for(let C=0,U=R.length;C<U;C++)v(R[C],M,w,b,E)}}function MM(s,t,e){const n=e.isWebGL2;function i(){let D=!1;const ot=new Xt;let q=null;const ht=new Xt(0,0,0,0);return{setMask:function(mt){q!==mt&&!D&&(s.colorMask(mt,mt,mt,mt),q=mt)},setLocked:function(mt){D=mt},setClear:function(mt,Bt,Te,Ee,Un){Un===!0&&(mt*=Ee,Bt*=Ee,Te*=Ee),ot.set(mt,Bt,Te,Ee),ht.equals(ot)===!1&&(s.clearColor(mt,Bt,Te,Ee),ht.copy(ot))},reset:function(){D=!1,q=null,ht.set(-1,0,0,0)}}}function r(){let D=!1,ot=null,q=null,ht=null;return{setTest:function(mt){mt?K(2929):lt(2929)},setMask:function(mt){ot!==mt&&!D&&(s.depthMask(mt),ot=mt)},setFunc:function(mt){if(q!==mt){if(mt)switch(mt){case Tp:s.depthFunc(512);break;case Ep:s.depthFunc(519);break;case Ap:s.depthFunc(513);break;case Aa:s.depthFunc(515);break;case Lp:s.depthFunc(514);break;case Cp:s.depthFunc(518);break;case Rp:s.depthFunc(516);break;case Pp:s.depthFunc(517);break;default:s.depthFunc(515)}else s.depthFunc(515);q=mt}},setLocked:function(mt){D=mt},setClear:function(mt){ht!==mt&&(s.clearDepth(mt),ht=mt)},reset:function(){D=!1,ot=null,q=null,ht=null}}}function o(){let D=!1,ot=null,q=null,ht=null,mt=null,Bt=null,Te=null,Ee=null,Un=null;return{setTest:function(ee){D||(ee?K(2960):lt(2960))},setMask:function(ee){ot!==ee&&!D&&(s.stencilMask(ee),ot=ee)},setFunc:function(ee,yn,_n){(q!==ee||ht!==yn||mt!==_n)&&(s.stencilFunc(ee,yn,_n),q=ee,ht=yn,mt=_n)},setOp:function(ee,yn,_n){(Bt!==ee||Te!==yn||Ee!==_n)&&(s.stencilOp(ee,yn,_n),Bt=ee,Te=yn,Ee=_n)},setLocked:function(ee){D=ee},setClear:function(ee){Un!==ee&&(s.clearStencil(ee),Un=ee)},reset:function(){D=!1,ot=null,q=null,ht=null,mt=null,Bt=null,Te=null,Ee=null,Un=null}}}const a=new i,l=new r,c=new o;let h={},u=null,d={},f=null,p=!1,m=null,y=null,g=null,x=null,v=null,_=null,M=null,w=!1,b=null,E=null,P=null,R=null,C=null;const U=s.getParameter(35661);let k=!1,B=0;const O=s.getParameter(7938);O.indexOf("WebGL")!==-1?(B=parseFloat(/^WebGL (\d)/.exec(O)[1]),k=B>=1):O.indexOf("OpenGL ES")!==-1&&(B=parseFloat(/^OpenGL ES (\d)/.exec(O)[1]),k=B>=2);let F=null,N={};const Z=s.getParameter(3088),tt=s.getParameter(2978),dt=new Xt().fromArray(Z),nt=new Xt().fromArray(tt);function _t(D,ot,q){const ht=new Uint8Array(4),mt=s.createTexture();s.bindTexture(D,mt),s.texParameteri(D,10241,9728),s.texParameteri(D,10240,9728);for(let Bt=0;Bt<q;Bt++)s.texImage2D(ot+Bt,0,6408,1,1,0,6408,5121,ht);return mt}const X={};X[3553]=_t(3553,3553,1),X[34067]=_t(34067,34069,6),a.setClear(0,0,0,1),l.setClear(1),c.setClear(0),K(2929),l.setFunc(Aa),$(!1),Q(xc),K(2884),Ct(In);function K(D){h[D]!==!0&&(s.enable(D),h[D]=!0)}function lt(D){h[D]!==!1&&(s.disable(D),h[D]=!1)}function H(D){D!==u&&(s.bindFramebuffer(36160,D),u=D)}function vt(D,ot){return ot===null&&u!==null&&(ot=u),d[D]!==ot?(s.bindFramebuffer(D,ot),d[D]=ot,n&&(D===36009&&(d[36160]=ot),D===36160&&(d[36009]=ot)),!0):!1}function Tt(D){return f!==D?(s.useProgram(D),f=D,!0):!1}const ut={[Pi]:32774,[pp]:32778,[mp]:32779};if(n)ut[bc]=32775,ut[Mc]=32776;else{const D=t.get("EXT_blend_minmax");D!==null&&(ut[bc]=D.MIN_EXT,ut[Mc]=D.MAX_EXT)}const pt={[gp]:0,[xp]:1,[yp]:768,[th]:770,[Sp]:776,[Mp]:774,[vp]:772,[_p]:769,[eh]:771,[wp]:775,[bp]:773};function Ct(D,ot,q,ht,mt,Bt,Te,Ee){if(D===In){p===!0&&(lt(3042),p=!1);return}if(p===!1&&(K(3042),p=!0),D!==fp){if(D!==m||Ee!==w){if((y!==Pi||v!==Pi)&&(s.blendEquation(32774),y=Pi,v=Pi),Ee)switch(D){case Fs:s.blendFuncSeparate(1,771,1,771);break;case yc:s.blendFunc(1,1);break;case _c:s.blendFuncSeparate(0,0,769,771);break;case vc:s.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",D);break}else switch(D){case Fs:s.blendFuncSeparate(770,771,1,771);break;case yc:s.blendFunc(770,1);break;case _c:s.blendFunc(0,769);break;case vc:s.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",D);break}g=null,x=null,_=null,M=null,m=D,w=Ee}return}mt=mt||ot,Bt=Bt||q,Te=Te||ht,(ot!==y||mt!==v)&&(s.blendEquationSeparate(ut[ot],ut[mt]),y=ot,v=mt),(q!==g||ht!==x||Bt!==_||Te!==M)&&(s.blendFuncSeparate(pt[q],pt[ht],pt[Bt],pt[Te]),g=q,x=ht,_=Bt,M=Te),m=D,w=null}function G(D,ot){D.side===Wi?lt(2884):K(2884);let q=D.side===se;ot&&(q=!q),$(q),D.blending===Fs&&D.transparent===!1?Ct(In):Ct(D.blending,D.blendEquation,D.blendSrc,D.blendDst,D.blendEquationAlpha,D.blendSrcAlpha,D.blendDstAlpha,D.premultipliedAlpha),l.setFunc(D.depthFunc),l.setTest(D.depthTest),l.setMask(D.depthWrite),a.setMask(D.colorWrite);const ht=D.stencilWrite;c.setTest(ht),ht&&(c.setMask(D.stencilWriteMask),c.setFunc(D.stencilFunc,D.stencilRef,D.stencilFuncMask),c.setOp(D.stencilFail,D.stencilZFail,D.stencilZPass)),rt(D.polygonOffset,D.polygonOffsetFactor,D.polygonOffsetUnits),D.alphaToCoverage===!0?K(32926):lt(32926)}function $(D){b!==D&&(D?s.frontFace(2304):s.frontFace(2305),b=D)}function Q(D){D!==hp?(K(2884),D!==E&&(D===xc?s.cullFace(1029):D===up?s.cullFace(1028):s.cullFace(1032))):lt(2884),E=D}function gt(D){D!==P&&(k&&s.lineWidth(D),P=D)}function rt(D,ot,q){D?(K(32823),(R!==ot||C!==q)&&(s.polygonOffset(ot,q),R=ot,C=q)):lt(32823)}function L(D){D?K(3089):lt(3089)}function A(D){D===void 0&&(D=33984+U-1),F!==D&&(s.activeTexture(D),F=D)}function W(D,ot){F===null&&A();let q=N[F];q===void 0&&(q={type:void 0,texture:void 0},N[F]=q),(q.type!==D||q.texture!==ot)&&(s.bindTexture(D,ot||X[D]),q.type=D,q.texture=ot)}function Y(){const D=N[F];D!==void 0&&D.type!==void 0&&(s.bindTexture(D.type,null),D.type=void 0,D.texture=void 0)}function st(){try{s.compressedTexImage2D.apply(s,arguments)}catch(D){console.error("THREE.WebGLState:",D)}}function ct(){try{s.texImage2D.apply(s,arguments)}catch(D){console.error("THREE.WebGLState:",D)}}function St(){try{s.texImage3D.apply(s,arguments)}catch(D){console.error("THREE.WebGLState:",D)}}function yt(D){dt.equals(D)===!1&&(s.scissor(D.x,D.y,D.z,D.w),dt.copy(D))}function Lt(D){nt.equals(D)===!1&&(s.viewport(D.x,D.y,D.z,D.w),nt.copy(D))}function xt(){s.disable(3042),s.disable(2884),s.disable(2929),s.disable(32823),s.disable(3089),s.disable(2960),s.disable(32926),s.blendEquation(32774),s.blendFunc(1,0),s.blendFuncSeparate(1,0,1,0),s.colorMask(!0,!0,!0,!0),s.clearColor(0,0,0,0),s.depthMask(!0),s.depthFunc(513),s.clearDepth(1),s.stencilMask(4294967295),s.stencilFunc(519,0,4294967295),s.stencilOp(7680,7680,7680),s.clearStencil(0),s.cullFace(1029),s.frontFace(2305),s.polygonOffset(0,0),s.activeTexture(33984),s.bindFramebuffer(36160,null),n===!0&&(s.bindFramebuffer(36009,null),s.bindFramebuffer(36008,null)),s.useProgram(null),s.lineWidth(1),s.scissor(0,0,s.canvas.width,s.canvas.height),s.viewport(0,0,s.canvas.width,s.canvas.height),h={},F=null,N={},u=null,d={},f=null,p=!1,m=null,y=null,g=null,x=null,v=null,_=null,M=null,w=!1,b=null,E=null,P=null,R=null,C=null,dt.set(0,0,s.canvas.width,s.canvas.height),nt.set(0,0,s.canvas.width,s.canvas.height),a.reset(),l.reset(),c.reset()}return{buffers:{color:a,depth:l,stencil:c},enable:K,disable:lt,bindFramebuffer:vt,bindXRFramebuffer:H,useProgram:Tt,setBlending:Ct,setMaterial:G,setFlipSided:$,setCullFace:Q,setLineWidth:gt,setPolygonOffset:rt,setScissorTest:L,activeTexture:A,bindTexture:W,unbindTexture:Y,compressedTexImage2D:st,texImage2D:ct,texImage3D:St,scissor:yt,viewport:Lt,reset:xt}}function wM(s,t,e,n,i,r,o){const a=i.isWebGL2,l=i.maxTextures,c=i.maxCubemapSize,h=i.maxTextureSize,u=i.maxSamples,d=new WeakMap;let f,p=!1;try{p=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function m(L,A){return p?new OffscreenCanvas(L,A):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function y(L,A,W,Y){let st=1;if((L.width>Y||L.height>Y)&&(st=Y/Math.max(L.width,L.height)),st<1||A===!0)if(typeof HTMLImageElement<"u"&&L instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&L instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&L instanceof ImageBitmap){const ct=A?Um:Math.floor,St=ct(st*L.width),yt=ct(st*L.height);f===void 0&&(f=m(St,yt));const Lt=W?m(St,yt):f;return Lt.width=St,Lt.height=yt,Lt.getContext("2d").drawImage(L,0,0,St,yt),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+L.width+"x"+L.height+") to ("+St+"x"+yt+")."),Lt}else return"data"in L&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+L.width+"x"+L.height+")."),L;return L}function g(L){return Fc(L.width)&&Fc(L.height)}function x(L){return a?!1:L.wrapS!==we||L.wrapT!==we||L.minFilter!==le&&L.minFilter!==he}function v(L,A){return L.generateMipmaps&&A&&L.minFilter!==le&&L.minFilter!==he}function _(L,A,W,Y,st=1){s.generateMipmap(L);const ct=n.get(A);ct.__maxMipLevel=Math.log2(Math.max(W,Y,st))}function M(L,A,W){if(a===!1)return A;if(L!==null){if(s[L]!==void 0)return s[L];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+L+"'")}let Y=A;return A===6403&&(W===5126&&(Y=33326),W===5131&&(Y=33325),W===5121&&(Y=33321)),A===6407&&(W===5126&&(Y=34837),W===5131&&(Y=34843),W===5121&&(Y=32849)),A===6408&&(W===5126&&(Y=34836),W===5131&&(Y=34842),W===5121&&(Y=32856)),(Y===33325||Y===33326||Y===34842||Y===34836)&&t.get("EXT_color_buffer_float"),Y}function w(L){return L===le||L===La||L===Ca?9728:9729}function b(L){const A=L.target;A.removeEventListener("dispose",b),P(A),A.isVideoTexture&&d.delete(A),o.memory.textures--}function E(L){const A=L.target;A.removeEventListener("dispose",E),R(A)}function P(L){const A=n.get(L);A.__webglInit!==void 0&&(s.deleteTexture(A.__webglTexture),n.remove(L))}function R(L){const A=L.texture,W=n.get(L),Y=n.get(A);if(L){if(Y.__webglTexture!==void 0&&(s.deleteTexture(Y.__webglTexture),o.memory.textures--),L.depthTexture&&L.depthTexture.dispose(),L.isWebGLCubeRenderTarget)for(let st=0;st<6;st++)s.deleteFramebuffer(W.__webglFramebuffer[st]),W.__webglDepthbuffer&&s.deleteRenderbuffer(W.__webglDepthbuffer[st]);else s.deleteFramebuffer(W.__webglFramebuffer),W.__webglDepthbuffer&&s.deleteRenderbuffer(W.__webglDepthbuffer),W.__webglMultisampledFramebuffer&&s.deleteFramebuffer(W.__webglMultisampledFramebuffer),W.__webglColorRenderbuffer&&s.deleteRenderbuffer(W.__webglColorRenderbuffer),W.__webglDepthRenderbuffer&&s.deleteRenderbuffer(W.__webglDepthRenderbuffer);if(L.isWebGLMultipleRenderTargets)for(let st=0,ct=A.length;st<ct;st++){const St=n.get(A[st]);St.__webglTexture&&(s.deleteTexture(St.__webglTexture),o.memory.textures--),n.remove(A[st])}n.remove(A),n.remove(L)}}let C=0;function U(){C=0}function k(){const L=C;return L>=l&&console.warn("THREE.WebGLTextures: Trying to use "+L+" texture units while this GPU supports only "+l),C+=1,L}function B(L,A){const W=n.get(L);if(L.isVideoTexture&&G(L),L.version>0&&W.__version!==L.version){const Y=L.image;if(Y===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(Y.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{_t(W,L,A);return}}e.activeTexture(33984+A),e.bindTexture(3553,W.__webglTexture)}function O(L,A){const W=n.get(L);if(L.version>0&&W.__version!==L.version){_t(W,L,A);return}e.activeTexture(33984+A),e.bindTexture(35866,W.__webglTexture)}function F(L,A){const W=n.get(L);if(L.version>0&&W.__version!==L.version){_t(W,L,A);return}e.activeTexture(33984+A),e.bindTexture(32879,W.__webglTexture)}function N(L,A){const W=n.get(L);if(L.version>0&&W.__version!==L.version){X(W,L,A);return}e.activeTexture(33984+A),e.bindTexture(34067,W.__webglTexture)}const Z={[Nr]:10497,[we]:33071,[Hr]:33648},tt={[le]:9728,[La]:9984,[Ca]:9986,[he]:9729,[nh]:9985,[Qi]:9987};function dt(L,A,W){if(W?(s.texParameteri(L,10242,Z[A.wrapS]),s.texParameteri(L,10243,Z[A.wrapT]),(L===32879||L===35866)&&s.texParameteri(L,32882,Z[A.wrapR]),s.texParameteri(L,10240,tt[A.magFilter]),s.texParameteri(L,10241,tt[A.minFilter])):(s.texParameteri(L,10242,33071),s.texParameteri(L,10243,33071),(L===32879||L===35866)&&s.texParameteri(L,32882,33071),(A.wrapS!==we||A.wrapT!==we)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),s.texParameteri(L,10240,w(A.magFilter)),s.texParameteri(L,10241,w(A.minFilter)),A.minFilter!==le&&A.minFilter!==he&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),t.has("EXT_texture_filter_anisotropic")===!0){const Y=t.get("EXT_texture_filter_anisotropic");if(A.type===Cn&&t.has("OES_texture_float_linear")===!1||a===!1&&A.type===Bi&&t.has("OES_texture_half_float_linear")===!1)return;(A.anisotropy>1||n.get(A).__currentAnisotropy)&&(s.texParameterf(L,Y.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(A.anisotropy,i.getMaxAnisotropy())),n.get(A).__currentAnisotropy=A.anisotropy)}}function nt(L,A){L.__webglInit===void 0&&(L.__webglInit=!0,A.addEventListener("dispose",b),L.__webglTexture=s.createTexture(),o.memory.textures++)}function _t(L,A,W){let Y=3553;A.isDataTexture2DArray&&(Y=35866),A.isDataTexture3D&&(Y=32879),nt(L,A),e.activeTexture(33984+W),e.bindTexture(Y,L.__webglTexture),s.pixelStorei(37440,A.flipY),s.pixelStorei(37441,A.premultiplyAlpha),s.pixelStorei(3317,A.unpackAlignment),s.pixelStorei(37443,0);const st=x(A)&&g(A.image)===!1,ct=y(A.image,st,!1,h),St=g(ct)||a,yt=r.convert(A.format);let Lt=r.convert(A.type),xt=M(A.internalFormat,yt,Lt);dt(Y,A,St);let D;const ot=A.mipmaps;if(A.isDepthTexture)xt=6402,a?A.type===Cn?xt=36012:A.type===Cr?xt=33190:A.type===ks?xt=35056:xt=33189:A.type===Cn&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),A.format===Oi&&xt===6402&&A.type!==Ur&&A.type!==Cr&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),A.type=Ur,Lt=r.convert(A.type)),A.format===zs&&xt===6402&&(xt=34041,A.type!==ks&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),A.type=ks,Lt=r.convert(A.type))),e.texImage2D(3553,0,xt,ct.width,ct.height,0,yt,Lt,null);else if(A.isDataTexture)if(ot.length>0&&St){for(let q=0,ht=ot.length;q<ht;q++)D=ot[q],e.texImage2D(3553,q,xt,D.width,D.height,0,yt,Lt,D.data);A.generateMipmaps=!1,L.__maxMipLevel=ot.length-1}else e.texImage2D(3553,0,xt,ct.width,ct.height,0,yt,Lt,ct.data),L.__maxMipLevel=0;else if(A.isCompressedTexture){for(let q=0,ht=ot.length;q<ht;q++)D=ot[q],A.format!==Fe&&A.format!==Fn?yt!==null?e.compressedTexImage2D(3553,q,xt,D.width,D.height,0,D.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):e.texImage2D(3553,q,xt,D.width,D.height,0,yt,Lt,D.data);L.__maxMipLevel=ot.length-1}else if(A.isDataTexture2DArray)e.texImage3D(35866,0,xt,ct.width,ct.height,ct.depth,0,yt,Lt,ct.data),L.__maxMipLevel=0;else if(A.isDataTexture3D)e.texImage3D(32879,0,xt,ct.width,ct.height,ct.depth,0,yt,Lt,ct.data),L.__maxMipLevel=0;else if(ot.length>0&&St){for(let q=0,ht=ot.length;q<ht;q++)D=ot[q],e.texImage2D(3553,q,xt,yt,Lt,D);A.generateMipmaps=!1,L.__maxMipLevel=ot.length-1}else e.texImage2D(3553,0,xt,yt,Lt,ct),L.__maxMipLevel=0;v(A,St)&&_(Y,A,ct.width,ct.height),L.__version=A.version,A.onUpdate&&A.onUpdate(A)}function X(L,A,W){if(A.image.length!==6)return;nt(L,A),e.activeTexture(33984+W),e.bindTexture(34067,L.__webglTexture),s.pixelStorei(37440,A.flipY),s.pixelStorei(37441,A.premultiplyAlpha),s.pixelStorei(3317,A.unpackAlignment),s.pixelStorei(37443,0);const Y=A&&(A.isCompressedTexture||A.image[0].isCompressedTexture),st=A.image[0]&&A.image[0].isDataTexture,ct=[];for(let q=0;q<6;q++)!Y&&!st?ct[q]=y(A.image[q],!1,!0,c):ct[q]=st?A.image[q].image:A.image[q];const St=ct[0],yt=g(St)||a,Lt=r.convert(A.format),xt=r.convert(A.type),D=M(A.internalFormat,Lt,xt);dt(34067,A,yt);let ot;if(Y){for(let q=0;q<6;q++){ot=ct[q].mipmaps;for(let ht=0;ht<ot.length;ht++){const mt=ot[ht];A.format!==Fe&&A.format!==Fn?Lt!==null?e.compressedTexImage2D(34069+q,ht,D,mt.width,mt.height,0,mt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):e.texImage2D(34069+q,ht,D,mt.width,mt.height,0,Lt,xt,mt.data)}}L.__maxMipLevel=ot.length-1}else{ot=A.mipmaps;for(let q=0;q<6;q++)if(st){e.texImage2D(34069+q,0,D,ct[q].width,ct[q].height,0,Lt,xt,ct[q].data);for(let ht=0;ht<ot.length;ht++){const Bt=ot[ht].image[q].image;e.texImage2D(34069+q,ht+1,D,Bt.width,Bt.height,0,Lt,xt,Bt.data)}}else{e.texImage2D(34069+q,0,D,Lt,xt,ct[q]);for(let ht=0;ht<ot.length;ht++){const mt=ot[ht];e.texImage2D(34069+q,ht+1,D,Lt,xt,mt.image[q])}}L.__maxMipLevel=ot.length}v(A,yt)&&_(34067,A,St.width,St.height),L.__version=A.version,A.onUpdate&&A.onUpdate(A)}function K(L,A,W,Y,st){const ct=r.convert(W.format),St=r.convert(W.type),yt=M(W.internalFormat,ct,St);st===32879||st===35866?e.texImage3D(st,0,yt,A.width,A.height,A.depth,0,ct,St,null):e.texImage2D(st,0,yt,A.width,A.height,0,ct,St,null),e.bindFramebuffer(36160,L),s.framebufferTexture2D(36160,Y,st,n.get(W).__webglTexture,0),e.bindFramebuffer(36160,null)}function lt(L,A,W){if(s.bindRenderbuffer(36161,L),A.depthBuffer&&!A.stencilBuffer){let Y=33189;if(W){const st=A.depthTexture;st&&st.isDepthTexture&&(st.type===Cn?Y=36012:st.type===Cr&&(Y=33190));const ct=Ct(A);s.renderbufferStorageMultisample(36161,ct,Y,A.width,A.height)}else s.renderbufferStorage(36161,Y,A.width,A.height);s.framebufferRenderbuffer(36160,36096,36161,L)}else if(A.depthBuffer&&A.stencilBuffer){if(W){const Y=Ct(A);s.renderbufferStorageMultisample(36161,Y,35056,A.width,A.height)}else s.renderbufferStorage(36161,34041,A.width,A.height);s.framebufferRenderbuffer(36160,33306,36161,L)}else{const Y=A.isWebGLMultipleRenderTargets===!0?A.texture[0]:A.texture,st=r.convert(Y.format),ct=r.convert(Y.type),St=M(Y.internalFormat,st,ct);if(W){const yt=Ct(A);s.renderbufferStorageMultisample(36161,yt,St,A.width,A.height)}else s.renderbufferStorage(36161,St,A.width,A.height)}s.bindRenderbuffer(36161,null)}function H(L,A){if(A&&A.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(36160,L),!(A.depthTexture&&A.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!n.get(A.depthTexture).__webglTexture||A.depthTexture.image.width!==A.width||A.depthTexture.image.height!==A.height)&&(A.depthTexture.image.width=A.width,A.depthTexture.image.height=A.height,A.depthTexture.needsUpdate=!0),B(A.depthTexture,0);const Y=n.get(A.depthTexture).__webglTexture;if(A.depthTexture.format===Oi)s.framebufferTexture2D(36160,36096,3553,Y,0);else if(A.depthTexture.format===zs)s.framebufferTexture2D(36160,33306,3553,Y,0);else throw new Error("Unknown depthTexture format")}function vt(L){const A=n.get(L),W=L.isWebGLCubeRenderTarget===!0;if(L.depthTexture){if(W)throw new Error("target.depthTexture not supported in Cube render targets");H(A.__webglFramebuffer,L)}else if(W){A.__webglDepthbuffer=[];for(let Y=0;Y<6;Y++)e.bindFramebuffer(36160,A.__webglFramebuffer[Y]),A.__webglDepthbuffer[Y]=s.createRenderbuffer(),lt(A.__webglDepthbuffer[Y],L,!1)}else e.bindFramebuffer(36160,A.__webglFramebuffer),A.__webglDepthbuffer=s.createRenderbuffer(),lt(A.__webglDepthbuffer,L,!1);e.bindFramebuffer(36160,null)}function Tt(L){const A=L.texture,W=n.get(L),Y=n.get(A);L.addEventListener("dispose",E),L.isWebGLMultipleRenderTargets!==!0&&(Y.__webglTexture=s.createTexture(),Y.__version=A.version,o.memory.textures++);const st=L.isWebGLCubeRenderTarget===!0,ct=L.isWebGLMultipleRenderTargets===!0,St=L.isWebGLMultisampleRenderTarget===!0,yt=A.isDataTexture3D||A.isDataTexture2DArray,Lt=g(L)||a;if(a&&A.format===Fn&&(A.type===Cn||A.type===Bi)&&(A.format=Fe,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),st){W.__webglFramebuffer=[];for(let xt=0;xt<6;xt++)W.__webglFramebuffer[xt]=s.createFramebuffer()}else if(W.__webglFramebuffer=s.createFramebuffer(),ct)if(i.drawBuffers){const xt=L.texture;for(let D=0,ot=xt.length;D<ot;D++){const q=n.get(xt[D]);q.__webglTexture===void 0&&(q.__webglTexture=s.createTexture(),o.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(St)if(a){W.__webglMultisampledFramebuffer=s.createFramebuffer(),W.__webglColorRenderbuffer=s.createRenderbuffer(),s.bindRenderbuffer(36161,W.__webglColorRenderbuffer);const xt=r.convert(A.format),D=r.convert(A.type),ot=M(A.internalFormat,xt,D),q=Ct(L);s.renderbufferStorageMultisample(36161,q,ot,L.width,L.height),e.bindFramebuffer(36160,W.__webglMultisampledFramebuffer),s.framebufferRenderbuffer(36160,36064,36161,W.__webglColorRenderbuffer),s.bindRenderbuffer(36161,null),L.depthBuffer&&(W.__webglDepthRenderbuffer=s.createRenderbuffer(),lt(W.__webglDepthRenderbuffer,L,!0)),e.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(st){e.bindTexture(34067,Y.__webglTexture),dt(34067,A,Lt);for(let xt=0;xt<6;xt++)K(W.__webglFramebuffer[xt],L,A,36064,34069+xt);v(A,Lt)&&_(34067,A,L.width,L.height),e.unbindTexture()}else if(ct){const xt=L.texture;for(let D=0,ot=xt.length;D<ot;D++){const q=xt[D],ht=n.get(q);e.bindTexture(3553,ht.__webglTexture),dt(3553,q,Lt),K(W.__webglFramebuffer,L,q,36064+D,3553),v(q,Lt)&&_(3553,q,L.width,L.height)}e.unbindTexture()}else{let xt=3553;yt&&(a?xt=A.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),e.bindTexture(xt,Y.__webglTexture),dt(xt,A,Lt),K(W.__webglFramebuffer,L,A,36064,xt),v(A,Lt)&&_(xt,A,L.width,L.height,L.depth),e.unbindTexture()}L.depthBuffer&&vt(L)}function ut(L){const A=g(L)||a,W=L.isWebGLMultipleRenderTargets===!0?L.texture:[L.texture];for(let Y=0,st=W.length;Y<st;Y++){const ct=W[Y];if(v(ct,A)){const St=L.isWebGLCubeRenderTarget?34067:3553,yt=n.get(ct).__webglTexture;e.bindTexture(St,yt),_(St,ct,L.width,L.height),e.unbindTexture()}}}function pt(L){if(L.isWebGLMultisampleRenderTarget)if(a){const A=L.width,W=L.height;let Y=16384;L.depthBuffer&&(Y|=256),L.stencilBuffer&&(Y|=1024);const st=n.get(L);e.bindFramebuffer(36008,st.__webglMultisampledFramebuffer),e.bindFramebuffer(36009,st.__webglFramebuffer),s.blitFramebuffer(0,0,A,W,0,0,A,W,Y,9728),e.bindFramebuffer(36008,null),e.bindFramebuffer(36009,st.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function Ct(L){return a&&L.isWebGLMultisampleRenderTarget?Math.min(u,L.samples):0}function G(L){const A=o.render.frame;d.get(L)!==A&&(d.set(L,A),L.update())}let $=!1,Q=!1;function gt(L,A){L&&L.isWebGLRenderTarget&&($===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),$=!0),L=L.texture),B(L,A)}function rt(L,A){L&&L.isWebGLCubeRenderTarget&&(Q===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),Q=!0),L=L.texture),N(L,A)}this.allocateTextureUnit=k,this.resetTextureUnits=U,this.setTexture2D=B,this.setTexture2DArray=O,this.setTexture3D=F,this.setTextureCube=N,this.setupRenderTarget=Tt,this.updateRenderTargetMipmap=ut,this.updateMultisampleRenderTarget=pt,this.safeSetTexture2D=gt,this.safeSetTextureCube=rt}function ug(s,t,e){const n=e.isWebGL2;function i(r){let o;if(r===Gi)return 5121;if(r===Vp)return 32819;if(r===Wp)return 32820;if(r===Gp)return 33635;if(r===Np)return 5120;if(r===Hp)return 5122;if(r===Ur)return 5123;if(r===Up)return 5124;if(r===Cr)return 5125;if(r===Cn)return 5126;if(r===Bi)return n?5131:(o=t.get("OES_texture_half_float"),o!==null?o.HALF_FLOAT_OES:null);if(r===Xp)return 6406;if(r===Fn)return 6407;if(r===Fe)return 6408;if(r===qp)return 6409;if(r===Yp)return 6410;if(r===Oi)return 6402;if(r===zs)return 34041;if(r===Jp)return 6403;if(r===Zp)return 36244;if(r===$p)return 33319;if(r===Kp)return 33320;if(r===Qp)return 36248;if(r===tm)return 36249;if(r===wc||r===Sc||r===Tc||r===Ec)if(o=t.get("WEBGL_compressed_texture_s3tc"),o!==null){if(r===wc)return o.COMPRESSED_RGB_S3TC_DXT1_EXT;if(r===Sc)return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(r===Tc)return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(r===Ec)return o.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(r===Ac||r===Lc||r===Cc||r===Rc)if(o=t.get("WEBGL_compressed_texture_pvrtc"),o!==null){if(r===Ac)return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(r===Lc)return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(r===Cc)return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(r===Rc)return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(r===em)return o=t.get("WEBGL_compressed_texture_etc1"),o!==null?o.COMPRESSED_RGB_ETC1_WEBGL:null;if((r===Pc||r===Dc)&&(o=t.get("WEBGL_compressed_texture_etc"),o!==null)){if(r===Pc)return o.COMPRESSED_RGB8_ETC2;if(r===Dc)return o.COMPRESSED_RGBA8_ETC2_EAC}if(r===nm||r===im||r===sm||r===rm||r===om||r===am||r===lm||r===cm||r===hm||r===um||r===dm||r===fm||r===pm||r===mm||r===xm||r===ym||r===_m||r===vm||r===bm||r===Mm||r===wm||r===Sm||r===Tm||r===Em||r===Am||r===Lm||r===Cm||r===Rm)return o=t.get("WEBGL_compressed_texture_astc"),o!==null?r:null;if(r===gm)return o=t.get("EXT_texture_compression_bptc"),o!==null?r:null;if(r===ks)return n?34042:(o=t.get("WEBGL_depth_texture"),o!==null?o.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:i}}class ph extends ge{constructor(t=[]){super(),this.cameras=t}}ph.prototype.isArrayCamera=!0;class Fi extends It{constructor(){super(),this.type="Group"}}Fi.prototype.isGroup=!0;const SM={type:"move"};class ql{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Fi,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Fi,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new S,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new S),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Fi,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new S,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new S),this._grip}dispatchEvent(t){return this._targetRay!==null&&this._targetRay.dispatchEvent(t),this._grip!==null&&this._grip.dispatchEvent(t),this._hand!==null&&this._hand.dispatchEvent(t),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(t,e,n){let i=null,r=null,o=null;const a=this._targetRay,l=this._grip,c=this._hand;if(t&&e.session.visibilityState!=="visible-blurred")if(a!==null&&(i=e.getPose(t.targetRaySpace,n),i!==null&&(a.matrix.fromArray(i.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),i.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(i.linearVelocity)):a.hasLinearVelocity=!1,i.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(i.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(SM))),c&&t.hand){o=!0;for(const m of t.hand.values()){const y=e.getJointPose(m,n);if(c.joints[m.jointName]===void 0){const x=new Fi;x.matrixAutoUpdate=!1,x.visible=!1,c.joints[m.jointName]=x,c.add(x)}const g=c.joints[m.jointName];y!==null&&(g.matrix.fromArray(y.transform.matrix),g.matrix.decompose(g.position,g.rotation,g.scale),g.jointRadius=y.radius),g.visible=y!==null}const h=c.joints["index-finger-tip"],u=c.joints["thumb-tip"],d=h.position.distanceTo(u.position),f=.02,p=.005;c.inputState.pinching&&d>f+p?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!c.inputState.pinching&&d<=f-p&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else l!==null&&t.gripSpace&&(r=e.getPose(t.gripSpace,n),r!==null&&(l.matrix.fromArray(r.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),r.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(r.linearVelocity)):l.hasLinearVelocity=!1,r.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(r.angularVelocity)):l.hasAngularVelocity=!1));return a!==null&&(a.visible=i!==null),l!==null&&(l.visible=r!==null),c!==null&&(c.visible=o!==null),this}}class TM extends di{constructor(t,e){super();const n=this,i=t.state;let r=null,o=1,a=null,l="local-floor",c=null,h=null,u=null,d=null,f=null,p=!1,m=null,y=null,g=null,x=null,v=null,_=null;const M=[],w=new Map,b=new ge;b.layers.enable(1),b.viewport=new Xt;const E=new ge;E.layers.enable(2),E.viewport=new Xt;const P=[b,E],R=new ph;R.layers.enable(1),R.layers.enable(2);let C=null,U=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(X){let K=M[X];return K===void 0&&(K=new ql,M[X]=K),K.getTargetRaySpace()},this.getControllerGrip=function(X){let K=M[X];return K===void 0&&(K=new ql,M[X]=K),K.getGripSpace()},this.getHand=function(X){let K=M[X];return K===void 0&&(K=new ql,M[X]=K),K.getHandSpace()};function k(X){const K=w.get(X.inputSource);K&&K.dispatchEvent({type:X.type,data:X.inputSource})}function B(){w.forEach(function(X,K){X.disconnect(K)}),w.clear(),C=null,U=null,i.bindXRFramebuffer(null),t.setRenderTarget(t.getRenderTarget()),u&&e.deleteFramebuffer(u),m&&e.deleteFramebuffer(m),y&&e.deleteRenderbuffer(y),g&&e.deleteRenderbuffer(g),u=null,m=null,y=null,g=null,f=null,d=null,h=null,r=null,_t.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(X){o=X,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(X){l=X,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return a},this.getBaseLayer=function(){return d!==null?d:f},this.getBinding=function(){return h},this.getFrame=function(){return x},this.getSession=function(){return r},this.setSession=async function(X){if(r=X,r!==null){r.addEventListener("select",k),r.addEventListener("selectstart",k),r.addEventListener("selectend",k),r.addEventListener("squeeze",k),r.addEventListener("squeezestart",k),r.addEventListener("squeezeend",k),r.addEventListener("end",B),r.addEventListener("inputsourceschange",O);const K=e.getContextAttributes();if(K.xrCompatible!==!0&&await e.makeXRCompatible(),r.renderState.layers===void 0){const lt={antialias:K.antialias,alpha:K.alpha,depth:K.depth,stencil:K.stencil,framebufferScaleFactor:o};f=new XRWebGLLayer(r,e,lt),r.updateRenderState({baseLayer:f})}else if(e instanceof WebGLRenderingContext){const lt={antialias:!0,alpha:K.alpha,depth:K.depth,stencil:K.stencil,framebufferScaleFactor:o};f=new XRWebGLLayer(r,e,lt),r.updateRenderState({layers:[f]})}else{p=K.antialias;let lt=null;K.depth&&(_=256,K.stencil&&(_|=1024),v=K.stencil?33306:36096,lt=K.stencil?35056:33190);const H={colorFormat:K.alpha?32856:32849,depthFormat:lt,scaleFactor:o};h=new XRWebGLBinding(r,e),d=h.createProjectionLayer(H),u=e.createFramebuffer(),r.updateRenderState({layers:[d]}),p&&(m=e.createFramebuffer(),y=e.createRenderbuffer(),e.bindRenderbuffer(36161,y),e.renderbufferStorageMultisample(36161,4,32856,d.textureWidth,d.textureHeight),i.bindFramebuffer(36160,m),e.framebufferRenderbuffer(36160,36064,36161,y),e.bindRenderbuffer(36161,null),lt!==null&&(g=e.createRenderbuffer(),e.bindRenderbuffer(36161,g),e.renderbufferStorageMultisample(36161,4,lt,d.textureWidth,d.textureHeight),e.framebufferRenderbuffer(36160,v,36161,g),e.bindRenderbuffer(36161,null)),i.bindFramebuffer(36160,null))}a=await r.requestReferenceSpace(l),_t.setContext(r),_t.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};function O(X){const K=r.inputSources;for(let lt=0;lt<M.length;lt++)w.set(K[lt],M[lt]);for(let lt=0;lt<X.removed.length;lt++){const H=X.removed[lt],vt=w.get(H);vt&&(vt.dispatchEvent({type:"disconnected",data:H}),w.delete(H))}for(let lt=0;lt<X.added.length;lt++){const H=X.added[lt],vt=w.get(H);vt&&vt.dispatchEvent({type:"connected",data:H})}}const F=new S,N=new S;function Z(X,K,lt){F.setFromMatrixPosition(K.matrixWorld),N.setFromMatrixPosition(lt.matrixWorld);const H=F.distanceTo(N),vt=K.projectionMatrix.elements,Tt=lt.projectionMatrix.elements,ut=vt[14]/(vt[10]-1),pt=vt[14]/(vt[10]+1),Ct=(vt[9]+1)/vt[5],G=(vt[9]-1)/vt[5],$=(vt[8]-1)/vt[0],Q=(Tt[8]+1)/Tt[0],gt=ut*$,rt=ut*Q,L=H/(-$+Q),A=L*-$;K.matrixWorld.decompose(X.position,X.quaternion,X.scale),X.translateX(A),X.translateZ(L),X.matrixWorld.compose(X.position,X.quaternion,X.scale),X.matrixWorldInverse.copy(X.matrixWorld).invert();const W=ut+L,Y=pt+L,st=gt-A,ct=rt+(H-A),St=Ct*pt/Y*W,yt=G*pt/Y*W;X.projectionMatrix.makePerspective(st,ct,St,yt,W,Y)}function tt(X,K){K===null?X.matrixWorld.copy(X.matrix):X.matrixWorld.multiplyMatrices(K.matrixWorld,X.matrix),X.matrixWorldInverse.copy(X.matrixWorld).invert()}this.updateCamera=function(X){if(r===null)return;R.near=E.near=b.near=X.near,R.far=E.far=b.far=X.far,(C!==R.near||U!==R.far)&&(r.updateRenderState({depthNear:R.near,depthFar:R.far}),C=R.near,U=R.far);const K=X.parent,lt=R.cameras;tt(R,K);for(let vt=0;vt<lt.length;vt++)tt(lt[vt],K);R.matrixWorld.decompose(R.position,R.quaternion,R.scale),X.position.copy(R.position),X.quaternion.copy(R.quaternion),X.scale.copy(R.scale),X.matrix.copy(R.matrix),X.matrixWorld.copy(R.matrixWorld);const H=X.children;for(let vt=0,Tt=H.length;vt<Tt;vt++)H[vt].updateMatrixWorld(!0);lt.length===2?Z(R,b,E):R.projectionMatrix.copy(b.projectionMatrix)},this.getCamera=function(){return R},this.getFoveation=function(){if(d!==null)return d.fixedFoveation;if(f!==null)return f.fixedFoveation},this.setFoveation=function(X){d!==null&&(d.fixedFoveation=X),f!==null&&f.fixedFoveation!==void 0&&(f.fixedFoveation=X)};let dt=null;function nt(X,K){if(c=K.getViewerPose(a),x=K,c!==null){const H=c.views;f!==null&&i.bindXRFramebuffer(f.framebuffer);let vt=!1;H.length!==R.cameras.length&&(R.cameras.length=0,vt=!0);for(let Tt=0;Tt<H.length;Tt++){const ut=H[Tt];let pt=null;if(f!==null)pt=f.getViewport(ut);else{const G=h.getViewSubImage(d,ut);i.bindXRFramebuffer(u),G.depthStencilTexture!==void 0&&e.framebufferTexture2D(36160,v,3553,G.depthStencilTexture,0),e.framebufferTexture2D(36160,36064,3553,G.colorTexture,0),pt=G.viewport}const Ct=P[Tt];Ct.matrix.fromArray(ut.transform.matrix),Ct.projectionMatrix.fromArray(ut.projectionMatrix),Ct.viewport.set(pt.x,pt.y,pt.width,pt.height),Tt===0&&R.matrix.copy(Ct.matrix),vt===!0&&R.cameras.push(Ct)}p&&(i.bindXRFramebuffer(m),_!==null&&e.clear(_))}const lt=r.inputSources;for(let H=0;H<M.length;H++){const vt=M[H],Tt=lt[H];vt.update(Tt,K,a)}if(dt&&dt(X,K),p){const H=d.textureWidth,vt=d.textureHeight;i.bindFramebuffer(36008,m),i.bindFramebuffer(36009,u),e.invalidateFramebuffer(36008,[v]),e.invalidateFramebuffer(36009,[v]),e.blitFramebuffer(0,0,H,vt,0,0,H,vt,16384,9728),e.invalidateFramebuffer(36008,[36064]),i.bindFramebuffer(36008,null),i.bindFramebuffer(36009,null),i.bindFramebuffer(36160,m)}x=null}const _t=new Qm;_t.setAnimationLoop(nt),this.setAnimationLoop=function(X){dt=X},this.dispose=function(){}}}function EM(s){function t(g,x){g.fogColor.value.copy(x.color),x.isFog?(g.fogNear.value=x.near,g.fogFar.value=x.far):x.isFogExp2&&(g.fogDensity.value=x.density)}function e(g,x,v,_,M){x.isMeshBasicMaterial?n(g,x):x.isMeshLambertMaterial?(n(g,x),l(g,x)):x.isMeshToonMaterial?(n(g,x),h(g,x)):x.isMeshPhongMaterial?(n(g,x),c(g,x)):x.isMeshStandardMaterial?(n(g,x),x.isMeshPhysicalMaterial?d(g,x,M):u(g,x)):x.isMeshMatcapMaterial?(n(g,x),f(g,x)):x.isMeshDepthMaterial?(n(g,x),p(g,x)):x.isMeshDistanceMaterial?(n(g,x),m(g,x)):x.isMeshNormalMaterial?(n(g,x),y(g,x)):x.isLineBasicMaterial?(i(g,x),x.isLineDashedMaterial&&r(g,x)):x.isPointsMaterial?o(g,x,v,_):x.isSpriteMaterial?a(g,x):x.isShadowMaterial?(g.color.value.copy(x.color),g.opacity.value=x.opacity):x.isShaderMaterial&&(x.uniformsNeedUpdate=!1)}function n(g,x){g.opacity.value=x.opacity,x.color&&g.diffuse.value.copy(x.color),x.emissive&&g.emissive.value.copy(x.emissive).multiplyScalar(x.emissiveIntensity),x.map&&(g.map.value=x.map),x.alphaMap&&(g.alphaMap.value=x.alphaMap),x.specularMap&&(g.specularMap.value=x.specularMap),x.alphaTest>0&&(g.alphaTest.value=x.alphaTest);const v=s.get(x).envMap;if(v){g.envMap.value=v,g.flipEnvMap.value=v.isCubeTexture&&v.isRenderTargetTexture===!1?-1:1,g.reflectivity.value=x.reflectivity,g.ior.value=x.ior,g.refractionRatio.value=x.refractionRatio;const w=s.get(v).__maxMipLevel;w!==void 0&&(g.maxMipLevel.value=w)}x.lightMap&&(g.lightMap.value=x.lightMap,g.lightMapIntensity.value=x.lightMapIntensity),x.aoMap&&(g.aoMap.value=x.aoMap,g.aoMapIntensity.value=x.aoMapIntensity);let _;x.map?_=x.map:x.specularMap?_=x.specularMap:x.displacementMap?_=x.displacementMap:x.normalMap?_=x.normalMap:x.bumpMap?_=x.bumpMap:x.roughnessMap?_=x.roughnessMap:x.metalnessMap?_=x.metalnessMap:x.alphaMap?_=x.alphaMap:x.emissiveMap?_=x.emissiveMap:x.clearcoatMap?_=x.clearcoatMap:x.clearcoatNormalMap?_=x.clearcoatNormalMap:x.clearcoatRoughnessMap?_=x.clearcoatRoughnessMap:x.specularIntensityMap?_=x.specularIntensityMap:x.specularTintMap?_=x.specularTintMap:x.transmissionMap?_=x.transmissionMap:x.thicknessMap&&(_=x.thicknessMap),_!==void 0&&(_.isWebGLRenderTarget&&(_=_.texture),_.matrixAutoUpdate===!0&&_.updateMatrix(),g.uvTransform.value.copy(_.matrix));let M;x.aoMap?M=x.aoMap:x.lightMap&&(M=x.lightMap),M!==void 0&&(M.isWebGLRenderTarget&&(M=M.texture),M.matrixAutoUpdate===!0&&M.updateMatrix(),g.uv2Transform.value.copy(M.matrix))}function i(g,x){g.diffuse.value.copy(x.color),g.opacity.value=x.opacity}function r(g,x){g.dashSize.value=x.dashSize,g.totalSize.value=x.dashSize+x.gapSize,g.scale.value=x.scale}function o(g,x,v,_){g.diffuse.value.copy(x.color),g.opacity.value=x.opacity,g.size.value=x.size*v,g.scale.value=_*.5,x.map&&(g.map.value=x.map),x.alphaMap&&(g.alphaMap.value=x.alphaMap),x.alphaTest>0&&(g.alphaTest.value=x.alphaTest);let M;x.map?M=x.map:x.alphaMap&&(M=x.alphaMap),M!==void 0&&(M.matrixAutoUpdate===!0&&M.updateMatrix(),g.uvTransform.value.copy(M.matrix))}function a(g,x){g.diffuse.value.copy(x.color),g.opacity.value=x.opacity,g.rotation.value=x.rotation,x.map&&(g.map.value=x.map),x.alphaMap&&(g.alphaMap.value=x.alphaMap),x.alphaTest>0&&(g.alphaTest.value=x.alphaTest);let v;x.map?v=x.map:x.alphaMap&&(v=x.alphaMap),v!==void 0&&(v.matrixAutoUpdate===!0&&v.updateMatrix(),g.uvTransform.value.copy(v.matrix))}function l(g,x){x.emissiveMap&&(g.emissiveMap.value=x.emissiveMap)}function c(g,x){g.specular.value.copy(x.specular),g.shininess.value=Math.max(x.shininess,1e-4),x.emissiveMap&&(g.emissiveMap.value=x.emissiveMap),x.bumpMap&&(g.bumpMap.value=x.bumpMap,g.bumpScale.value=x.bumpScale,x.side===se&&(g.bumpScale.value*=-1)),x.normalMap&&(g.normalMap.value=x.normalMap,g.normalScale.value.copy(x.normalScale),x.side===se&&g.normalScale.value.negate()),x.displacementMap&&(g.displacementMap.value=x.displacementMap,g.displacementScale.value=x.displacementScale,g.displacementBias.value=x.displacementBias)}function h(g,x){x.gradientMap&&(g.gradientMap.value=x.gradientMap),x.emissiveMap&&(g.emissiveMap.value=x.emissiveMap),x.bumpMap&&(g.bumpMap.value=x.bumpMap,g.bumpScale.value=x.bumpScale,x.side===se&&(g.bumpScale.value*=-1)),x.normalMap&&(g.normalMap.value=x.normalMap,g.normalScale.value.copy(x.normalScale),x.side===se&&g.normalScale.value.negate()),x.displacementMap&&(g.displacementMap.value=x.displacementMap,g.displacementScale.value=x.displacementScale,g.displacementBias.value=x.displacementBias)}function u(g,x){g.roughness.value=x.roughness,g.metalness.value=x.metalness,x.roughnessMap&&(g.roughnessMap.value=x.roughnessMap),x.metalnessMap&&(g.metalnessMap.value=x.metalnessMap),x.emissiveMap&&(g.emissiveMap.value=x.emissiveMap),x.bumpMap&&(g.bumpMap.value=x.bumpMap,g.bumpScale.value=x.bumpScale,x.side===se&&(g.bumpScale.value*=-1)),x.normalMap&&(g.normalMap.value=x.normalMap,g.normalScale.value.copy(x.normalScale),x.side===se&&g.normalScale.value.negate()),x.displacementMap&&(g.displacementMap.value=x.displacementMap,g.displacementScale.value=x.displacementScale,g.displacementBias.value=x.displacementBias),s.get(x).envMap&&(g.envMapIntensity.value=x.envMapIntensity)}function d(g,x,v){u(g,x),g.ior.value=x.ior,x.sheenTint&&g.sheenTint.value.copy(x.sheenTint),x.clearcoat>0&&(g.clearcoat.value=x.clearcoat,g.clearcoatRoughness.value=x.clearcoatRoughness,x.clearcoatMap&&(g.clearcoatMap.value=x.clearcoatMap),x.clearcoatRoughnessMap&&(g.clearcoatRoughnessMap.value=x.clearcoatRoughnessMap),x.clearcoatNormalMap&&(g.clearcoatNormalScale.value.copy(x.clearcoatNormalScale),g.clearcoatNormalMap.value=x.clearcoatNormalMap,x.side===se&&g.clearcoatNormalScale.value.negate())),x.transmission>0&&(g.transmission.value=x.transmission,g.transmissionSamplerMap.value=v.texture,g.transmissionSamplerSize.value.set(v.width,v.height),x.transmissionMap&&(g.transmissionMap.value=x.transmissionMap),g.thickness.value=x.thickness,x.thicknessMap&&(g.thicknessMap.value=x.thicknessMap),g.attenuationDistance.value=x.attenuationDistance,g.attenuationTint.value.copy(x.attenuationTint)),g.specularIntensity.value=x.specularIntensity,g.specularTint.value.copy(x.specularTint),x.specularIntensityMap&&(g.specularIntensityMap.value=x.specularIntensityMap),x.specularTintMap&&(g.specularTintMap.value=x.specularTintMap)}function f(g,x){x.matcap&&(g.matcap.value=x.matcap),x.bumpMap&&(g.bumpMap.value=x.bumpMap,g.bumpScale.value=x.bumpScale,x.side===se&&(g.bumpScale.value*=-1)),x.normalMap&&(g.normalMap.value=x.normalMap,g.normalScale.value.copy(x.normalScale),x.side===se&&g.normalScale.value.negate()),x.displacementMap&&(g.displacementMap.value=x.displacementMap,g.displacementScale.value=x.displacementScale,g.displacementBias.value=x.displacementBias)}function p(g,x){x.displacementMap&&(g.displacementMap.value=x.displacementMap,g.displacementScale.value=x.displacementScale,g.displacementBias.value=x.displacementBias)}function m(g,x){x.displacementMap&&(g.displacementMap.value=x.displacementMap,g.displacementScale.value=x.displacementScale,g.displacementBias.value=x.displacementBias),g.referencePosition.value.copy(x.referencePosition),g.nearDistance.value=x.nearDistance,g.farDistance.value=x.farDistance}function y(g,x){x.bumpMap&&(g.bumpMap.value=x.bumpMap,g.bumpScale.value=x.bumpScale,x.side===se&&(g.bumpScale.value*=-1)),x.normalMap&&(g.normalMap.value=x.normalMap,g.normalScale.value.copy(x.normalScale),x.side===se&&g.normalScale.value.negate()),x.displacementMap&&(g.displacementMap.value=x.displacementMap,g.displacementScale.value=x.displacementScale,g.displacementBias.value=x.displacementBias)}return{refreshFogUniforms:t,refreshMaterialUniforms:e}}function AM(){const s=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return s.style.display="block",s}function qt(s={}){const t=s.canvas!==void 0?s.canvas:AM(),e=s.context!==void 0?s.context:null,n=s.alpha!==void 0?s.alpha:!1,i=s.depth!==void 0?s.depth:!0,r=s.stencil!==void 0?s.stencil:!0,o=s.antialias!==void 0?s.antialias:!1,a=s.premultipliedAlpha!==void 0?s.premultipliedAlpha:!0,l=s.preserveDrawingBuffer!==void 0?s.preserveDrawingBuffer:!1,c=s.powerPreference!==void 0?s.powerPreference:"default",h=s.failIfMajorPerformanceCaveat!==void 0?s.failIfMajorPerformanceCaveat:!1;let u=null,d=null;const f=[],p=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=ke,this.physicallyCorrectLights=!1,this.toneMapping=ni,this.toneMappingExposure=1;const m=this;let y=!1,g=0,x=0,v=null,_=-1,M=null;const w=new Xt,b=new Xt;let E=null,P=t.width,R=t.height,C=1,U=null,k=null;const B=new Xt(0,0,P,R),O=new Xt(0,0,P,R);let F=!1;const N=[],Z=new ho;let tt=!1,dt=!1,nt=null;const _t=new ft,X=new S,K={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function lt(){return v===null?C:1}let H=e;function vt(T,z){for(let I=0;I<T.length;I++){const V=T[I],J=t.getContext(V,z);if(J!==null)return J}return null}try{const T={alpha:n,depth:i,stencil:r,antialias:o,premultipliedAlpha:a,preserveDrawingBuffer:l,powerPreference:c,failIfMajorPerformanceCaveat:h};if(t.addEventListener("webglcontextlost",Te,!1),t.addEventListener("webglcontextrestored",Ee,!1),H===null){const z=["webgl2","webgl","experimental-webgl"];if(m.isWebGL1Renderer===!0&&z.shift(),H=vt(z,T),H===null)throw vt(z)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}H.getShaderPrecisionFormat===void 0&&(H.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(T){throw console.error("THREE.WebGLRenderer: "+T.message),T}let Tt,ut,pt,Ct,G,$,Q,gt,rt,L,A,W,Y,st,ct,St,yt,Lt,xt,D,ot,q,ht;function mt(){Tt=new $v(H),ut=new Gv(H,Tt,s),Tt.init(ut),q=new ug(H,Tt,ut),pt=new MM(H,Tt,ut),N[0]=1029,Ct=new tb,G=new uM,$=new wM(H,Tt,pt,G,ut,q,Ct),Q=new qv(m),gt=new Zv(m),rt=new py(H,ut),ht=new Vv(H,Tt,rt,ut),L=new Kv(H,rt,Ct,ht),A=new sb(H,L,rt,Ct),xt=new ib(H),St=new Xv(G),W=new hM(m,Q,gt,Tt,ut,ht,St),Y=new EM(G),st=new fM(G),ct=new _M(Tt,ut),Lt=new Uv(m,Q,pt,A,a),yt=new hg(m,A,ut),D=new Wv(H,Tt,Ct,ut),ot=new Qv(H,Tt,Ct,ut),Ct.programs=W.programs,m.capabilities=ut,m.extensions=Tt,m.properties=G,m.renderLists=st,m.shadowMap=yt,m.state=pt,m.info=Ct}mt();const Bt=new TM(m,H);this.xr=Bt,this.getContext=function(){return H},this.getContextAttributes=function(){return H.getContextAttributes()},this.forceContextLoss=function(){const T=Tt.get("WEBGL_lose_context");T&&T.loseContext()},this.forceContextRestore=function(){const T=Tt.get("WEBGL_lose_context");T&&T.restoreContext()},this.getPixelRatio=function(){return C},this.setPixelRatio=function(T){T!==void 0&&(C=T,this.setSize(P,R,!1))},this.getSize=function(T){return T.set(P,R)},this.setSize=function(T,z,I){if(Bt.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}P=T,R=z,t.width=Math.floor(T*C),t.height=Math.floor(z*C),I!==!1&&(t.style.width=T+"px",t.style.height=z+"px"),this.setViewport(0,0,T,z)},this.getDrawingBufferSize=function(T){return T.set(P*C,R*C).floor()},this.setDrawingBufferSize=function(T,z,I){P=T,R=z,C=I,t.width=Math.floor(T*I),t.height=Math.floor(z*I),this.setViewport(0,0,T,z)},this.getCurrentViewport=function(T){return T.copy(w)},this.getViewport=function(T){return T.copy(B)},this.setViewport=function(T,z,I,V){T.isVector4?B.set(T.x,T.y,T.z,T.w):B.set(T,z,I,V),pt.viewport(w.copy(B).multiplyScalar(C).floor())},this.getScissor=function(T){return T.copy(O)},this.setScissor=function(T,z,I,V){T.isVector4?O.set(T.x,T.y,T.z,T.w):O.set(T,z,I,V),pt.scissor(b.copy(O).multiplyScalar(C).floor())},this.getScissorTest=function(){return F},this.setScissorTest=function(T){pt.setScissorTest(F=T)},this.setOpaqueSort=function(T){U=T},this.setTransparentSort=function(T){k=T},this.getClearColor=function(T){return T.copy(Lt.getClearColor())},this.setClearColor=function(){Lt.setClearColor.apply(Lt,arguments)},this.getClearAlpha=function(){return Lt.getClearAlpha()},this.setClearAlpha=function(){Lt.setClearAlpha.apply(Lt,arguments)},this.clear=function(T,z,I){let V=0;(T===void 0||T)&&(V|=16384),(z===void 0||z)&&(V|=256),(I===void 0||I)&&(V|=1024),H.clear(V)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",Te,!1),t.removeEventListener("webglcontextrestored",Ee,!1),st.dispose(),ct.dispose(),G.dispose(),Q.dispose(),gt.dispose(),A.dispose(),ht.dispose(),Bt.dispose(),Bt.removeEventListener("sessionstart",fu),Bt.removeEventListener("sessionend",pu),nt&&(nt.dispose(),nt=null),gi.stop()};function Te(T){T.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),y=!0}function Ee(){console.log("THREE.WebGLRenderer: Context Restored."),y=!1;const T=Ct.autoReset,z=yt.enabled,I=yt.autoUpdate,V=yt.needsUpdate,J=yt.type;mt(),Ct.autoReset=T,yt.enabled=z,yt.autoUpdate=I,yt.needsUpdate=V,yt.type=J}function Un(T){const z=T.target;z.removeEventListener("dispose",Un),ee(z)}function ee(T){yn(T),G.remove(T)}function yn(T){const z=G.get(T).programs;z!==void 0&&z.forEach(function(I){W.releaseProgram(I)})}function _n(T,z){T.render(function(I){m.renderBufferImmediate(I,z)})}this.renderBufferImmediate=function(T,z){ht.initAttributes();const I=G.get(T);T.hasPositions&&!I.position&&(I.position=H.createBuffer()),T.hasNormals&&!I.normal&&(I.normal=H.createBuffer()),T.hasUvs&&!I.uv&&(I.uv=H.createBuffer()),T.hasColors&&!I.color&&(I.color=H.createBuffer());const V=z.getAttributes();T.hasPositions&&(H.bindBuffer(34962,I.position),H.bufferData(34962,T.positionArray,35048),ht.enableAttribute(V.position.location),H.vertexAttribPointer(V.position.location,3,5126,!1,0,0)),T.hasNormals&&(H.bindBuffer(34962,I.normal),H.bufferData(34962,T.normalArray,35048),ht.enableAttribute(V.normal.location),H.vertexAttribPointer(V.normal.location,3,5126,!1,0,0)),T.hasUvs&&(H.bindBuffer(34962,I.uv),H.bufferData(34962,T.uvArray,35048),ht.enableAttribute(V.uv.location),H.vertexAttribPointer(V.uv.location,2,5126,!1,0,0)),T.hasColors&&(H.bindBuffer(34962,I.color),H.bufferData(34962,T.colorArray,35048),ht.enableAttribute(V.color.location),H.vertexAttribPointer(V.color.location,3,5126,!1,0,0)),ht.disableUnusedAttributes(),H.drawArrays(4,0,T.count),T.count=0},this.renderBufferDirect=function(T,z,I,V,J,Rt){z===null&&(z=K);const wt=J.isMesh&&J.matrixWorld.determinant()<0,Mt=yu(T,z,V,J);pt.setMaterial(V,wt);let Ft=I.index;const Wt=I.attributes.position;if(Ft===null){if(Wt===void 0||Wt.count===0)return}else if(Ft.count===0)return;let Ot=1;V.wireframe===!0&&(Ft=L.getWireframeAttribute(I),Ot=2),(I.morphAttributes.position!==void 0||I.morphAttributes.normal!==void 0)&&xt.update(J,I,V,Mt),ht.setup(J,V,Mt,I,Ft);let Ut,Et=D;Ft!==null&&(Ut=rt.get(Ft),Et=ot,Et.setIndex(Ut));const xi=Ft!==null?Ft.count:Wt.count,ae=I.drawRange.start*Ot,Vn=I.drawRange.count*Ot,Je=Rt!==null?Rt.start*Ot:0,yi=Rt!==null?Rt.count*Ot:1/0,Wn=Math.max(ae,Je),pe=Math.min(xi,ae+Vn,Je+yi)-1,ln=Math.max(0,pe-Wn+1);if(ln!==0){if(J.isMesh)V.wireframe===!0?(pt.setLineWidth(V.wireframeLinewidth*lt()),Et.setMode(1)):Et.setMode(4);else if(J.isLine){let ve=V.linewidth;ve===void 0&&(ve=1),pt.setLineWidth(ve*lt()),J.isLineSegments?Et.setMode(1):J.isLineLoop?Et.setMode(2):Et.setMode(3)}else J.isPoints?Et.setMode(0):J.isSprite&&Et.setMode(4);if(J.isInstancedMesh)Et.renderInstances(Wn,ln,J.count);else if(I.isInstancedBufferGeometry){const ve=Math.min(I.instanceCount,I._maxInstanceCount);Et.renderInstances(Wn,ln,ve)}else Et.render(Wn,ln)}},this.compile=function(T,z){d=ct.get(T),d.init(),p.push(d),T.traverseVisible(function(I){I.isLight&&I.layers.test(z.layers)&&(d.pushLight(I),I.castShadow&&d.pushShadow(I))}),d.setupLights(m.physicallyCorrectLights),T.traverse(function(I){const V=I.material;if(V)if(Array.isArray(V))for(let J=0;J<V.length;J++){const Rt=V[J];_l(Rt,T,I)}else _l(V,T,I)}),p.pop(),d=null};let yl=null;function e0(T){yl&&yl(T)}function fu(){gi.stop()}function pu(){gi.start()}const gi=new Qm;gi.setAnimationLoop(e0),typeof window<"u"&&gi.setContext(window),this.setAnimationLoop=function(T){yl=T,Bt.setAnimationLoop(T),T===null?gi.stop():gi.start()},Bt.addEventListener("sessionstart",fu),Bt.addEventListener("sessionend",pu),this.render=function(T,z){if(z!==void 0&&z.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(y===!0)return;T.autoUpdate===!0&&T.updateMatrixWorld(),z.parent===null&&z.updateMatrixWorld(),Bt.enabled===!0&&Bt.isPresenting===!0&&(Bt.cameraAutoUpdate===!0&&Bt.updateCamera(z),z=Bt.getCamera()),T.isScene===!0&&T.onBeforeRender(m,T,z,v),d=ct.get(T,p.length),d.init(),p.push(d),_t.multiplyMatrices(z.projectionMatrix,z.matrixWorldInverse),Z.setFromProjectionMatrix(_t),dt=this.localClippingEnabled,tt=St.init(this.clippingPlanes,dt,z),u=st.get(T,f.length),u.init(),f.push(u),mu(T,z,0,m.sortObjects),u.finish(),m.sortObjects===!0&&u.sort(U,k),tt===!0&&St.beginShadows();const I=d.state.shadowsArray;if(yt.render(I,T,z),tt===!0&&St.endShadows(),this.info.autoReset===!0&&this.info.reset(),Lt.render(u,T),d.setupLights(m.physicallyCorrectLights),z.isArrayCamera){const V=z.cameras;for(let J=0,Rt=V.length;J<Rt;J++){const wt=V[J];gu(u,T,wt,wt.viewport)}}else gu(u,T,z);v!==null&&($.updateMultisampleRenderTarget(v),$.updateRenderTargetMipmap(v)),T.isScene===!0&&T.onAfterRender(m,T,z),pt.buffers.depth.setTest(!0),pt.buffers.depth.setMask(!0),pt.buffers.color.setMask(!0),pt.setPolygonOffset(!1),ht.resetDefaultState(),_=-1,M=null,p.pop(),p.length>0?d=p[p.length-1]:d=null,f.pop(),f.length>0?u=f[f.length-1]:u=null};function mu(T,z,I,V){if(T.visible===!1)return;if(T.layers.test(z.layers)){if(T.isGroup)I=T.renderOrder;else if(T.isLOD)T.autoUpdate===!0&&T.update(z);else if(T.isLight)d.pushLight(T),T.castShadow&&d.pushShadow(T);else if(T.isSprite){if(!T.frustumCulled||Z.intersectsSprite(T)){V&&X.setFromMatrixPosition(T.matrixWorld).applyMatrix4(_t);const wt=A.update(T),Mt=T.material;Mt.visible&&u.push(T,wt,Mt,I,X.z,null)}}else if(T.isImmediateRenderObject)V&&X.setFromMatrixPosition(T.matrixWorld).applyMatrix4(_t),u.push(T,null,T.material,I,X.z,null);else if((T.isMesh||T.isLine||T.isPoints)&&(T.isSkinnedMesh&&T.skeleton.frame!==Ct.render.frame&&(T.skeleton.update(),T.skeleton.frame=Ct.render.frame),!T.frustumCulled||Z.intersectsObject(T))){V&&X.setFromMatrixPosition(T.matrixWorld).applyMatrix4(_t);const wt=A.update(T),Mt=T.material;if(Array.isArray(Mt)){const Ft=wt.groups;for(let Wt=0,Ot=Ft.length;Wt<Ot;Wt++){const Ut=Ft[Wt],Et=Mt[Ut.materialIndex];Et&&Et.visible&&u.push(T,wt,Et,I,X.z,Ut)}}else Mt.visible&&u.push(T,wt,Mt,I,X.z,null)}}const Rt=T.children;for(let wt=0,Mt=Rt.length;wt<Mt;wt++)mu(Rt[wt],z,I,V)}function gu(T,z,I,V){const J=T.opaque,Rt=T.transmissive,wt=T.transparent;d.setupLightsView(I),Rt.length>0&&n0(J,z,I),V&&pt.viewport(w.copy(V)),J.length>0&&vo(J,z,I),Rt.length>0&&vo(Rt,z,I),wt.length>0&&vo(wt,z,I)}function n0(T,z,I){if(nt===null){const wt=o===!0&&ut.isWebGL2===!0?lh:nn;nt=new wt(1024,1024,{generateMipmaps:!0,type:q.convert(Bi)!==null?Bi:Gi,minFilter:Qi,magFilter:le,wrapS:we,wrapT:we})}const V=m.getRenderTarget();m.setRenderTarget(nt),m.clear();const J=m.toneMapping;m.toneMapping=ni,vo(T,z,I),m.toneMapping=J,$.updateMultisampleRenderTarget(nt),$.updateRenderTargetMipmap(nt),m.setRenderTarget(V)}function vo(T,z,I){const V=z.isScene===!0?z.overrideMaterial:null;for(let J=0,Rt=T.length;J<Rt;J++){const wt=T[J],Mt=wt.object,Ft=wt.geometry,Wt=V===null?wt.material:V,Ot=wt.group;Mt.layers.test(I.layers)&&i0(Mt,z,I,Ft,Wt,Ot)}}function i0(T,z,I,V,J,Rt){if(T.onBeforeRender(m,z,I,V,J,Rt),T.modelViewMatrix.multiplyMatrices(I.matrixWorldInverse,T.matrixWorld),T.normalMatrix.getNormalMatrix(T.modelViewMatrix),T.isImmediateRenderObject){const wt=yu(I,z,J,T);pt.setMaterial(J),ht.reset(),_n(T,wt)}else J.transparent===!0&&J.side===Wi?(J.side=se,J.needsUpdate=!0,m.renderBufferDirect(I,z,V,J,T,Rt),J.side=Vi,J.needsUpdate=!0,m.renderBufferDirect(I,z,V,J,T,Rt),J.side=Wi):m.renderBufferDirect(I,z,V,J,T,Rt);T.onAfterRender(m,z,I,V,J,Rt)}function _l(T,z,I){z.isScene!==!0&&(z=K);const V=G.get(T),J=d.state.lights,Rt=d.state.shadowsArray,wt=J.state.version,Mt=W.getParameters(T,J.state,Rt,z,I),Ft=W.getProgramCacheKey(Mt);let Wt=V.programs;V.environment=T.isMeshStandardMaterial?z.environment:null,V.fog=z.fog,V.envMap=(T.isMeshStandardMaterial?gt:Q).get(T.envMap||V.environment),Wt===void 0&&(T.addEventListener("dispose",Un),Wt=new Map,V.programs=Wt);let Ot=Wt.get(Ft);if(Ot!==void 0){if(V.currentProgram===Ot&&V.lightsStateVersion===wt)return xu(T,Mt),Ot}else Mt.uniforms=W.getUniforms(T),T.onBuild(Mt,m),T.onBeforeCompile(Mt,m),Ot=W.acquireProgram(Mt,Ft),Wt.set(Ft,Ot),V.uniforms=Mt.uniforms;const Ut=V.uniforms;(!T.isShaderMaterial&&!T.isRawShaderMaterial||T.clipping===!0)&&(Ut.clippingPlanes=St.uniform),xu(T,Mt),V.needsLights=r0(T),V.lightsStateVersion=wt,V.needsLights&&(Ut.ambientLightColor.value=J.state.ambient,Ut.lightProbe.value=J.state.probe,Ut.directionalLights.value=J.state.directional,Ut.directionalLightShadows.value=J.state.directionalShadow,Ut.spotLights.value=J.state.spot,Ut.spotLightShadows.value=J.state.spotShadow,Ut.rectAreaLights.value=J.state.rectArea,Ut.ltc_1.value=J.state.rectAreaLTC1,Ut.ltc_2.value=J.state.rectAreaLTC2,Ut.pointLights.value=J.state.point,Ut.pointLightShadows.value=J.state.pointShadow,Ut.hemisphereLights.value=J.state.hemi,Ut.directionalShadowMap.value=J.state.directionalShadowMap,Ut.directionalShadowMatrix.value=J.state.directionalShadowMatrix,Ut.spotShadowMap.value=J.state.spotShadowMap,Ut.spotShadowMatrix.value=J.state.spotShadowMatrix,Ut.pointShadowMap.value=J.state.pointShadowMap,Ut.pointShadowMatrix.value=J.state.pointShadowMatrix);const Et=Ot.getUniforms(),xi=si.seqWithValue(Et.seq,Ut);return V.currentProgram=Ot,V.uniformsList=xi,Ot}function xu(T,z){const I=G.get(T);I.outputEncoding=z.outputEncoding,I.instancing=z.instancing,I.skinning=z.skinning,I.morphTargets=z.morphTargets,I.morphNormals=z.morphNormals,I.numClippingPlanes=z.numClippingPlanes,I.numIntersection=z.numClipIntersection,I.vertexAlphas=z.vertexAlphas,I.vertexTangents=z.vertexTangents}function yu(T,z,I,V){z.isScene!==!0&&(z=K),$.resetTextureUnits();const J=z.fog,Rt=I.isMeshStandardMaterial?z.environment:null,wt=v===null?m.outputEncoding:v.texture.encoding,Mt=(I.isMeshStandardMaterial?gt:Q).get(I.envMap||Rt),Ft=I.vertexColors===!0&&!!V.geometry&&!!V.geometry.attributes.color&&V.geometry.attributes.color.itemSize===4,Wt=!!V.geometry&&!!V.geometry.attributes.tangent,Ot=!!V.geometry&&!!V.geometry.morphAttributes.position,Ut=!!V.geometry&&!!V.geometry.morphAttributes.normal,Et=G.get(I),xi=d.state.lights;if(tt===!0&&(dt===!0||T!==M)){const ve=T===M&&I.id===_;St.setState(I,T,ve)}let ae=!1;I.version===Et.__version?(Et.needsLights&&Et.lightsStateVersion!==xi.state.version||Et.outputEncoding!==wt||V.isInstancedMesh&&Et.instancing===!1||!V.isInstancedMesh&&Et.instancing===!0||V.isSkinnedMesh&&Et.skinning===!1||!V.isSkinnedMesh&&Et.skinning===!0||Et.envMap!==Mt||I.fog&&Et.fog!==J||Et.numClippingPlanes!==void 0&&(Et.numClippingPlanes!==St.numPlanes||Et.numIntersection!==St.numIntersection)||Et.vertexAlphas!==Ft||Et.vertexTangents!==Wt||Et.morphTargets!==Ot||Et.morphNormals!==Ut)&&(ae=!0):(ae=!0,Et.__version=I.version);let Vn=Et.currentProgram;ae===!0&&(Vn=_l(I,z,V));let Je=!1,yi=!1,Wn=!1;const pe=Vn.getUniforms(),ln=Et.uniforms;if(pt.useProgram(Vn.program)&&(Je=!0,yi=!0,Wn=!0),I.id!==_&&(_=I.id,yi=!0),Je||M!==T){if(pe.setValue(H,"projectionMatrix",T.projectionMatrix),ut.logarithmicDepthBuffer&&pe.setValue(H,"logDepthBufFC",2/(Math.log(T.far+1)/Math.LN2)),M!==T&&(M=T,yi=!0,Wn=!0),I.isShaderMaterial||I.isMeshPhongMaterial||I.isMeshToonMaterial||I.isMeshStandardMaterial||I.envMap){const ve=pe.map.cameraPosition;ve!==void 0&&ve.setValue(H,X.setFromMatrixPosition(T.matrixWorld))}(I.isMeshPhongMaterial||I.isMeshToonMaterial||I.isMeshLambertMaterial||I.isMeshBasicMaterial||I.isMeshStandardMaterial||I.isShaderMaterial)&&pe.setValue(H,"isOrthographic",T.isOrthographicCamera===!0),(I.isMeshPhongMaterial||I.isMeshToonMaterial||I.isMeshLambertMaterial||I.isMeshBasicMaterial||I.isMeshStandardMaterial||I.isShaderMaterial||I.isShadowMaterial||V.isSkinnedMesh)&&pe.setValue(H,"viewMatrix",T.matrixWorldInverse)}if(V.isSkinnedMesh){pe.setOptional(H,V,"bindMatrix"),pe.setOptional(H,V,"bindMatrixInverse");const ve=V.skeleton;ve&&(ut.floatVertexTextures?(ve.boneTexture===null&&ve.computeBoneTexture(),pe.setValue(H,"boneTexture",ve.boneTexture,$),pe.setValue(H,"boneTextureSize",ve.boneTextureSize)):pe.setOptional(H,ve,"boneMatrices"))}return(yi||Et.receiveShadow!==V.receiveShadow)&&(Et.receiveShadow=V.receiveShadow,pe.setValue(H,"receiveShadow",V.receiveShadow)),yi&&(pe.setValue(H,"toneMappingExposure",m.toneMappingExposure),Et.needsLights&&s0(ln,Wn),J&&I.fog&&Y.refreshFogUniforms(ln,J),Y.refreshMaterialUniforms(ln,I,C,R,nt),si.upload(H,Et.uniformsList,ln,$)),I.isShaderMaterial&&I.uniformsNeedUpdate===!0&&(si.upload(H,Et.uniformsList,ln,$),I.uniformsNeedUpdate=!1),I.isSpriteMaterial&&pe.setValue(H,"center",V.center),pe.setValue(H,"modelViewMatrix",V.modelViewMatrix),pe.setValue(H,"normalMatrix",V.normalMatrix),pe.setValue(H,"modelMatrix",V.matrixWorld),Vn}function s0(T,z){T.ambientLightColor.needsUpdate=z,T.lightProbe.needsUpdate=z,T.directionalLights.needsUpdate=z,T.directionalLightShadows.needsUpdate=z,T.pointLights.needsUpdate=z,T.pointLightShadows.needsUpdate=z,T.spotLights.needsUpdate=z,T.spotLightShadows.needsUpdate=z,T.rectAreaLights.needsUpdate=z,T.hemisphereLights.needsUpdate=z}function r0(T){return T.isMeshLambertMaterial||T.isMeshToonMaterial||T.isMeshPhongMaterial||T.isMeshStandardMaterial||T.isShadowMaterial||T.isShaderMaterial&&T.lights===!0}this.getActiveCubeFace=function(){return g},this.getActiveMipmapLevel=function(){return x},this.getRenderTarget=function(){return v},this.setRenderTarget=function(T,z=0,I=0){v=T,g=z,x=I,T&&G.get(T).__webglFramebuffer===void 0&&$.setupRenderTarget(T);let V=null,J=!1,Rt=!1;if(T){const Mt=T.texture;(Mt.isDataTexture3D||Mt.isDataTexture2DArray)&&(Rt=!0);const Ft=G.get(T).__webglFramebuffer;T.isWebGLCubeRenderTarget?(V=Ft[z],J=!0):T.isWebGLMultisampleRenderTarget?V=G.get(T).__webglMultisampledFramebuffer:V=Ft,w.copy(T.viewport),b.copy(T.scissor),E=T.scissorTest}else w.copy(B).multiplyScalar(C).floor(),b.copy(O).multiplyScalar(C).floor(),E=F;if(pt.bindFramebuffer(36160,V)&&ut.drawBuffers){let Mt=!1;if(T)if(T.isWebGLMultipleRenderTargets){const Ft=T.texture;if(N.length!==Ft.length||N[0]!==36064){for(let Wt=0,Ot=Ft.length;Wt<Ot;Wt++)N[Wt]=36064+Wt;N.length=Ft.length,Mt=!0}}else(N.length!==1||N[0]!==36064)&&(N[0]=36064,N.length=1,Mt=!0);else(N.length!==1||N[0]!==1029)&&(N[0]=1029,N.length=1,Mt=!0);Mt&&(ut.isWebGL2?H.drawBuffers(N):Tt.get("WEBGL_draw_buffers").drawBuffersWEBGL(N))}if(pt.viewport(w),pt.scissor(b),pt.setScissorTest(E),J){const Mt=G.get(T.texture);H.framebufferTexture2D(36160,36064,34069+z,Mt.__webglTexture,I)}else if(Rt){const Mt=G.get(T.texture),Ft=z||0;H.framebufferTextureLayer(36160,36064,Mt.__webglTexture,I||0,Ft)}_=-1},this.readRenderTargetPixels=function(T,z,I,V,J,Rt,wt){if(!(T&&T.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Mt=G.get(T).__webglFramebuffer;if(T.isWebGLCubeRenderTarget&&wt!==void 0&&(Mt=Mt[wt]),Mt){pt.bindFramebuffer(36160,Mt);try{const Ft=T.texture,Wt=Ft.format,Ot=Ft.type;if(Wt!==Fe&&q.convert(Wt)!==H.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const Ut=Ot===Bi&&(Tt.has("EXT_color_buffer_half_float")||ut.isWebGL2&&Tt.has("EXT_color_buffer_float"));if(Ot!==Gi&&q.convert(Ot)!==H.getParameter(35738)&&!(Ot===Cn&&(ut.isWebGL2||Tt.has("OES_texture_float")||Tt.has("WEBGL_color_buffer_float")))&&!Ut){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}H.checkFramebufferStatus(36160)===36053?z>=0&&z<=T.width-V&&I>=0&&I<=T.height-J&&H.readPixels(z,I,V,J,q.convert(Wt),q.convert(Ot),Rt):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const Ft=v!==null?G.get(v).__webglFramebuffer:null;pt.bindFramebuffer(36160,Ft)}}},this.copyFramebufferToTexture=function(T,z,I=0){const V=Math.pow(2,-I),J=Math.floor(z.image.width*V),Rt=Math.floor(z.image.height*V);let wt=q.convert(z.format);ut.isWebGL2&&(wt===6407&&(wt=32849),wt===6408&&(wt=32856)),$.setTexture2D(z,0),H.copyTexImage2D(3553,I,wt,T.x,T.y,J,Rt,0),pt.unbindTexture()},this.copyTextureToTexture=function(T,z,I,V=0){const J=z.image.width,Rt=z.image.height,wt=q.convert(I.format),Mt=q.convert(I.type);$.setTexture2D(I,0),H.pixelStorei(37440,I.flipY),H.pixelStorei(37441,I.premultiplyAlpha),H.pixelStorei(3317,I.unpackAlignment),z.isDataTexture?H.texSubImage2D(3553,V,T.x,T.y,J,Rt,wt,Mt,z.image.data):z.isCompressedTexture?H.compressedTexSubImage2D(3553,V,T.x,T.y,z.mipmaps[0].width,z.mipmaps[0].height,wt,z.mipmaps[0].data):H.texSubImage2D(3553,V,T.x,T.y,wt,Mt,z.image),V===0&&I.generateMipmaps&&H.generateMipmap(3553),pt.unbindTexture()},this.copyTextureToTexture3D=function(T,z,I,V,J=0){if(m.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const Rt=T.max.x-T.min.x+1,wt=T.max.y-T.min.y+1,Mt=T.max.z-T.min.z+1,Ft=q.convert(V.format),Wt=q.convert(V.type);let Ot;if(V.isDataTexture3D)$.setTexture3D(V,0),Ot=32879;else if(V.isDataTexture2DArray)$.setTexture2DArray(V,0),Ot=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}H.pixelStorei(37440,V.flipY),H.pixelStorei(37441,V.premultiplyAlpha),H.pixelStorei(3317,V.unpackAlignment);const Ut=H.getParameter(3314),Et=H.getParameter(32878),xi=H.getParameter(3316),ae=H.getParameter(3315),Vn=H.getParameter(32877),Je=I.isCompressedTexture?I.mipmaps[0]:I.image;H.pixelStorei(3314,Je.width),H.pixelStorei(32878,Je.height),H.pixelStorei(3316,T.min.x),H.pixelStorei(3315,T.min.y),H.pixelStorei(32877,T.min.z),I.isDataTexture||I.isDataTexture3D?H.texSubImage3D(Ot,J,z.x,z.y,z.z,Rt,wt,Mt,Ft,Wt,Je.data):I.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),H.compressedTexSubImage3D(Ot,J,z.x,z.y,z.z,Rt,wt,Mt,Ft,Je.data)):H.texSubImage3D(Ot,J,z.x,z.y,z.z,Rt,wt,Mt,Ft,Wt,Je),H.pixelStorei(3314,Ut),H.pixelStorei(32878,Et),H.pixelStorei(3316,xi),H.pixelStorei(3315,ae),H.pixelStorei(32877,Vn),J===0&&V.generateMipmaps&&H.generateMipmap(Ot),pt.unbindTexture()},this.initTexture=function(T){$.setTexture2D(T,0),pt.unbindTexture()},this.resetState=function(){g=0,x=0,v=null,pt.reset(),ht.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class dg extends qt{}dg.prototype.isWebGL1Renderer=!0;class fo{constructor(t,e=25e-5){this.name="",this.color=new it(t),this.density=e}clone(){return new fo(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}fo.prototype.isFogExp2=!0;class po{constructor(t,e=1,n=1e3){this.name="",this.color=new it(t),this.near=e,this.far=n}clone(){return new po(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}po.prototype.isFog=!0;class Za extends It{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return this.fog!==null&&(e.object.fog=this.fog.toJSON()),e}}Za.prototype.isScene=!0;class is{constructor(t,e){this.array=t,this.stride=e,this.count=t!==void 0?t.length/e:0,this.usage=Ns,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Ve()}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,n){t*=this.stride,n*=e.stride;for(let i=0,r=this.stride;i<r;i++)this.array[t+i]=e.array[n+i];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ve()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(e,this.stride);return n.setUsage(this.usage),n}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ve()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}is.prototype.isInterleavedBuffer=!0;const ne=new S;class ai{constructor(t,e,n,i=!1){this.name="",this.data=t,this.itemSize=e,this.offset=n,this.normalized=i===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,n=this.data.count;e<n;e++)ne.x=this.getX(e),ne.y=this.getY(e),ne.z=this.getZ(e),ne.applyMatrix4(t),this.setXYZ(e,ne.x,ne.y,ne.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)ne.x=this.getX(e),ne.y=this.getY(e),ne.z=this.getZ(e),ne.applyNormalMatrix(t),this.setXYZ(e,ne.x,ne.y,ne.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)ne.x=this.getX(e),ne.y=this.getY(e),ne.z=this.getZ(e),ne.transformDirection(t),this.setXYZ(e,ne.x,ne.y,ne.z);return this}setX(t,e){return this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){return this.data.array[t*this.data.stride+this.offset]}getY(t){return this.data.array[t*this.data.stride+this.offset+1]}getZ(t){return this.data.array[t*this.data.stride+this.offset+2]}getW(t){return this.data.array[t*this.data.stride+this.offset+3]}setXY(t,e,n){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this}setXYZ(t,e,n,i){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this}setXYZW(t,e,n,i,r){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this.data.array[t+3]=r,this}clone(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)e.push(this.data.array[i+r])}return new Nt(new this.array.constructor(e),this.itemSize,this.normalized)}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new ai(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)e.push(this.data.array[i+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}ai.prototype.isInterleavedBufferAttribute=!0;class $a extends ye{constructor(t){super(),this.type="SpriteMaterial",this.color=new it(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this}}$a.prototype.isSpriteMaterial=!0;let Ts;const mr=new S,Es=new S,As=new S,Ls=new j,gr=new j,fg=new ft,Uo=new S,xr=new S,Vo=new S,Ku=new j,Yl=new j,Qu=new j;class Ka extends It{constructor(t){if(super(),this.type="Sprite",Ts===void 0){Ts=new bt;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),n=new is(e,5);Ts.setIndex([0,1,2,0,2,3]),Ts.setAttribute("position",new ai(n,3,0,!1)),Ts.setAttribute("uv",new ai(n,2,3,!1))}this.geometry=Ts,this.material=t!==void 0?t:new $a,this.center=new j(.5,.5)}raycast(t,e){t.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Es.setFromMatrixScale(this.matrixWorld),fg.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),As.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Es.multiplyScalar(-As.z);const n=this.material.rotation;let i,r;n!==0&&(r=Math.cos(n),i=Math.sin(n));const o=this.center;Wo(Uo.set(-.5,-.5,0),As,o,Es,i,r),Wo(xr.set(.5,-.5,0),As,o,Es,i,r),Wo(Vo.set(.5,.5,0),As,o,Es,i,r),Ku.set(0,0),Yl.set(1,0),Qu.set(1,1);let a=t.ray.intersectTriangle(Uo,xr,Vo,!1,mr);if(a===null&&(Wo(xr.set(-.5,.5,0),As,o,Es,i,r),Yl.set(0,1),a=t.ray.intersectTriangle(Uo,Vo,xr,!1,mr),a===null))return;const l=t.ray.origin.distanceTo(mr);l<t.near||l>t.far||e.push({distance:l,point:mr.clone(),uv:re.getUV(mr,Uo,xr,Vo,Ku,Yl,Qu,new j),face:null,object:this})}copy(t){return super.copy(t),t.center!==void 0&&this.center.copy(t.center),this.material=t.material,this}}Ka.prototype.isSprite=!0;function Wo(s,t,e,n,i,r){Ls.subVectors(s,e).addScalar(.5).multiply(n),i!==void 0?(gr.x=r*Ls.x-i*Ls.y,gr.y=i*Ls.x+r*Ls.y):gr.copy(Ls),s.copy(t),s.x+=gr.x,s.y+=gr.y,s.applyMatrix4(fg)}const Go=new S,td=new S;class pg extends It{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(t){super.copy(t,!1);const e=t.levels;for(let n=0,i=e.length;n<i;n++){const r=e[n];this.addLevel(r.object.clone(),r.distance)}return this.autoUpdate=t.autoUpdate,this}addLevel(t,e=0){e=Math.abs(e);const n=this.levels;let i;for(i=0;i<n.length&&!(e<n[i].distance);i++);return n.splice(i,0,{distance:e,object:t}),this.add(t),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(t){const e=this.levels;if(e.length>0){let n,i;for(n=1,i=e.length;n<i&&!(t<e[n].distance);n++);return e[n-1].object}return null}raycast(t,e){if(this.levels.length>0){Go.setFromMatrixPosition(this.matrixWorld);const i=t.ray.origin.distanceTo(Go);this.getObjectForDistance(i).raycast(t,e)}}update(t){const e=this.levels;if(e.length>1){Go.setFromMatrixPosition(t.matrixWorld),td.setFromMatrixPosition(this.matrixWorld);const n=Go.distanceTo(td)/t.zoom;e[0].object.visible=!0;let i,r;for(i=1,r=e.length;i<r&&n>=e[i].distance;i++)e[i-1].object.visible=!1,e[i].object.visible=!0;for(this._currentLevel=i-1;i<r;i++)e[i].object.visible=!1}}toJSON(t){const e=super.toJSON(t);this.autoUpdate===!1&&(e.object.autoUpdate=!1),e.object.levels=[];const n=this.levels;for(let i=0,r=n.length;i<r;i++){const o=n[i];e.object.levels.push({object:o.object.uuid,distance:o.distance})}return e}}const ed=new S,nd=new Xt,id=new Xt,LM=new S,sd=new ft;class Qa extends ce{constructor(t,e){super(t,e),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new ft,this.bindMatrixInverse=new ft}copy(t){return super.copy(t),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this}bind(t,e){this.skeleton=t,e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new Xt,e=this.geometry.attributes.skinWeight;for(let n=0,i=e.count;n<i;n++){t.x=e.getX(n),t.y=e.getY(n),t.z=e.getZ(n),t.w=e.getW(n);const r=1/t.manhattanLength();r!==1/0?t.multiplyScalar(r):t.set(1,0,0,0),e.setXYZW(n,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(t,e){const n=this.skeleton,i=this.geometry;nd.fromBufferAttribute(i.attributes.skinIndex,t),id.fromBufferAttribute(i.attributes.skinWeight,t),ed.fromBufferAttribute(i.attributes.position,t).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let r=0;r<4;r++){const o=id.getComponent(r);if(o!==0){const a=nd.getComponent(r);sd.multiplyMatrices(n.bones[a].matrixWorld,n.boneInverses[a]),e.addScaledVector(LM.copy(ed).applyMatrix4(sd),o)}}return e.applyMatrix4(this.bindMatrixInverse)}}Qa.prototype.isSkinnedMesh=!0;class tl extends It{constructor(){super(),this.type="Bone"}}tl.prototype.isBone=!0;class Ni extends fe{constructor(t=null,e=1,n=1,i,r,o,a,l,c=le,h=le,u,d){super(null,o,a,l,c,h,i,r,u,d),this.image={data:t,width:e,height:n},this.magFilter=c,this.minFilter=h,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Ni.prototype.isDataTexture=!0;const rd=new ft,CM=new ft;class el{constructor(t=[],e=[]){this.uuid=Ve(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(t.length*16),e.length===0)this.calculateInverses();else if(t.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let n=0,i=this.bones.length;n<i;n++)this.boneInverses.push(new ft)}}calculateInverses(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const n=new ft;this.bones[t]&&n.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(n)}}pose(){for(let t=0,e=this.bones.length;t<e;t++){const n=this.bones[t];n&&n.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const n=this.bones[t];n&&(n.parent&&n.parent.isBone?(n.matrix.copy(n.parent.matrixWorld).invert(),n.matrix.multiply(n.matrixWorld)):n.matrix.copy(n.matrixWorld),n.matrix.decompose(n.position,n.quaternion,n.scale))}}update(){const t=this.bones,e=this.boneInverses,n=this.boneMatrices,i=this.boneTexture;for(let r=0,o=t.length;r<o;r++){const a=t[r]?t[r].matrixWorld:CM;rd.multiplyMatrices(a,e[r]),rd.toArray(n,r*16)}i!==null&&(i.needsUpdate=!0)}clone(){return new el(this.bones,this.boneInverses)}computeBoneTexture(){let t=Math.sqrt(this.bones.length*4);t=Hm(t),t=Math.max(t,4);const e=new Float32Array(t*t*4);e.set(this.boneMatrices);const n=new Ni(e,t,t,Fe,Cn);return this.boneMatrices=e,this.boneTexture=n,this.boneTextureSize=t,this}getBoneByName(t){for(let e=0,n=this.bones.length;e<n;e++){const i=this.bones[e];if(i.name===t)return i}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(t,e){this.uuid=t.uuid;for(let n=0,i=t.bones.length;n<i;n++){const r=t.bones[n];let o=e[r];o===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),o=new tl),this.bones.push(o),this.boneInverses.push(new ft().fromArray(t.boneInverses[n]))}return this.init(),this}toJSON(){const t={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const e=this.bones,n=this.boneInverses;for(let i=0,r=e.length;i<r;i++){const o=e[i];t.bones.push(o.uuid);const a=n[i];t.boneInverses.push(a.toArray())}return t}}class qi extends Nt{constructor(t,e,n,i=1){typeof n=="number"&&(i=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(t,e,n),this.meshPerAttribute=i}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}qi.prototype.isInstancedBufferAttribute=!0;const od=new ft,ad=new ft,Xo=[],yr=new ce;class mh extends ce{constructor(t,e,n){super(t,e),this.instanceMatrix=new qi(new Float32Array(n*16),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}copy(t){return super.copy(t),this.instanceMatrix.copy(t.instanceMatrix),t.instanceColor!==null&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this}getColorAt(t,e){e.fromArray(this.instanceColor.array,t*3)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,t*16)}raycast(t,e){const n=this.matrixWorld,i=this.count;if(yr.geometry=this.geometry,yr.material=this.material,yr.material!==void 0)for(let r=0;r<i;r++){this.getMatrixAt(r,od),ad.multiplyMatrices(n,od),yr.matrixWorld=ad,yr.raycast(t,Xo);for(let o=0,a=Xo.length;o<a;o++){const l=Xo[o];l.instanceId=r,l.object=this,e.push(l)}Xo.length=0}}setColorAt(t,e){this.instanceColor===null&&(this.instanceColor=new qi(new Float32Array(this.instanceMatrix.count*3),3)),e.toArray(this.instanceColor.array,t*3)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,t*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}mh.prototype.isInstancedMesh=!0;class _e extends ye{constructor(t){super(),this.type="LineBasicMaterial",this.color=new it(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this}}_e.prototype.isLineBasicMaterial=!0;const ld=new S,cd=new S,hd=new ft,jl=new pi,qo=new fi;let On=class extends It{constructor(t=new bt,e=new _e){super(),this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(t.index===null){const e=t.attributes.position,n=[0];for(let i=1,r=e.count;i<r;i++)ld.fromBufferAttribute(e,i-1),cd.fromBufferAttribute(e,i),n[i]=n[i-1],n[i]+=ld.distanceTo(cd);t.setAttribute("lineDistance",new at(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,r=t.params.Line.threshold,o=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),qo.copy(n.boundingSphere),qo.applyMatrix4(i),qo.radius+=r,t.ray.intersectsSphere(qo)===!1)return;hd.copy(i).invert(),jl.copy(t.ray).applyMatrix4(hd);const a=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,c=new S,h=new S,u=new S,d=new S,f=this.isLineSegments?2:1;if(n.isBufferGeometry){const p=n.index,y=n.attributes.position;if(p!==null){const g=Math.max(0,o.start),x=Math.min(p.count,o.start+o.count);for(let v=g,_=x-1;v<_;v+=f){const M=p.getX(v),w=p.getX(v+1);if(c.fromBufferAttribute(y,M),h.fromBufferAttribute(y,w),jl.distanceSqToSegment(c,h,d,u)>l)continue;d.applyMatrix4(this.matrixWorld);const E=t.ray.origin.distanceTo(d);E<t.near||E>t.far||e.push({distance:E,point:u.clone().applyMatrix4(this.matrixWorld),index:v,face:null,faceIndex:null,object:this})}}else{const g=Math.max(0,o.start),x=Math.min(y.count,o.start+o.count);for(let v=g,_=x-1;v<_;v+=f){if(c.fromBufferAttribute(y,v),h.fromBufferAttribute(y,v+1),jl.distanceSqToSegment(c,h,d,u)>l)continue;d.applyMatrix4(this.matrixWorld);const w=t.ray.origin.distanceTo(d);w<t.near||w>t.far||e.push({distance:w,point:u.clone().applyMatrix4(this.matrixWorld),index:v,face:null,faceIndex:null,object:this})}}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=i.length;r<o;r++){const a=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}};On.prototype.isLine=!0;const ud=new S,dd=new S;class Ne extends On{constructor(t,e){super(t,e),this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(t.index===null){const e=t.attributes.position,n=[];for(let i=0,r=e.count;i<r;i+=2)ud.fromBufferAttribute(e,i),dd.fromBufferAttribute(e,i+1),n[i]=i===0?0:n[i-1],n[i+1]=n[i]+ud.distanceTo(dd);t.setAttribute("lineDistance",new at(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}Ne.prototype.isLineSegments=!0;class gh extends On{constructor(t,e){super(t,e),this.type="LineLoop"}}gh.prototype.isLineLoop=!0;class ss extends ye{constructor(t){super(),this.type="PointsMaterial",this.color=new it(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this}}ss.prototype.isPointsMaterial=!0;const fd=new ft,Bc=new pi,Yo=new fi,jo=new S;class mo extends It{constructor(t=new bt,e=new ss){super(),this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,r=t.params.Points.threshold,o=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Yo.copy(n.boundingSphere),Yo.applyMatrix4(i),Yo.radius+=r,t.ray.intersectsSphere(Yo)===!1)return;fd.copy(i).invert(),Bc.copy(t.ray).applyMatrix4(fd);const a=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a;if(n.isBufferGeometry){const c=n.index,u=n.attributes.position;if(c!==null){const d=Math.max(0,o.start),f=Math.min(c.count,o.start+o.count);for(let p=d,m=f;p<m;p++){const y=c.getX(p);jo.fromBufferAttribute(u,y),pd(jo,y,l,i,t,e,this)}}else{const d=Math.max(0,o.start),f=Math.min(u.count,o.start+o.count);for(let p=d,m=f;p<m;p++)jo.fromBufferAttribute(u,p),pd(jo,p,l,i,t,e,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=i.length;r<o;r++){const a=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}mo.prototype.isPoints=!0;function pd(s,t,e,n,i,r,o){const a=Bc.distanceSqToPoint(s);if(a<e){const l=new S;Bc.closestPointToPoint(s,l),l.applyMatrix4(n);const c=i.ray.origin.distanceTo(l);if(c<i.near||c>i.far)return;r.push({distance:c,distanceToRay:Math.sqrt(a),point:l,index:t,face:null,object:o})}}class mg extends fe{constructor(t,e,n,i,r,o,a,l,c){super(t,e,n,i,r,o,a,l,c),this.format=a!==void 0?a:Fn,this.minFilter=o!==void 0?o:he,this.magFilter=r!==void 0?r:he,this.generateMipmaps=!1;const h=this;function u(){h.needsUpdate=!0,t.requestVideoFrameCallback(u)}"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback(u)}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;"requestVideoFrameCallback"in t===!1&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}mg.prototype.isVideoTexture=!0;class xh extends fe{constructor(t,e,n,i,r,o,a,l,c,h,u,d){super(null,o,a,l,c,h,i,r,u,d),this.image={width:e,height:n},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}xh.prototype.isCompressedTexture=!0;class gg extends fe{constructor(t,e,n,i,r,o,a,l,c){super(t,e,n,i,r,o,a,l,c),this.needsUpdate=!0}}gg.prototype.isCanvasTexture=!0;class xg extends fe{constructor(t,e,n,i,r,o,a,l,c,h){if(h=h!==void 0?h:Oi,h!==Oi&&h!==zs)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&h===Oi&&(n=Ur),n===void 0&&h===zs&&(n=ks),super(null,i,r,o,a,l,h,n,c),this.image={width:t,height:e},this.magFilter=a!==void 0?a:le,this.minFilter=l!==void 0?l:le,this.flipY=!1,this.generateMipmaps=!1}}xg.prototype.isDepthTexture=!0;class Vs extends bt{constructor(t=1,e=8,n=0,i=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:t,segments:e,thetaStart:n,thetaLength:i},e=Math.max(3,e);const r=[],o=[],a=[],l=[],c=new S,h=new j;o.push(0,0,0),a.push(0,0,1),l.push(.5,.5);for(let u=0,d=3;u<=e;u++,d+=3){const f=n+u/e*i;c.x=t*Math.cos(f),c.y=t*Math.sin(f),o.push(c.x,c.y,c.z),a.push(0,0,1),h.x=(o[d]/t+1)/2,h.y=(o[d+1]/t+1)/2,l.push(h.x,h.y)}for(let u=1;u<=e;u++)r.push(u,u+1,0);this.setIndex(r),this.setAttribute("position",new at(o,3)),this.setAttribute("normal",new at(a,3)),this.setAttribute("uv",new at(l,2))}static fromJSON(t){return new Vs(t.radius,t.segments,t.thetaStart,t.thetaLength)}}class li extends bt{constructor(t=1,e=1,n=1,i=8,r=1,o=!1,a=0,l=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:n,radialSegments:i,heightSegments:r,openEnded:o,thetaStart:a,thetaLength:l};const c=this;i=Math.floor(i),r=Math.floor(r);const h=[],u=[],d=[],f=[];let p=0;const m=[],y=n/2;let g=0;x(),o===!1&&(t>0&&v(!0),e>0&&v(!1)),this.setIndex(h),this.setAttribute("position",new at(u,3)),this.setAttribute("normal",new at(d,3)),this.setAttribute("uv",new at(f,2));function x(){const _=new S,M=new S;let w=0;const b=(e-t)/n;for(let E=0;E<=r;E++){const P=[],R=E/r,C=R*(e-t)+t;for(let U=0;U<=i;U++){const k=U/i,B=k*l+a,O=Math.sin(B),F=Math.cos(B);M.x=C*O,M.y=-R*n+y,M.z=C*F,u.push(M.x,M.y,M.z),_.set(O,b,F).normalize(),d.push(_.x,_.y,_.z),f.push(k,1-R),P.push(p++)}m.push(P)}for(let E=0;E<i;E++)for(let P=0;P<r;P++){const R=m[P][E],C=m[P+1][E],U=m[P+1][E+1],k=m[P][E+1];h.push(R,C,k),h.push(C,U,k),w+=6}c.addGroup(g,w,0),g+=w}function v(_){const M=p,w=new j,b=new S;let E=0;const P=_===!0?t:e,R=_===!0?1:-1;for(let U=1;U<=i;U++)u.push(0,y*R,0),d.push(0,R,0),f.push(.5,.5),p++;const C=p;for(let U=0;U<=i;U++){const B=U/i*l+a,O=Math.cos(B),F=Math.sin(B);b.x=P*F,b.y=y*R,b.z=P*O,u.push(b.x,b.y,b.z),d.push(0,R,0),w.x=O*.5+.5,w.y=F*.5*R+.5,f.push(w.x,w.y),p++}for(let U=0;U<i;U++){const k=M+U,B=C+U;_===!0?h.push(B,B+1,k):h.push(B+1,B,k),E+=3}c.addGroup(g,E,_===!0?1:2),g+=E}}static fromJSON(t){return new li(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class Ws extends li{constructor(t=1,e=1,n=8,i=1,r=!1,o=0,a=Math.PI*2){super(0,t,e,n,i,r,o,a),this.type="ConeGeometry",this.parameters={radius:t,height:e,radialSegments:n,heightSegments:i,openEnded:r,thetaStart:o,thetaLength:a}}static fromJSON(t){return new Ws(t.radius,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class xn extends bt{constructor(t,e,n=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:e,radius:n,detail:i};const r=[],o=[];a(i),c(n),h(),this.setAttribute("position",new at(r,3)),this.setAttribute("normal",new at(r.slice(),3)),this.setAttribute("uv",new at(o,2)),i===0?this.computeVertexNormals():this.normalizeNormals();function a(x){const v=new S,_=new S,M=new S;for(let w=0;w<e.length;w+=3)f(e[w+0],v),f(e[w+1],_),f(e[w+2],M),l(v,_,M,x)}function l(x,v,_,M){const w=M+1,b=[];for(let E=0;E<=w;E++){b[E]=[];const P=x.clone().lerp(_,E/w),R=v.clone().lerp(_,E/w),C=w-E;for(let U=0;U<=C;U++)U===0&&E===w?b[E][U]=P:b[E][U]=P.clone().lerp(R,U/C)}for(let E=0;E<w;E++)for(let P=0;P<2*(w-E)-1;P++){const R=Math.floor(P/2);P%2===0?(d(b[E][R+1]),d(b[E+1][R]),d(b[E][R])):(d(b[E][R+1]),d(b[E+1][R+1]),d(b[E+1][R]))}}function c(x){const v=new S;for(let _=0;_<r.length;_+=3)v.x=r[_+0],v.y=r[_+1],v.z=r[_+2],v.normalize().multiplyScalar(x),r[_+0]=v.x,r[_+1]=v.y,r[_+2]=v.z}function h(){const x=new S;for(let v=0;v<r.length;v+=3){x.x=r[v+0],x.y=r[v+1],x.z=r[v+2];const _=y(x)/2/Math.PI+.5,M=g(x)/Math.PI+.5;o.push(_,1-M)}p(),u()}function u(){for(let x=0;x<o.length;x+=6){const v=o[x+0],_=o[x+2],M=o[x+4],w=Math.max(v,_,M),b=Math.min(v,_,M);w>.9&&b<.1&&(v<.2&&(o[x+0]+=1),_<.2&&(o[x+2]+=1),M<.2&&(o[x+4]+=1))}}function d(x){r.push(x.x,x.y,x.z)}function f(x,v){const _=x*3;v.x=t[_+0],v.y=t[_+1],v.z=t[_+2]}function p(){const x=new S,v=new S,_=new S,M=new S,w=new j,b=new j,E=new j;for(let P=0,R=0;P<r.length;P+=9,R+=6){x.set(r[P+0],r[P+1],r[P+2]),v.set(r[P+3],r[P+4],r[P+5]),_.set(r[P+6],r[P+7],r[P+8]),w.set(o[R+0],o[R+1]),b.set(o[R+2],o[R+3]),E.set(o[R+4],o[R+5]),M.copy(x).add(v).add(_).divideScalar(3);const C=y(M);m(w,R+0,x,C),m(b,R+2,v,C),m(E,R+4,_,C)}}function m(x,v,_,M){M<0&&x.x===1&&(o[v]=x.x-1),_.x===0&&_.z===0&&(o[v]=M/2/Math.PI+.5)}function y(x){return Math.atan2(x.z,-x.x)}function g(x){return Math.atan2(-x.y,Math.sqrt(x.x*x.x+x.z*x.z))}}static fromJSON(t){return new xn(t.vertices,t.indices,t.radius,t.details)}}class Gs extends xn{constructor(t=1,e=0){const n=(1+Math.sqrt(5))/2,i=1/n,r=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-n,0,-i,n,0,i,-n,0,i,n,-i,-n,0,-i,n,0,i,-n,0,i,n,0,-n,0,-i,n,0,-i,-n,0,i,n,0,i],o=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(r,o,t,e),this.type="DodecahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Gs(t.radius,t.detail)}}const Jo=new S,Zo=new S,Jl=new S,$o=new re;class yh extends bt{constructor(t,e){if(super(),this.type="EdgesGeometry",this.parameters={thresholdAngle:e},e=e!==void 0?e:1,t.isGeometry===!0){console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return}const i=Math.pow(10,4),r=Math.cos(zi*e),o=t.getIndex(),a=t.getAttribute("position"),l=o?o.count:a.count,c=[0,0,0],h=["a","b","c"],u=new Array(3),d={},f=[];for(let p=0;p<l;p+=3){o?(c[0]=o.getX(p),c[1]=o.getX(p+1),c[2]=o.getX(p+2)):(c[0]=p,c[1]=p+1,c[2]=p+2);const{a:m,b:y,c:g}=$o;if(m.fromBufferAttribute(a,c[0]),y.fromBufferAttribute(a,c[1]),g.fromBufferAttribute(a,c[2]),$o.getNormal(Jl),u[0]=`${Math.round(m.x*i)},${Math.round(m.y*i)},${Math.round(m.z*i)}`,u[1]=`${Math.round(y.x*i)},${Math.round(y.y*i)},${Math.round(y.z*i)}`,u[2]=`${Math.round(g.x*i)},${Math.round(g.y*i)},${Math.round(g.z*i)}`,!(u[0]===u[1]||u[1]===u[2]||u[2]===u[0]))for(let x=0;x<3;x++){const v=(x+1)%3,_=u[x],M=u[v],w=$o[h[x]],b=$o[h[v]],E=`${_}_${M}`,P=`${M}_${_}`;P in d&&d[P]?(Jl.dot(d[P].normal)<=r&&(f.push(w.x,w.y,w.z),f.push(b.x,b.y,b.z)),d[P]=null):E in d||(d[E]={index0:c[x],index1:c[v],normal:Jl.clone()})}}for(const p in d)if(d[p]){const{index0:m,index1:y}=d[p];Jo.fromBufferAttribute(a,m),Zo.fromBufferAttribute(a,y),f.push(Jo.x,Jo.y,Jo.z),f.push(Zo.x,Zo.y,Zo.z)}this.setAttribute("position",new at(f,3))}}class We{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(t,e){const n=this.getUtoTmapping(t);return this.getPoint(n,e)}getPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return e}getSpacedPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPointAt(n/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let n,i=this.getPoint(0),r=0;e.push(0);for(let o=1;o<=t;o++)n=this.getPoint(o/t),r+=n.distanceTo(i),e.push(r),i=n;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const n=this.getLengths();let i=0;const r=n.length;let o;e?o=e:o=t*n[r-1];let a=0,l=r-1,c;for(;a<=l;)if(i=Math.floor(a+(l-a)/2),c=n[i]-o,c<0)a=i+1;else if(c>0)l=i-1;else{l=i;break}if(i=l,n[i]===o)return i/(r-1);const h=n[i],d=n[i+1]-h,f=(o-h)/d;return(i+f)/(r-1)}getTangent(t,e){let i=t-1e-4,r=t+1e-4;i<0&&(i=0),r>1&&(r=1);const o=this.getPoint(i),a=this.getPoint(r),l=e||(o.isVector2?new j:new S);return l.copy(a).sub(o).normalize(),l}getTangentAt(t,e){const n=this.getUtoTmapping(t);return this.getTangent(n,e)}computeFrenetFrames(t,e){const n=new S,i=[],r=[],o=[],a=new S,l=new ft;for(let f=0;f<=t;f++){const p=f/t;i[f]=this.getTangentAt(p,new S),i[f].normalize()}r[0]=new S,o[0]=new S;let c=Number.MAX_VALUE;const h=Math.abs(i[0].x),u=Math.abs(i[0].y),d=Math.abs(i[0].z);h<=c&&(c=h,n.set(1,0,0)),u<=c&&(c=u,n.set(0,1,0)),d<=c&&n.set(0,0,1),a.crossVectors(i[0],n).normalize(),r[0].crossVectors(i[0],a),o[0].crossVectors(i[0],r[0]);for(let f=1;f<=t;f++){if(r[f]=r[f-1].clone(),o[f]=o[f-1].clone(),a.crossVectors(i[f-1],i[f]),a.length()>Number.EPSILON){a.normalize();const p=Math.acos(Me(i[f-1].dot(i[f]),-1,1));r[f].applyMatrix4(l.makeRotationAxis(a,p))}o[f].crossVectors(i[f],r[f])}if(e===!0){let f=Math.acos(Me(r[0].dot(r[t]),-1,1));f/=t,i[0].dot(a.crossVectors(r[0],r[t]))>0&&(f=-f);for(let p=1;p<=t;p++)r[p].applyMatrix4(l.makeRotationAxis(i[p],f*p)),o[p].crossVectors(i[p],r[p])}return{tangents:i,normals:r,binormals:o}}clone(){return new this.constructor().copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class go extends We{constructor(t=0,e=0,n=1,i=1,r=0,o=Math.PI*2,a=!1,l=0){super(),this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=n,this.yRadius=i,this.aStartAngle=r,this.aEndAngle=o,this.aClockwise=a,this.aRotation=l}getPoint(t,e){const n=e||new j,i=Math.PI*2;let r=this.aEndAngle-this.aStartAngle;const o=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=i;for(;r>i;)r-=i;r<Number.EPSILON&&(o?r=0:r=i),this.aClockwise===!0&&!o&&(r===i?r=-i:r=r-i);const a=this.aStartAngle+t*r;let l=this.aX+this.xRadius*Math.cos(a),c=this.aY+this.yRadius*Math.sin(a);if(this.aRotation!==0){const h=Math.cos(this.aRotation),u=Math.sin(this.aRotation),d=l-this.aX,f=c-this.aY;l=d*h-f*u+this.aX,c=d*u+f*h+this.aY}return n.set(l,c)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}go.prototype.isEllipseCurve=!0;class _h extends go{constructor(t,e,n,i,r,o){super(t,e,n,n,i,r,o),this.type="ArcCurve"}}_h.prototype.isArcCurve=!0;function vh(){let s=0,t=0,e=0,n=0;function i(r,o,a,l){s=r,t=a,e=-3*r+3*o-2*a-l,n=2*r-2*o+a+l}return{initCatmullRom:function(r,o,a,l,c){i(o,a,c*(a-r),c*(l-o))},initNonuniformCatmullRom:function(r,o,a,l,c,h,u){let d=(o-r)/c-(a-r)/(c+h)+(a-o)/h,f=(a-o)/h-(l-o)/(h+u)+(l-a)/u;d*=h,f*=h,i(o,a,d,f)},calc:function(r){const o=r*r,a=o*r;return s+t*r+e*o+n*a}}}const Ko=new S,Zl=new vh,$l=new vh,Kl=new vh;class bh extends We{constructor(t=[],e=!1,n="centripetal",i=.5){super(),this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=n,this.tension=i}getPoint(t,e=new S){const n=e,i=this.points,r=i.length,o=(r-(this.closed?0:1))*t;let a=Math.floor(o),l=o-a;this.closed?a+=a>0?0:(Math.floor(Math.abs(a)/r)+1)*r:l===0&&a===r-1&&(a=r-2,l=1);let c,h;this.closed||a>0?c=i[(a-1)%r]:(Ko.subVectors(i[0],i[1]).add(i[0]),c=Ko);const u=i[a%r],d=i[(a+1)%r];if(this.closed||a+2<r?h=i[(a+2)%r]:(Ko.subVectors(i[r-1],i[r-2]).add(i[r-1]),h=Ko),this.curveType==="centripetal"||this.curveType==="chordal"){const f=this.curveType==="chordal"?.5:.25;let p=Math.pow(c.distanceToSquared(u),f),m=Math.pow(u.distanceToSquared(d),f),y=Math.pow(d.distanceToSquared(h),f);m<1e-4&&(m=1),p<1e-4&&(p=m),y<1e-4&&(y=m),Zl.initNonuniformCatmullRom(c.x,u.x,d.x,h.x,p,m,y),$l.initNonuniformCatmullRom(c.y,u.y,d.y,h.y,p,m,y),Kl.initNonuniformCatmullRom(c.z,u.z,d.z,h.z,p,m,y)}else this.curveType==="catmullrom"&&(Zl.initCatmullRom(c.x,u.x,d.x,h.x,this.tension),$l.initCatmullRom(c.y,u.y,d.y,h.y,this.tension),Kl.initCatmullRom(c.z,u.z,d.z,h.z,this.tension));return n.set(Zl.calc(l),$l.calc(l),Kl.calc(l)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const i=t.points[e];this.points.push(i.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const i=this.points[e];t.points.push(i.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const i=t.points[e];this.points.push(new S().fromArray(i))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}bh.prototype.isCatmullRomCurve3=!0;function md(s,t,e,n,i){const r=(n-t)*.5,o=(i-e)*.5,a=s*s,l=s*a;return(2*e-2*n+r+o)*l+(-3*e+3*n-2*r-o)*a+r*s+e}function RM(s,t){const e=1-s;return e*e*t}function PM(s,t){return 2*(1-s)*s*t}function DM(s,t){return s*s*t}function Pr(s,t,e,n){return RM(s,t)+PM(s,e)+DM(s,n)}function IM(s,t){const e=1-s;return e*e*e*t}function FM(s,t){const e=1-s;return 3*e*e*s*t}function kM(s,t){return 3*(1-s)*s*s*t}function BM(s,t){return s*s*s*t}function Dr(s,t,e,n,i){return IM(s,t)+FM(s,e)+kM(s,n)+BM(s,i)}class nl extends We{constructor(t=new j,e=new j,n=new j,i=new j){super(),this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=n,this.v3=i}getPoint(t,e=new j){const n=e,i=this.v0,r=this.v1,o=this.v2,a=this.v3;return n.set(Dr(t,i.x,r.x,o.x,a.x),Dr(t,i.y,r.y,o.y,a.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}nl.prototype.isCubicBezierCurve=!0;class Mh extends We{constructor(t=new S,e=new S,n=new S,i=new S){super(),this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=n,this.v3=i}getPoint(t,e=new S){const n=e,i=this.v0,r=this.v1,o=this.v2,a=this.v3;return n.set(Dr(t,i.x,r.x,o.x,a.x),Dr(t,i.y,r.y,o.y,a.y),Dr(t,i.z,r.z,o.z,a.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}Mh.prototype.isCubicBezierCurve3=!0;class xo extends We{constructor(t=new j,e=new j){super(),this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new j){const n=e;return t===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e){const n=e||new j;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}xo.prototype.isLineCurve=!0;class yg extends We{constructor(t=new S,e=new S){super(),this.type="LineCurve3",this.isLineCurve3=!0,this.v1=t,this.v2=e}getPoint(t,e=new S){const n=e;return t===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class il extends We{constructor(t=new j,e=new j,n=new j){super(),this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new j){const n=e,i=this.v0,r=this.v1,o=this.v2;return n.set(Pr(t,i.x,r.x,o.x),Pr(t,i.y,r.y,o.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}il.prototype.isQuadraticBezierCurve=!0;class wh extends We{constructor(t=new S,e=new S,n=new S){super(),this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new S){const n=e,i=this.v0,r=this.v1,o=this.v2;return n.set(Pr(t,i.x,r.x,o.x),Pr(t,i.y,r.y,o.y),Pr(t,i.z,r.z,o.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}wh.prototype.isQuadraticBezierCurve3=!0;class sl extends We{constructor(t=[]){super(),this.type="SplineCurve",this.points=t}getPoint(t,e=new j){const n=e,i=this.points,r=(i.length-1)*t,o=Math.floor(r),a=r-o,l=i[o===0?o:o-1],c=i[o],h=i[o>i.length-2?i.length-1:o+1],u=i[o>i.length-3?i.length-1:o+2];return n.set(md(a,l.x,c.x,h.x,u.x),md(a,l.y,c.y,h.y,u.y)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const i=t.points[e];this.points.push(i.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const i=this.points[e];t.points.push(i.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const i=t.points[e];this.points.push(new j().fromArray(i))}return this}}sl.prototype.isSplineCurve=!0;var Sh=Object.freeze({__proto__:null,ArcCurve:_h,CatmullRomCurve3:bh,CubicBezierCurve:nl,CubicBezierCurve3:Mh,EllipseCurve:go,LineCurve:xo,LineCurve3:yg,QuadraticBezierCurve:il,QuadraticBezierCurve3:wh,SplineCurve:sl});const OM={triangulate:function(s,t,e=2){const n=t&&t.length,i=n?t[0]*e:s.length;let r=_g(s,0,i,e,!0);const o=[];if(!r||r.next===r.prev)return o;let a,l,c,h,u,d,f;if(n&&(r=VM(s,t,r,e)),s.length>80*e){a=c=s[0],l=h=s[1];for(let p=e;p<i;p+=e)u=s[p],d=s[p+1],u<a&&(a=u),d<l&&(l=d),u>c&&(c=u),d>h&&(h=d);f=Math.max(c-a,h-l),f=f!==0?1/f:0}return qr(r,o,e,a,l,f),o}};function _g(s,t,e,n,i){let r,o;if(i===QM(s,t,e,n)>0)for(r=t;r<e;r+=n)o=gd(r,s[r],s[r+1],o);else for(r=e-n;r>=t;r-=n)o=gd(r,s[r],s[r+1],o);return o&&rl(o,o.next)&&(jr(o),o=o.next),o}function ci(s,t){if(!s)return s;t||(t=s);let e=s,n;do if(n=!1,!e.steiner&&(rl(e,e.next)||Kt(e.prev,e,e.next)===0)){if(jr(e),e=t=e.prev,e===e.next)break;n=!0}else e=e.next;while(n||e!==t);return t}function qr(s,t,e,n,i,r,o){if(!s)return;!o&&r&&YM(s,n,i,r);let a=s,l,c;for(;s.prev!==s.next;){if(l=s.prev,c=s.next,r?NM(s,n,i,r):zM(s)){t.push(l.i/e),t.push(s.i/e),t.push(c.i/e),jr(s),s=c.next,a=c.next;continue}if(s=c,s===a){o?o===1?(s=HM(ci(s),t,e),qr(s,t,e,n,i,r,2)):o===2&&UM(s,t,e,n,i,r):qr(ci(s),t,e,n,i,r,1);break}}}function zM(s){const t=s.prev,e=s,n=s.next;if(Kt(t,e,n)>=0)return!1;let i=s.next.next;for(;i!==s.prev;){if(Is(t.x,t.y,e.x,e.y,n.x,n.y,i.x,i.y)&&Kt(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function NM(s,t,e,n){const i=s.prev,r=s,o=s.next;if(Kt(i,r,o)>=0)return!1;const a=i.x<r.x?i.x<o.x?i.x:o.x:r.x<o.x?r.x:o.x,l=i.y<r.y?i.y<o.y?i.y:o.y:r.y<o.y?r.y:o.y,c=i.x>r.x?i.x>o.x?i.x:o.x:r.x>o.x?r.x:o.x,h=i.y>r.y?i.y>o.y?i.y:o.y:r.y>o.y?r.y:o.y,u=Oc(a,l,t,e,n),d=Oc(c,h,t,e,n);let f=s.prevZ,p=s.nextZ;for(;f&&f.z>=u&&p&&p.z<=d;){if(f!==s.prev&&f!==s.next&&Is(i.x,i.y,r.x,r.y,o.x,o.y,f.x,f.y)&&Kt(f.prev,f,f.next)>=0||(f=f.prevZ,p!==s.prev&&p!==s.next&&Is(i.x,i.y,r.x,r.y,o.x,o.y,p.x,p.y)&&Kt(p.prev,p,p.next)>=0))return!1;p=p.nextZ}for(;f&&f.z>=u;){if(f!==s.prev&&f!==s.next&&Is(i.x,i.y,r.x,r.y,o.x,o.y,f.x,f.y)&&Kt(f.prev,f,f.next)>=0)return!1;f=f.prevZ}for(;p&&p.z<=d;){if(p!==s.prev&&p!==s.next&&Is(i.x,i.y,r.x,r.y,o.x,o.y,p.x,p.y)&&Kt(p.prev,p,p.next)>=0)return!1;p=p.nextZ}return!0}function HM(s,t,e){let n=s;do{const i=n.prev,r=n.next.next;!rl(i,r)&&vg(i,n,n.next,r)&&Yr(i,r)&&Yr(r,i)&&(t.push(i.i/e),t.push(n.i/e),t.push(r.i/e),jr(n),jr(n.next),n=s=r),n=n.next}while(n!==s);return ci(n)}function UM(s,t,e,n,i,r){let o=s;do{let a=o.next.next;for(;a!==o.prev;){if(o.i!==a.i&&ZM(o,a)){let l=bg(o,a);o=ci(o,o.next),l=ci(l,l.next),qr(o,t,e,n,i,r),qr(l,t,e,n,i,r);return}a=a.next}o=o.next}while(o!==s)}function VM(s,t,e,n){const i=[];let r,o,a,l,c;for(r=0,o=t.length;r<o;r++)a=t[r]*n,l=r<o-1?t[r+1]*n:s.length,c=_g(s,a,l,n,!1),c===c.next&&(c.steiner=!0),i.push(JM(c));for(i.sort(WM),r=0;r<i.length;r++)GM(i[r],e),e=ci(e,e.next);return e}function WM(s,t){return s.x-t.x}function GM(s,t){if(t=XM(s,t),t){const e=bg(t,s);ci(t,t.next),ci(e,e.next)}}function XM(s,t){let e=t;const n=s.x,i=s.y;let r=-1/0,o;do{if(i<=e.y&&i>=e.next.y&&e.next.y!==e.y){const d=e.x+(i-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(d<=n&&d>r){if(r=d,d===n){if(i===e.y)return e;if(i===e.next.y)return e.next}o=e.x<e.next.x?e:e.next}}e=e.next}while(e!==t);if(!o)return null;if(n===r)return o;const a=o,l=o.x,c=o.y;let h=1/0,u;e=o;do n>=e.x&&e.x>=l&&n!==e.x&&Is(i<c?n:r,i,l,c,i<c?r:n,i,e.x,e.y)&&(u=Math.abs(i-e.y)/(n-e.x),Yr(e,s)&&(u<h||u===h&&(e.x>o.x||e.x===o.x&&qM(o,e)))&&(o=e,h=u)),e=e.next;while(e!==a);return o}function qM(s,t){return Kt(s.prev,s,t.prev)<0&&Kt(t.next,s,s.next)<0}function YM(s,t,e,n){let i=s;do i.z===null&&(i.z=Oc(i.x,i.y,t,e,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==s);i.prevZ.nextZ=null,i.prevZ=null,jM(i)}function jM(s){let t,e,n,i,r,o,a,l,c=1;do{for(e=s,s=null,r=null,o=0;e;){for(o++,n=e,a=0,t=0;t<c&&(a++,n=n.nextZ,!!n);t++);for(l=c;a>0||l>0&&n;)a!==0&&(l===0||!n||e.z<=n.z)?(i=e,e=e.nextZ,a--):(i=n,n=n.nextZ,l--),r?r.nextZ=i:s=i,i.prevZ=r,r=i;e=n}r.nextZ=null,c*=2}while(o>1);return s}function Oc(s,t,e,n,i){return s=32767*(s-e)*i,t=32767*(t-n)*i,s=(s|s<<8)&16711935,s=(s|s<<4)&252645135,s=(s|s<<2)&858993459,s=(s|s<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,s|t<<1}function JM(s){let t=s,e=s;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==s);return e}function Is(s,t,e,n,i,r,o,a){return(i-o)*(t-a)-(s-o)*(r-a)>=0&&(s-o)*(n-a)-(e-o)*(t-a)>=0&&(e-o)*(r-a)-(i-o)*(n-a)>=0}function ZM(s,t){return s.next.i!==t.i&&s.prev.i!==t.i&&!$M(s,t)&&(Yr(s,t)&&Yr(t,s)&&KM(s,t)&&(Kt(s.prev,s,t.prev)||Kt(s,t.prev,t))||rl(s,t)&&Kt(s.prev,s,s.next)>0&&Kt(t.prev,t,t.next)>0)}function Kt(s,t,e){return(t.y-s.y)*(e.x-t.x)-(t.x-s.x)*(e.y-t.y)}function rl(s,t){return s.x===t.x&&s.y===t.y}function vg(s,t,e,n){const i=ta(Kt(s,t,e)),r=ta(Kt(s,t,n)),o=ta(Kt(e,n,s)),a=ta(Kt(e,n,t));return!!(i!==r&&o!==a||i===0&&Qo(s,e,t)||r===0&&Qo(s,n,t)||o===0&&Qo(e,s,n)||a===0&&Qo(e,t,n))}function Qo(s,t,e){return t.x<=Math.max(s.x,e.x)&&t.x>=Math.min(s.x,e.x)&&t.y<=Math.max(s.y,e.y)&&t.y>=Math.min(s.y,e.y)}function ta(s){return s>0?1:s<0?-1:0}function $M(s,t){let e=s;do{if(e.i!==s.i&&e.next.i!==s.i&&e.i!==t.i&&e.next.i!==t.i&&vg(e,e.next,s,t))return!0;e=e.next}while(e!==s);return!1}function Yr(s,t){return Kt(s.prev,s,s.next)<0?Kt(s,t,s.next)>=0&&Kt(s,s.prev,t)>=0:Kt(s,t,s.prev)<0||Kt(s,s.next,t)<0}function KM(s,t){let e=s,n=!1;const i=(s.x+t.x)/2,r=(s.y+t.y)/2;do e.y>r!=e.next.y>r&&e.next.y!==e.y&&i<(e.next.x-e.x)*(r-e.y)/(e.next.y-e.y)+e.x&&(n=!n),e=e.next;while(e!==s);return n}function bg(s,t){const e=new zc(s.i,s.x,s.y),n=new zc(t.i,t.x,t.y),i=s.next,r=t.prev;return s.next=t,t.prev=s,e.next=i,i.prev=e,n.next=e,e.prev=n,r.next=n,n.prev=r,n}function gd(s,t,e,n){const i=new zc(s,t,e);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function jr(s){s.next.prev=s.prev,s.prev.next=s.next,s.prevZ&&(s.prevZ.nextZ=s.nextZ),s.nextZ&&(s.nextZ.prevZ=s.prevZ)}function zc(s,t,e){this.i=s,this.x=t,this.y=e,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function QM(s,t,e,n){let i=0;for(let r=t,o=e-n;r<e;r+=n)i+=(s[o]-s[r])*(s[r+1]+s[o+1]),o=r;return i}class mn{static area(t){const e=t.length;let n=0;for(let i=e-1,r=0;r<e;i=r++)n+=t[i].x*t[r].y-t[r].x*t[i].y;return n*.5}static isClockWise(t){return mn.area(t)<0}static triangulateShape(t,e){const n=[],i=[],r=[];xd(t),yd(n,t);let o=t.length;e.forEach(xd);for(let l=0;l<e.length;l++)i.push(o),o+=e[l].length,yd(n,e[l]);const a=OM.triangulate(n,i);for(let l=0;l<a.length;l+=3)r.push(a.slice(l,l+3));return r}}function xd(s){const t=s.length;t>2&&s[t-1].equals(s[0])&&s.pop()}function yd(s,t){for(let e=0;e<t.length;e++)s.push(t[e].x),s.push(t[e].y)}class sn extends bt{constructor(t,e){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const n=this,i=[],r=[];for(let a=0,l=t.length;a<l;a++){const c=t[a];o(c)}this.setAttribute("position",new at(i,3)),this.setAttribute("uv",new at(r,2)),this.computeVertexNormals();function o(a){const l=[],c=e.curveSegments!==void 0?e.curveSegments:12,h=e.steps!==void 0?e.steps:1;let u=e.depth!==void 0?e.depth:100,d=e.bevelEnabled!==void 0?e.bevelEnabled:!0,f=e.bevelThickness!==void 0?e.bevelThickness:6,p=e.bevelSize!==void 0?e.bevelSize:f-2,m=e.bevelOffset!==void 0?e.bevelOffset:0,y=e.bevelSegments!==void 0?e.bevelSegments:3;const g=e.extrudePath,x=e.UVGenerator!==void 0?e.UVGenerator:tw;e.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),u=e.amount);let v,_=!1,M,w,b,E;g&&(v=g.getSpacedPoints(h),_=!0,d=!1,M=g.computeFrenetFrames(h,!1),w=new S,b=new S,E=new S),d||(y=0,f=0,p=0,m=0);const P=a.extractPoints(c);let R=P.shape;const C=P.holes;if(!mn.isClockWise(R)){R=R.reverse();for(let G=0,$=C.length;G<$;G++){const Q=C[G];mn.isClockWise(Q)&&(C[G]=Q.reverse())}}const k=mn.triangulateShape(R,C),B=R;for(let G=0,$=C.length;G<$;G++){const Q=C[G];R=R.concat(Q)}function O(G,$,Q){return $||console.error("THREE.ExtrudeGeometry: vec does not exist"),$.clone().multiplyScalar(Q).add(G)}const F=R.length,N=k.length;function Z(G,$,Q){let gt,rt,L;const A=G.x-$.x,W=G.y-$.y,Y=Q.x-G.x,st=Q.y-G.y,ct=A*A+W*W,St=A*st-W*Y;if(Math.abs(St)>Number.EPSILON){const yt=Math.sqrt(ct),Lt=Math.sqrt(Y*Y+st*st),xt=$.x-W/yt,D=$.y+A/yt,ot=Q.x-st/Lt,q=Q.y+Y/Lt,ht=((ot-xt)*st-(q-D)*Y)/(A*st-W*Y);gt=xt+A*ht-G.x,rt=D+W*ht-G.y;const mt=gt*gt+rt*rt;if(mt<=2)return new j(gt,rt);L=Math.sqrt(mt/2)}else{let yt=!1;A>Number.EPSILON?Y>Number.EPSILON&&(yt=!0):A<-Number.EPSILON?Y<-Number.EPSILON&&(yt=!0):Math.sign(W)===Math.sign(st)&&(yt=!0),yt?(gt=-W,rt=A,L=Math.sqrt(ct)):(gt=A,rt=W,L=Math.sqrt(ct/2))}return new j(gt/L,rt/L)}const tt=[];for(let G=0,$=B.length,Q=$-1,gt=G+1;G<$;G++,Q++,gt++)Q===$&&(Q=0),gt===$&&(gt=0),tt[G]=Z(B[G],B[Q],B[gt]);const dt=[];let nt,_t=tt.concat();for(let G=0,$=C.length;G<$;G++){const Q=C[G];nt=[];for(let gt=0,rt=Q.length,L=rt-1,A=gt+1;gt<rt;gt++,L++,A++)L===rt&&(L=0),A===rt&&(A=0),nt[gt]=Z(Q[gt],Q[L],Q[A]);dt.push(nt),_t=_t.concat(nt)}for(let G=0;G<y;G++){const $=G/y,Q=f*Math.cos($*Math.PI/2),gt=p*Math.sin($*Math.PI/2)+m;for(let rt=0,L=B.length;rt<L;rt++){const A=O(B[rt],tt[rt],gt);vt(A.x,A.y,-Q)}for(let rt=0,L=C.length;rt<L;rt++){const A=C[rt];nt=dt[rt];for(let W=0,Y=A.length;W<Y;W++){const st=O(A[W],nt[W],gt);vt(st.x,st.y,-Q)}}}const X=p+m;for(let G=0;G<F;G++){const $=d?O(R[G],_t[G],X):R[G];_?(b.copy(M.normals[0]).multiplyScalar($.x),w.copy(M.binormals[0]).multiplyScalar($.y),E.copy(v[0]).add(b).add(w),vt(E.x,E.y,E.z)):vt($.x,$.y,0)}for(let G=1;G<=h;G++)for(let $=0;$<F;$++){const Q=d?O(R[$],_t[$],X):R[$];_?(b.copy(M.normals[G]).multiplyScalar(Q.x),w.copy(M.binormals[G]).multiplyScalar(Q.y),E.copy(v[G]).add(b).add(w),vt(E.x,E.y,E.z)):vt(Q.x,Q.y,u/h*G)}for(let G=y-1;G>=0;G--){const $=G/y,Q=f*Math.cos($*Math.PI/2),gt=p*Math.sin($*Math.PI/2)+m;for(let rt=0,L=B.length;rt<L;rt++){const A=O(B[rt],tt[rt],gt);vt(A.x,A.y,u+Q)}for(let rt=0,L=C.length;rt<L;rt++){const A=C[rt];nt=dt[rt];for(let W=0,Y=A.length;W<Y;W++){const st=O(A[W],nt[W],gt);_?vt(st.x,st.y+v[h-1].y,v[h-1].x+Q):vt(st.x,st.y,u+Q)}}}K(),lt();function K(){const G=i.length/3;if(d){let $=0,Q=F*$;for(let gt=0;gt<N;gt++){const rt=k[gt];Tt(rt[2]+Q,rt[1]+Q,rt[0]+Q)}$=h+y*2,Q=F*$;for(let gt=0;gt<N;gt++){const rt=k[gt];Tt(rt[0]+Q,rt[1]+Q,rt[2]+Q)}}else{for(let $=0;$<N;$++){const Q=k[$];Tt(Q[2],Q[1],Q[0])}for(let $=0;$<N;$++){const Q=k[$];Tt(Q[0]+F*h,Q[1]+F*h,Q[2]+F*h)}}n.addGroup(G,i.length/3-G,0)}function lt(){const G=i.length/3;let $=0;H(B,$),$+=B.length;for(let Q=0,gt=C.length;Q<gt;Q++){const rt=C[Q];H(rt,$),$+=rt.length}n.addGroup(G,i.length/3-G,1)}function H(G,$){let Q=G.length;for(;--Q>=0;){const gt=Q;let rt=Q-1;rt<0&&(rt=G.length-1);for(let L=0,A=h+y*2;L<A;L++){const W=F*L,Y=F*(L+1),st=$+gt+W,ct=$+rt+W,St=$+rt+Y,yt=$+gt+Y;ut(st,ct,St,yt)}}}function vt(G,$,Q){l.push(G),l.push($),l.push(Q)}function Tt(G,$,Q){pt(G),pt($),pt(Q);const gt=i.length/3,rt=x.generateTopUV(n,i,gt-3,gt-2,gt-1);Ct(rt[0]),Ct(rt[1]),Ct(rt[2])}function ut(G,$,Q,gt){pt(G),pt($),pt(gt),pt($),pt(Q),pt(gt);const rt=i.length/3,L=x.generateSideWallUV(n,i,rt-6,rt-3,rt-2,rt-1);Ct(L[0]),Ct(L[1]),Ct(L[3]),Ct(L[1]),Ct(L[2]),Ct(L[3])}function pt(G){i.push(l[G*3+0]),i.push(l[G*3+1]),i.push(l[G*3+2])}function Ct(G){r.push(G.x),r.push(G.y)}}}toJSON(){const t=super.toJSON(),e=this.parameters.shapes,n=this.parameters.options;return ew(e,n,t)}static fromJSON(t,e){const n=[];for(let r=0,o=t.shapes.length;r<o;r++){const a=e[t.shapes[r]];n.push(a)}const i=t.options.extrudePath;return i!==void 0&&(t.options.extrudePath=new Sh[i.type]().fromJSON(i)),new sn(n,t.options)}}const tw={generateTopUV:function(s,t,e,n,i){const r=t[e*3],o=t[e*3+1],a=t[n*3],l=t[n*3+1],c=t[i*3],h=t[i*3+1];return[new j(r,o),new j(a,l),new j(c,h)]},generateSideWallUV:function(s,t,e,n,i,r){const o=t[e*3],a=t[e*3+1],l=t[e*3+2],c=t[n*3],h=t[n*3+1],u=t[n*3+2],d=t[i*3],f=t[i*3+1],p=t[i*3+2],m=t[r*3],y=t[r*3+1],g=t[r*3+2];return Math.abs(a-h)<Math.abs(o-c)?[new j(o,1-l),new j(c,1-u),new j(d,1-p),new j(m,1-g)]:[new j(a,1-l),new j(h,1-u),new j(f,1-p),new j(y,1-g)]}};function ew(s,t,e){if(e.shapes=[],Array.isArray(s))for(let n=0,i=s.length;n<i;n++){const r=s[n];e.shapes.push(r.uuid)}else e.shapes.push(s.uuid);return t.extrudePath!==void 0&&(e.options.extrudePath=t.extrudePath.toJSON()),e}class Xs extends xn{constructor(t=1,e=0){const n=(1+Math.sqrt(5))/2,i=[-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],r=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(i,r,t,e),this.type="IcosahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Xs(t.radius,t.detail)}}class qs extends bt{constructor(t,e=12,n=0,i=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:t,segments:e,phiStart:n,phiLength:i},e=Math.floor(e),i=Me(i,0,Math.PI*2);const r=[],o=[],a=[],l=1/e,c=new S,h=new j;for(let u=0;u<=e;u++){const d=n+u*l*i,f=Math.sin(d),p=Math.cos(d);for(let m=0;m<=t.length-1;m++)c.x=t[m].x*f,c.y=t[m].y,c.z=t[m].x*p,o.push(c.x,c.y,c.z),h.x=u/e,h.y=m/(t.length-1),a.push(h.x,h.y)}for(let u=0;u<e;u++)for(let d=0;d<t.length-1;d++){const f=d+u*t.length,p=f,m=f+t.length,y=f+t.length+1,g=f+1;r.push(p,m,g),r.push(m,y,g)}if(this.setIndex(r),this.setAttribute("position",new at(o,3)),this.setAttribute("uv",new at(a,2)),this.computeVertexNormals(),i===Math.PI*2){const u=this.attributes.normal.array,d=new S,f=new S,p=new S,m=e*t.length*3;for(let y=0,g=0;y<t.length;y++,g+=3)d.x=u[g+0],d.y=u[g+1],d.z=u[g+2],f.x=u[m+g+0],f.y=u[m+g+1],f.z=u[m+g+2],p.addVectors(d,f).normalize(),u[g+0]=u[m+g+0]=p.x,u[g+1]=u[m+g+1]=p.y,u[g+2]=u[m+g+2]=p.z}}static fromJSON(t){return new qs(t.points,t.segments,t.phiStart,t.phiLength)}}class Yi extends xn{constructor(t=1,e=0){const n=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],i=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(n,i,t,e),this.type="OctahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Yi(t.radius,t.detail)}}class Ra extends bt{constructor(t,e,n){super(),this.type="ParametricGeometry",this.parameters={func:t,slices:e,stacks:n};const i=[],r=[],o=[],a=[],l=1e-5,c=new S,h=new S,u=new S,d=new S,f=new S;t.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");const p=e+1;for(let m=0;m<=n;m++){const y=m/n;for(let g=0;g<=e;g++){const x=g/e;t(x,y,h),r.push(h.x,h.y,h.z),x-l>=0?(t(x-l,y,u),d.subVectors(h,u)):(t(x+l,y,u),d.subVectors(u,h)),y-l>=0?(t(x,y-l,u),f.subVectors(h,u)):(t(x,y+l,u),f.subVectors(u,h)),c.crossVectors(d,f).normalize(),o.push(c.x,c.y,c.z),a.push(x,y)}}for(let m=0;m<n;m++)for(let y=0;y<e;y++){const g=m*p+y,x=m*p+y+1,v=(m+1)*p+y+1,_=(m+1)*p+y;i.push(g,x,_),i.push(x,v,_)}this.setIndex(i),this.setAttribute("position",new at(r,3)),this.setAttribute("normal",new at(o,3)),this.setAttribute("uv",new at(a,2))}}class Ys extends bt{constructor(t=.5,e=1,n=8,i=1,r=0,o=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:t,outerRadius:e,thetaSegments:n,phiSegments:i,thetaStart:r,thetaLength:o},n=Math.max(3,n),i=Math.max(1,i);const a=[],l=[],c=[],h=[];let u=t;const d=(e-t)/i,f=new S,p=new j;for(let m=0;m<=i;m++){for(let y=0;y<=n;y++){const g=r+y/n*o;f.x=u*Math.cos(g),f.y=u*Math.sin(g),l.push(f.x,f.y,f.z),c.push(0,0,1),p.x=(f.x/e+1)/2,p.y=(f.y/e+1)/2,h.push(p.x,p.y)}u+=d}for(let m=0;m<i;m++){const y=m*(n+1);for(let g=0;g<n;g++){const x=g+y,v=x,_=x+n+1,M=x+n+2,w=x+1;a.push(v,_,w),a.push(_,M,w)}}this.setIndex(a),this.setAttribute("position",new at(l,3)),this.setAttribute("normal",new at(c,3)),this.setAttribute("uv",new at(h,2))}static fromJSON(t){return new Ys(t.innerRadius,t.outerRadius,t.thetaSegments,t.phiSegments,t.thetaStart,t.thetaLength)}}class ji extends bt{constructor(t,e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const n=[],i=[],r=[],o=[];let a=0,l=0;if(Array.isArray(t)===!1)c(t);else for(let h=0;h<t.length;h++)c(t[h]),this.addGroup(a,l,h),a+=l,l=0;this.setIndex(n),this.setAttribute("position",new at(i,3)),this.setAttribute("normal",new at(r,3)),this.setAttribute("uv",new at(o,2));function c(h){const u=i.length/3,d=h.extractPoints(e);let f=d.shape;const p=d.holes;mn.isClockWise(f)===!1&&(f=f.reverse());for(let y=0,g=p.length;y<g;y++){const x=p[y];mn.isClockWise(x)===!0&&(p[y]=x.reverse())}const m=mn.triangulateShape(f,p);for(let y=0,g=p.length;y<g;y++){const x=p[y];f=f.concat(x)}for(let y=0,g=f.length;y<g;y++){const x=f[y];i.push(x.x,x.y,0),r.push(0,0,1),o.push(x.x,x.y)}for(let y=0,g=m.length;y<g;y++){const x=m[y],v=x[0]+u,_=x[1]+u,M=x[2]+u;n.push(v,_,M),l+=3}}}toJSON(){const t=super.toJSON(),e=this.parameters.shapes;return nw(e,t)}static fromJSON(t,e){const n=[];for(let i=0,r=t.shapes.length;i<r;i++){const o=e[t.shapes[i]];n.push(o)}return new ji(n,t.curveSegments)}}function nw(s,t){if(t.shapes=[],Array.isArray(s))for(let e=0,n=s.length;e<n;e++){const i=s[e];t.shapes.push(i.uuid)}else t.shapes.push(s.uuid);return t}class Ji extends bt{constructor(t=1,e=32,n=16,i=0,r=Math.PI*2,o=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:n,phiStart:i,phiLength:r,thetaStart:o,thetaLength:a},e=Math.max(3,Math.floor(e)),n=Math.max(2,Math.floor(n));const l=Math.min(o+a,Math.PI);let c=0;const h=[],u=new S,d=new S,f=[],p=[],m=[],y=[];for(let g=0;g<=n;g++){const x=[],v=g/n;let _=0;g==0&&o==0?_=.5/e:g==n&&l==Math.PI&&(_=-.5/e);for(let M=0;M<=e;M++){const w=M/e;u.x=-t*Math.cos(i+w*r)*Math.sin(o+v*a),u.y=t*Math.cos(o+v*a),u.z=t*Math.sin(i+w*r)*Math.sin(o+v*a),p.push(u.x,u.y,u.z),d.copy(u).normalize(),m.push(d.x,d.y,d.z),y.push(w+_,1-v),x.push(c++)}h.push(x)}for(let g=0;g<n;g++)for(let x=0;x<e;x++){const v=h[g][x+1],_=h[g][x],M=h[g+1][x],w=h[g+1][x+1];(g!==0||o>0)&&f.push(v,_,w),(g!==n-1||l<Math.PI)&&f.push(_,M,w)}this.setIndex(f),this.setAttribute("position",new at(p,3)),this.setAttribute("normal",new at(m,3)),this.setAttribute("uv",new at(y,2))}static fromJSON(t){return new Ji(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class js extends xn{constructor(t=1,e=0){const n=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],i=[2,1,0,0,3,2,1,3,0,2,3,1];super(n,i,t,e),this.type="TetrahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new js(t.radius,t.detail)}}class Pa extends sn{constructor(t,e={}){const n=e.font;if(!(n&&n.isFont))return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),new bt;const i=n.generateShapes(t,e.size);e.depth=e.height!==void 0?e.height:50,e.bevelThickness===void 0&&(e.bevelThickness=10),e.bevelSize===void 0&&(e.bevelSize=8),e.bevelEnabled===void 0&&(e.bevelEnabled=!1),super(i,e),this.type="TextGeometry"}}class Js extends bt{constructor(t=1,e=.4,n=8,i=6,r=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:e,radialSegments:n,tubularSegments:i,arc:r},n=Math.floor(n),i=Math.floor(i);const o=[],a=[],l=[],c=[],h=new S,u=new S,d=new S;for(let f=0;f<=n;f++)for(let p=0;p<=i;p++){const m=p/i*r,y=f/n*Math.PI*2;u.x=(t+e*Math.cos(y))*Math.cos(m),u.y=(t+e*Math.cos(y))*Math.sin(m),u.z=e*Math.sin(y),a.push(u.x,u.y,u.z),h.x=t*Math.cos(m),h.y=t*Math.sin(m),d.subVectors(u,h).normalize(),l.push(d.x,d.y,d.z),c.push(p/i),c.push(f/n)}for(let f=1;f<=n;f++)for(let p=1;p<=i;p++){const m=(i+1)*f+p-1,y=(i+1)*(f-1)+p-1,g=(i+1)*(f-1)+p,x=(i+1)*f+p;o.push(m,y,x),o.push(y,g,x)}this.setIndex(o),this.setAttribute("position",new at(a,3)),this.setAttribute("normal",new at(l,3)),this.setAttribute("uv",new at(c,2))}static fromJSON(t){return new Js(t.radius,t.tube,t.radialSegments,t.tubularSegments,t.arc)}}class Zs extends bt{constructor(t=1,e=.4,n=64,i=8,r=2,o=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:t,tube:e,tubularSegments:n,radialSegments:i,p:r,q:o},n=Math.floor(n),i=Math.floor(i);const a=[],l=[],c=[],h=[],u=new S,d=new S,f=new S,p=new S,m=new S,y=new S,g=new S;for(let v=0;v<=n;++v){const _=v/n*r*Math.PI*2;x(_,r,o,t,f),x(_+.01,r,o,t,p),y.subVectors(p,f),g.addVectors(p,f),m.crossVectors(y,g),g.crossVectors(m,y),m.normalize(),g.normalize();for(let M=0;M<=i;++M){const w=M/i*Math.PI*2,b=-e*Math.cos(w),E=e*Math.sin(w);u.x=f.x+(b*g.x+E*m.x),u.y=f.y+(b*g.y+E*m.y),u.z=f.z+(b*g.z+E*m.z),l.push(u.x,u.y,u.z),d.subVectors(u,f).normalize(),c.push(d.x,d.y,d.z),h.push(v/n),h.push(M/i)}}for(let v=1;v<=n;v++)for(let _=1;_<=i;_++){const M=(i+1)*(v-1)+(_-1),w=(i+1)*v+(_-1),b=(i+1)*v+_,E=(i+1)*(v-1)+_;a.push(M,w,E),a.push(w,b,E)}this.setIndex(a),this.setAttribute("position",new at(l,3)),this.setAttribute("normal",new at(c,3)),this.setAttribute("uv",new at(h,2));function x(v,_,M,w,b){const E=Math.cos(v),P=Math.sin(v),R=M/_*v,C=Math.cos(R);b.x=w*(2+C)*.5*E,b.y=w*(2+C)*P*.5,b.z=w*Math.sin(R)*.5}}static fromJSON(t){return new Zs(t.radius,t.tube,t.tubularSegments,t.radialSegments,t.p,t.q)}}class $s extends bt{constructor(t,e=64,n=1,i=8,r=!1){super(),this.type="TubeGeometry",this.parameters={path:t,tubularSegments:e,radius:n,radialSegments:i,closed:r};const o=t.computeFrenetFrames(e,r);this.tangents=o.tangents,this.normals=o.normals,this.binormals=o.binormals;const a=new S,l=new S,c=new j;let h=new S;const u=[],d=[],f=[],p=[];m(),this.setIndex(p),this.setAttribute("position",new at(u,3)),this.setAttribute("normal",new at(d,3)),this.setAttribute("uv",new at(f,2));function m(){for(let v=0;v<e;v++)y(v);y(r===!1?e:0),x(),g()}function y(v){h=t.getPointAt(v/e,h);const _=o.normals[v],M=o.binormals[v];for(let w=0;w<=i;w++){const b=w/i*Math.PI*2,E=Math.sin(b),P=-Math.cos(b);l.x=P*_.x+E*M.x,l.y=P*_.y+E*M.y,l.z=P*_.z+E*M.z,l.normalize(),d.push(l.x,l.y,l.z),a.x=h.x+n*l.x,a.y=h.y+n*l.y,a.z=h.z+n*l.z,u.push(a.x,a.y,a.z)}}function g(){for(let v=1;v<=e;v++)for(let _=1;_<=i;_++){const M=(i+1)*(v-1)+(_-1),w=(i+1)*v+(_-1),b=(i+1)*v+_,E=(i+1)*(v-1)+_;p.push(M,w,E),p.push(w,b,E)}}function x(){for(let v=0;v<=e;v++)for(let _=0;_<=i;_++)c.x=v/e,c.y=_/i,f.push(c.x,c.y)}}toJSON(){const t=super.toJSON();return t.path=this.parameters.path.toJSON(),t}static fromJSON(t){return new $s(new Sh[t.path.type]().fromJSON(t.path),t.tubularSegments,t.radius,t.radialSegments,t.closed)}}class Th extends bt{constructor(t){if(super(),this.type="WireframeGeometry",t.isGeometry===!0){console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return}const e=[],n=new Set,i=new S,r=new S;if(t.index!==null){const o=t.attributes.position,a=t.index;let l=t.groups;l.length===0&&(l=[{start:0,count:a.count,materialIndex:0}]);for(let c=0,h=l.length;c<h;++c){const u=l[c],d=u.start,f=u.count;for(let p=d,m=d+f;p<m;p+=3)for(let y=0;y<3;y++){const g=a.getX(p+y),x=a.getX(p+(y+1)%3);i.fromBufferAttribute(o,g),r.fromBufferAttribute(o,x),_d(i,r,n)===!0&&(e.push(i.x,i.y,i.z),e.push(r.x,r.y,r.z))}}}else{const o=t.attributes.position;for(let a=0,l=o.count/3;a<l;a++)for(let c=0;c<3;c++){const h=3*a+c,u=3*a+(c+1)%3;i.fromBufferAttribute(o,h),r.fromBufferAttribute(o,u),_d(i,r,n)===!0&&(e.push(i.x,i.y,i.z),e.push(r.x,r.y,r.z))}}this.setAttribute("position",new at(e,3))}}function _d(s,t,e){const n=`${s.x},${s.y},${s.z}-${t.x},${t.y},${t.z}`,i=`${t.x},${t.y},${t.z}-${s.x},${s.y},${s.z}`;return e.has(n)===!0||e.has(i)===!0?!1:(e.add(n,i),!0)}var vd=Object.freeze({__proto__:null,BoxGeometry:kn,BoxBufferGeometry:kn,CircleGeometry:Vs,CircleBufferGeometry:Vs,ConeGeometry:Ws,ConeBufferGeometry:Ws,CylinderGeometry:li,CylinderBufferGeometry:li,DodecahedronGeometry:Gs,DodecahedronBufferGeometry:Gs,EdgesGeometry:yh,ExtrudeGeometry:sn,ExtrudeBufferGeometry:sn,IcosahedronGeometry:Xs,IcosahedronBufferGeometry:Xs,LatheGeometry:qs,LatheBufferGeometry:qs,OctahedronGeometry:Yi,OctahedronBufferGeometry:Yi,ParametricGeometry:Ra,ParametricBufferGeometry:Ra,PlaneGeometry:Xi,PlaneBufferGeometry:Xi,PolyhedronGeometry:xn,PolyhedronBufferGeometry:xn,RingGeometry:Ys,RingBufferGeometry:Ys,ShapeGeometry:ji,ShapeBufferGeometry:ji,SphereGeometry:Ji,SphereBufferGeometry:Ji,TetrahedronGeometry:js,TetrahedronBufferGeometry:js,TextGeometry:Pa,TextBufferGeometry:Pa,TorusGeometry:Js,TorusBufferGeometry:Js,TorusKnotGeometry:Zs,TorusKnotBufferGeometry:Zs,TubeGeometry:$s,TubeBufferGeometry:$s,WireframeGeometry:Th});class Eh extends ye{constructor(t){super(),this.type="ShadowMaterial",this.color=new it(0),this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this}}Eh.prototype.isShadowMaterial=!0;class ol extends ye{constructor(t){super(),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new it(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new it(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ts,this.normalScale=new j(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}ol.prototype.isMeshStandardMaterial=!0;class Ah extends ol{constructor(t){super(),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new j(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Me(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}}),this.sheenTint=new it(0),this.transmission=0,this.transmissionMap=null,this.thickness=.01,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationTint=new it(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularTint=new it(1,1,1),this.specularTintMap=null,this._clearcoat=0,this._transmission=0,this.setValues(t)}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.ior=t.ior,this.sheenTint.copy(t.sheenTint),this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationTint.copy(t.attenuationTint),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularTint.copy(t.specularTint),this.specularTintMap=t.specularTintMap,this}}Ah.prototype.isMeshPhysicalMaterial=!0;class Lh extends ye{constructor(t){super(),this.type="MeshPhongMaterial",this.color=new it(16777215),this.specular=new it(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new it(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ts,this.normalScale=new j(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=oo,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}Lh.prototype.isMeshPhongMaterial=!0;class Ch extends ye{constructor(t){super(),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new it(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new it(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ts,this.normalScale=new j(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}Ch.prototype.isMeshToonMaterial=!0;class Rh extends ye{constructor(t){super(),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ts,this.normalScale=new j(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}Rh.prototype.isMeshNormalMaterial=!0;class Ph extends ye{constructor(t){super(),this.type="MeshLambertMaterial",this.color=new it(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new it(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=oo,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}Ph.prototype.isMeshLambertMaterial=!0;class Dh extends ye{constructor(t){super(),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new it(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ts,this.normalScale=new j(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.flatShading=t.flatShading,this}}Dh.prototype.isMeshMatcapMaterial=!0;class Ih extends _e{constructor(t){super(),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}Ih.prototype.isLineDashedMaterial=!0;var iw=Object.freeze({__proto__:null,ShadowMaterial:Eh,SpriteMaterial:$a,RawShaderMaterial:rr,ShaderMaterial:Bn,PointsMaterial:ss,MeshPhysicalMaterial:Ah,MeshStandardMaterial:ol,MeshPhongMaterial:Lh,MeshToonMaterial:Ch,MeshNormalMaterial:Rh,MeshLambertMaterial:Ph,MeshDepthMaterial:ja,MeshDistanceMaterial:Ja,MeshBasicMaterial:Nn,MeshMatcapMaterial:Dh,LineDashedMaterial:Ih,LineBasicMaterial:_e,Material:ye});const Jt={arraySlice:function(s,t,e){return Jt.isTypedArray(s)?new s.constructor(s.subarray(t,e!==void 0?e:s.length)):s.slice(t,e)},convertArray:function(s,t,e){return!s||!e&&s.constructor===t?s:typeof t.BYTES_PER_ELEMENT=="number"?new t(s):Array.prototype.slice.call(s)},isTypedArray:function(s){return ArrayBuffer.isView(s)&&!(s instanceof DataView)},getKeyframeOrder:function(s){function t(i,r){return s[i]-s[r]}const e=s.length,n=new Array(e);for(let i=0;i!==e;++i)n[i]=i;return n.sort(t),n},sortedArray:function(s,t,e){const n=s.length,i=new s.constructor(n);for(let r=0,o=0;o!==n;++r){const a=e[r]*t;for(let l=0;l!==t;++l)i[o++]=s[a+l]}return i},flattenJSON:function(s,t,e,n){let i=1,r=s[0];for(;r!==void 0&&r[n]===void 0;)r=s[i++];if(r===void 0)return;let o=r[n];if(o!==void 0)if(Array.isArray(o))do o=r[n],o!==void 0&&(t.push(r.time),e.push.apply(e,o)),r=s[i++];while(r!==void 0);else if(o.toArray!==void 0)do o=r[n],o!==void 0&&(t.push(r.time),o.toArray(e,e.length)),r=s[i++];while(r!==void 0);else do o=r[n],o!==void 0&&(t.push(r.time),e.push(o)),r=s[i++];while(r!==void 0)},subclip:function(s,t,e,n,i=30){const r=s.clone();r.name=t;const o=[];for(let l=0;l<r.tracks.length;++l){const c=r.tracks[l],h=c.getValueSize(),u=[],d=[];for(let f=0;f<c.times.length;++f){const p=c.times[f]*i;if(!(p<e||p>=n)){u.push(c.times[f]);for(let m=0;m<h;++m)d.push(c.values[f*h+m])}}u.length!==0&&(c.times=Jt.convertArray(u,c.times.constructor),c.values=Jt.convertArray(d,c.values.constructor),o.push(c))}r.tracks=o;let a=1/0;for(let l=0;l<r.tracks.length;++l)a>r.tracks[l].times[0]&&(a=r.tracks[l].times[0]);for(let l=0;l<r.tracks.length;++l)r.tracks[l].shift(-1*a);return r.resetDuration(),r},makeClipAdditive:function(s,t=0,e=s,n=30){n<=0&&(n=30);const i=e.tracks.length,r=t/n;for(let o=0;o<i;++o){const a=e.tracks[o],l=a.ValueTypeName;if(l==="bool"||l==="string")continue;const c=s.tracks.find(function(g){return g.name===a.name&&g.ValueTypeName===l});if(c===void 0)continue;let h=0;const u=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(h=u/3);let d=0;const f=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=f/3);const p=a.times.length-1;let m;if(r<=a.times[0]){const g=h,x=u-h;m=Jt.arraySlice(a.values,g,x)}else if(r>=a.times[p]){const g=p*u+h,x=g+u-h;m=Jt.arraySlice(a.values,g,x)}else{const g=a.createInterpolant(),x=h,v=u-h;g.evaluate(r),m=Jt.arraySlice(g.resultBuffer,x,v)}l==="quaternion"&&new Se().fromArray(m).normalize().conjugate().toArray(m);const y=c.times.length;for(let g=0;g<y;++g){const x=g*f+d;if(l==="quaternion")Se.multiplyQuaternionsFlat(c.values,x,m,0,c.values,x);else{const v=f-d*2;for(let _=0;_<v;++_)c.values[x+_]-=m[_]}}}return s.blendMode=ih,s}};class zn{constructor(t,e,n,i){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new e.constructor(n),this.sampleValues=e,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let n=this._cachedIndex,i=e[n],r=e[n-1];t:{e:{let o;n:{i:if(!(t<i)){for(let a=n+2;;){if(i===void 0){if(t<r)break i;return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,t,r)}if(n===a)break;if(r=i,i=e[++n],t<i)break e}o=e.length;break n}if(!(t>=r)){const a=e[1];t<a&&(n=2,r=a);for(let l=n-2;;){if(r===void 0)return this._cachedIndex=0,this.beforeStart_(0,t,i);if(n===l)break;if(i=r,r=e[--n-1],t>=r)break e}o=n,n=0;break n}break t}for(;n<o;){const a=n+o>>>1;t<e[a]?o=a:n=a+1}if(i=e[n],r=e[n-1],r===void 0)return this._cachedIndex=0,this.beforeStart_(0,t,i);if(i===void 0)return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,r,t)}this._cachedIndex=n,this.intervalChanged_(n,r,i)}return this.interpolate_(n,r,t,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,i=this.valueSize,r=t*i;for(let o=0;o!==i;++o)e[o]=n[r+o];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}zn.prototype.beforeStart_=zn.prototype.copySampleValue_;zn.prototype.afterEnd_=zn.prototype.copySampleValue_;class Mg extends zn{constructor(t,e,n,i){super(t,e,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Di,endingEnd:Di}}intervalChanged_(t,e,n){const i=this.parameterPositions;let r=t-2,o=t+1,a=i[r],l=i[o];if(a===void 0)switch(this.getSettings_().endingStart){case Ii:r=t,a=2*e-n;break;case Gr:r=i.length-2,a=e+i[r]-i[r+1];break;default:r=t,a=n}if(l===void 0)switch(this.getSettings_().endingEnd){case Ii:o=t,l=2*n-e;break;case Gr:o=1,l=n+i[1]-i[0];break;default:o=t-1,l=e}const c=(n-e)*.5,h=this.valueSize;this._weightPrev=c/(e-a),this._weightNext=c/(l-n),this._offsetPrev=r*h,this._offsetNext=o*h}interpolate_(t,e,n,i){const r=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=t*a,c=l-a,h=this._offsetPrev,u=this._offsetNext,d=this._weightPrev,f=this._weightNext,p=(n-e)/(i-e),m=p*p,y=m*p,g=-d*y+2*d*m-d*p,x=(1+d)*y+(-1.5-2*d)*m+(-.5+d)*p+1,v=(-1-f)*y+(1.5+f)*m+.5*p,_=f*y-f*m;for(let M=0;M!==a;++M)r[M]=g*o[h+M]+x*o[c+M]+v*o[l+M]+_*o[u+M];return r}}class Fh extends zn{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t,e,n,i){const r=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=t*a,c=l-a,h=(n-e)/(i-e),u=1-h;for(let d=0;d!==a;++d)r[d]=o[c+d]*u+o[l+d]*h;return r}}class wg extends zn{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t){return this.copySampleValue_(t-1)}}class an{constructor(t,e,n,i){if(t===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=Jt.convertArray(e,this.TimeBufferType),this.values=Jt.convertArray(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let n;if(e.toJSON!==this.toJSON)n=e.toJSON(t);else{n={name:t.name,times:Jt.convertArray(t.times,Array),values:Jt.convertArray(t.values,Array)};const i=t.getInterpolation();i!==t.DefaultInterpolation&&(n.interpolation=i)}return n.type=t.ValueTypeName,n}InterpolantFactoryMethodDiscrete(t){return new wg(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new Fh(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new Mg(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case Vr:e=this.InterpolantFactoryMethodDiscrete;break;case Wr:e=this.InterpolantFactoryMethodLinear;break;case wa:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(t!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(n);return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Vr;case this.InterpolantFactoryMethodLinear:return Wr;case this.InterpolantFactoryMethodSmooth:return wa}}getValueSize(){return this.values.length/this.times.length}shift(t){if(t!==0){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]+=t}return this}scale(t){if(t!==1){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]*=t}return this}trim(t,e){const n=this.times,i=n.length;let r=0,o=i-1;for(;r!==i&&n[r]<t;)++r;for(;o!==-1&&n[o]>e;)--o;if(++o,r!==0||o!==i){r>=o&&(o=Math.max(o,1),r=o-1);const a=this.getValueSize();this.times=Jt.arraySlice(n,r,o),this.values=Jt.arraySlice(this.values,r*a,o*a)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const n=this.times,i=this.values,r=n.length;r===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let o=null;for(let a=0;a!==r;a++){const l=n[a];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,a,l),t=!1;break}if(o!==null&&o>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,a,l,o),t=!1;break}o=l}if(i!==void 0&&Jt.isTypedArray(i))for(let a=0,l=i.length;a!==l;++a){const c=i[a];if(isNaN(c)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,a,c),t=!1;break}}return t}optimize(){const t=Jt.arraySlice(this.times),e=Jt.arraySlice(this.values),n=this.getValueSize(),i=this.getInterpolation()===wa,r=t.length-1;let o=1;for(let a=1;a<r;++a){let l=!1;const c=t[a],h=t[a+1];if(c!==h&&(a!==1||c!==t[0]))if(i)l=!0;else{const u=a*n,d=u-n,f=u+n;for(let p=0;p!==n;++p){const m=e[u+p];if(m!==e[d+p]||m!==e[f+p]){l=!0;break}}}if(l){if(a!==o){t[o]=t[a];const u=a*n,d=o*n;for(let f=0;f!==n;++f)e[d+f]=e[u+f]}++o}}if(r>0){t[o]=t[r];for(let a=r*n,l=o*n,c=0;c!==n;++c)e[l+c]=e[a+c];++o}return o!==t.length?(this.times=Jt.arraySlice(t,0,o),this.values=Jt.arraySlice(e,0,o*n)):(this.times=t,this.values=e),this}clone(){const t=Jt.arraySlice(this.times,0),e=Jt.arraySlice(this.values,0),n=this.constructor,i=new n(this.name,t,e);return i.createInterpolant=this.createInterpolant,i}}an.prototype.TimeBufferType=Float32Array;an.prototype.ValueBufferType=Float32Array;an.prototype.DefaultInterpolation=Wr;class rs extends an{}rs.prototype.ValueTypeName="bool";rs.prototype.ValueBufferType=Array;rs.prototype.DefaultInterpolation=Vr;rs.prototype.InterpolantFactoryMethodLinear=void 0;rs.prototype.InterpolantFactoryMethodSmooth=void 0;class kh extends an{}kh.prototype.ValueTypeName="color";class Jr extends an{}Jr.prototype.ValueTypeName="number";class Sg extends zn{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t,e,n,i){const r=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=(n-e)/(i-e);let c=t*a;for(let h=c+a;c!==h;c+=4)Se.slerpFlat(r,0,o,c-a,o,c,l);return r}}class ar extends an{InterpolantFactoryMethodLinear(t){return new Sg(this.times,this.values,this.getValueSize(),t)}}ar.prototype.ValueTypeName="quaternion";ar.prototype.DefaultInterpolation=Wr;ar.prototype.InterpolantFactoryMethodSmooth=void 0;class os extends an{}os.prototype.ValueTypeName="string";os.prototype.ValueBufferType=Array;os.prototype.DefaultInterpolation=Vr;os.prototype.InterpolantFactoryMethodLinear=void 0;os.prototype.InterpolantFactoryMethodSmooth=void 0;class Zr extends an{}Zr.prototype.ValueTypeName="vector";class $r{constructor(t,e=-1,n,i=Ua){this.name=t,this.tracks=n,this.duration=e,this.blendMode=i,this.uuid=Ve(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],n=t.tracks,i=1/(t.fps||1);for(let o=0,a=n.length;o!==a;++o)e.push(rw(n[o]).scale(i));const r=new this(t.name,t.duration,e,t.blendMode);return r.uuid=t.uuid,r}static toJSON(t){const e=[],n=t.tracks,i={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let r=0,o=n.length;r!==o;++r)e.push(an.toJSON(n[r]));return i}static CreateFromMorphTargetSequence(t,e,n,i){const r=e.length,o=[];for(let a=0;a<r;a++){let l=[],c=[];l.push((a+r-1)%r,a,(a+1)%r),c.push(0,1,0);const h=Jt.getKeyframeOrder(l);l=Jt.sortedArray(l,1,h),c=Jt.sortedArray(c,1,h),!i&&l[0]===0&&(l.push(r),c.push(c[0])),o.push(new Jr(".morphTargetInfluences["+e[a].name+"]",l,c).scale(1/n))}return new this(t,-1,o)}static findByName(t,e){let n=t;if(!Array.isArray(t)){const i=t;n=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<n.length;i++)if(n[i].name===e)return n[i];return null}static CreateClipsFromMorphTargetSequences(t,e,n){const i={},r=/^([\w-]*?)([\d]+)$/;for(let a=0,l=t.length;a<l;a++){const c=t[a],h=c.name.match(r);if(h&&h.length>1){const u=h[1];let d=i[u];d||(i[u]=d=[]),d.push(c)}}const o=[];for(const a in i)o.push(this.CreateFromMorphTargetSequence(a,i[a],e,n));return o}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(u,d,f,p,m){if(f.length!==0){const y=[],g=[];Jt.flattenJSON(f,y,g,p),y.length!==0&&m.push(new u(d,y,g))}},i=[],r=t.name||"default",o=t.fps||30,a=t.blendMode;let l=t.length||-1;const c=t.hierarchy||[];for(let u=0;u<c.length;u++){const d=c[u].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const f={};let p;for(p=0;p<d.length;p++)if(d[p].morphTargets)for(let m=0;m<d[p].morphTargets.length;m++)f[d[p].morphTargets[m]]=-1;for(const m in f){const y=[],g=[];for(let x=0;x!==d[p].morphTargets.length;++x){const v=d[p];y.push(v.time),g.push(v.morphTarget===m?1:0)}i.push(new Jr(".morphTargetInfluence["+m+"]",y,g))}l=f.length*o}else{const f=".bones["+e[u].name+"]";n(Zr,f+".position",d,"pos",i),n(ar,f+".quaternion",d,"rot",i),n(Zr,f+".scale",d,"scl",i)}}return i.length===0?null:new this(r,l,i,a)}resetDuration(){const t=this.tracks;let e=0;for(let n=0,i=t.length;n!==i;++n){const r=this.tracks[n];e=Math.max(e,r.times[r.times.length-1])}return this.duration=e,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function sw(s){switch(s.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Jr;case"vector":case"vector2":case"vector3":case"vector4":return Zr;case"color":return kh;case"quaternion":return ar;case"bool":case"boolean":return rs;case"string":return os}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+s)}function rw(s){if(s.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=sw(s.type);if(s.times===void 0){const e=[],n=[];Jt.flattenJSON(s.keys,e,n,"value"),s.times=e,s.values=n}return t.parse!==void 0?t.parse(s):new t(s.name,s.times,s.values,s.interpolation)}const Zi={enabled:!1,files:{},add:function(s,t){this.enabled!==!1&&(this.files[s]=t)},get:function(s){if(this.enabled!==!1)return this.files[s]},remove:function(s){delete this.files[s]},clear:function(){this.files={}}};class Bh{constructor(t,e,n){const i=this;let r=!1,o=0,a=0,l;const c=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n,this.itemStart=function(h){a++,r===!1&&i.onStart!==void 0&&i.onStart(h,o,a),r=!0},this.itemEnd=function(h){o++,i.onProgress!==void 0&&i.onProgress(h,o,a),o===a&&(r=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(h){i.onError!==void 0&&i.onError(h)},this.resolveURL=function(h){return l?l(h):h},this.setURLModifier=function(h){return l=h,this},this.addHandler=function(h,u){return c.push(h,u),this},this.removeHandler=function(h){const u=c.indexOf(h);return u!==-1&&c.splice(u,2),this},this.getHandler=function(h){for(let u=0,d=c.length;u<d;u+=2){const f=c[u],p=c[u+1];if(f.global&&(f.lastIndex=0),f.test(h))return p}return null}}}const Tg=new Bh;class Ie{constructor(t){this.manager=t!==void 0?t:Tg,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const n=this;return new Promise(function(i,r){n.load(t,i,e,r)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}const Qe={};class rn extends Ie{constructor(t){super(t)}load(t,e,n,i){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,o=Zi.get(t);if(o!==void 0)return r.manager.itemStart(t),setTimeout(function(){e&&e(o),r.manager.itemEnd(t)},0),o;if(Qe[t]!==void 0){Qe[t].push({onLoad:e,onProgress:n,onError:i});return}const a=/^data:(.*?)(;base64)?,(.*)$/,l=t.match(a);let c;if(l){const h=l[1],u=!!l[2];let d=l[3];d=decodeURIComponent(d),u&&(d=atob(d));try{let f;const p=(this.responseType||"").toLowerCase();switch(p){case"arraybuffer":case"blob":const m=new Uint8Array(d.length);for(let g=0;g<d.length;g++)m[g]=d.charCodeAt(g);p==="blob"?f=new Blob([m.buffer],{type:h}):f=m.buffer;break;case"document":f=new DOMParser().parseFromString(d,h);break;case"json":f=JSON.parse(d);break;default:f=d;break}setTimeout(function(){e&&e(f),r.manager.itemEnd(t)},0)}catch(f){setTimeout(function(){i&&i(f),r.manager.itemError(t),r.manager.itemEnd(t)},0)}}else{Qe[t]=[],Qe[t].push({onLoad:e,onProgress:n,onError:i}),c=new XMLHttpRequest,c.open("GET",t,!0),c.addEventListener("load",function(h){const u=this.response,d=Qe[t];if(delete Qe[t],this.status===200||this.status===0){this.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),Zi.add(t,u);for(let f=0,p=d.length;f<p;f++){const m=d[f];m.onLoad&&m.onLoad(u)}r.manager.itemEnd(t)}else{for(let f=0,p=d.length;f<p;f++){const m=d[f];m.onError&&m.onError(h)}r.manager.itemError(t),r.manager.itemEnd(t)}},!1),c.addEventListener("progress",function(h){const u=Qe[t];for(let d=0,f=u.length;d<f;d++){const p=u[d];p.onProgress&&p.onProgress(h)}},!1),c.addEventListener("error",function(h){const u=Qe[t];delete Qe[t];for(let d=0,f=u.length;d<f;d++){const p=u[d];p.onError&&p.onError(h)}r.manager.itemError(t),r.manager.itemEnd(t)},!1),c.addEventListener("abort",function(h){const u=Qe[t];delete Qe[t];for(let d=0,f=u.length;d<f;d++){const p=u[d];p.onError&&p.onError(h)}r.manager.itemError(t),r.manager.itemEnd(t)},!1),this.responseType!==void 0&&(c.responseType=this.responseType),this.withCredentials!==void 0&&(c.withCredentials=this.withCredentials),c.overrideMimeType&&c.overrideMimeType(this.mimeType!==void 0?this.mimeType:"text/plain");for(const h in this.requestHeader)c.setRequestHeader(h,this.requestHeader[h]);c.send(null)}return r.manager.itemStart(t),c}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class ow extends Ie{constructor(t){super(t)}load(t,e,n,i){const r=this,o=new rn(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(t,function(a){try{e(r.parse(JSON.parse(a)))}catch(l){i?i(l):console.error(l),r.manager.itemError(t)}},n,i)}parse(t){const e=[];for(let n=0;n<t.length;n++){const i=$r.parse(t[n]);e.push(i)}return e}}class aw extends Ie{constructor(t){super(t)}load(t,e,n,i){const r=this,o=[],a=new xh,l=new rn(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(r.withCredentials);let c=0;function h(u){l.load(t[u],function(d){const f=r.parse(d,!0);o[u]={width:f.width,height:f.height,format:f.format,mipmaps:f.mipmaps},c+=1,c===6&&(f.mipmapCount===1&&(a.minFilter=he),a.image=o,a.format=f.format,a.needsUpdate=!0,e&&e(a))},n,i)}if(Array.isArray(t))for(let u=0,d=t.length;u<d;++u)h(u);else l.load(t,function(u){const d=r.parse(u,!0);if(d.isCubemap){const f=d.mipmaps.length/d.mipmapCount;for(let p=0;p<f;p++){o[p]={mipmaps:[]};for(let m=0;m<d.mipmapCount;m++)o[p].mipmaps.push(d.mipmaps[p*d.mipmapCount+m]),o[p].format=d.format,o[p].width=d.width,o[p].height=d.height}a.image=o}else a.image.width=d.width,a.image.height=d.height,a.mipmaps=d.mipmaps;d.mipmapCount===1&&(a.minFilter=he),a.format=d.format,a.needsUpdate=!0,e&&e(a)},n,i);return a}}class Kr extends Ie{constructor(t){super(t)}load(t,e,n,i){this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,o=Zi.get(t);if(o!==void 0)return r.manager.itemStart(t),setTimeout(function(){e&&e(o),r.manager.itemEnd(t)},0),o;const a=document.createElementNS("http://www.w3.org/1999/xhtml","img");function l(){a.removeEventListener("load",l,!1),a.removeEventListener("error",c,!1),Zi.add(t,this),e&&e(this),r.manager.itemEnd(t)}function c(h){a.removeEventListener("load",l,!1),a.removeEventListener("error",c,!1),i&&i(h),r.manager.itemError(t),r.manager.itemEnd(t)}return a.addEventListener("load",l,!1),a.addEventListener("error",c,!1),t.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(a.crossOrigin=this.crossOrigin),r.manager.itemStart(t),a.src=t,a}}class Eg extends Ie{constructor(t){super(t)}load(t,e,n,i){const r=new sr,o=new Kr(this.manager);o.setCrossOrigin(this.crossOrigin),o.setPath(this.path);let a=0;function l(c){o.load(t[c],function(h){r.images[c]=h,a++,a===6&&(r.needsUpdate=!0,e&&e(r))},void 0,i)}for(let c=0;c<t.length;++c)l(c);return r}}class Ag extends Ie{constructor(t){super(t)}load(t,e,n,i){const r=this,o=new Ni,a=new rn(this.manager);return a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setPath(this.path),a.setWithCredentials(r.withCredentials),a.load(t,function(l){const c=r.parse(l);c&&(c.image!==void 0?o.image=c.image:c.data!==void 0&&(o.image.width=c.width,o.image.height=c.height,o.image.data=c.data),o.wrapS=c.wrapS!==void 0?c.wrapS:we,o.wrapT=c.wrapT!==void 0?c.wrapT:we,o.magFilter=c.magFilter!==void 0?c.magFilter:he,o.minFilter=c.minFilter!==void 0?c.minFilter:he,o.anisotropy=c.anisotropy!==void 0?c.anisotropy:1,c.encoding!==void 0&&(o.encoding=c.encoding),c.flipY!==void 0&&(o.flipY=c.flipY),c.format!==void 0&&(o.format=c.format),c.type!==void 0&&(o.type=c.type),c.mipmaps!==void 0&&(o.mipmaps=c.mipmaps,o.minFilter=Qi),c.mipmapCount===1&&(o.minFilter=he),c.generateMipmaps!==void 0&&(o.generateMipmaps=c.generateMipmaps),o.needsUpdate=!0,e&&e(o,c))},n,i),o}}class Lg extends Ie{constructor(t){super(t)}load(t,e,n,i){const r=new fe,o=new Kr(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(t,function(a){r.image=a;const l=t.search(/\.jpe?g($|\?)/i)>0||t.search(/^data\:image\/jpeg/)===0;r.format=l?Fn:Fe,r.needsUpdate=!0,e!==void 0&&e(r)},n,i),r}}class Cg extends We{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new xo(e,t))}getPoint(t){const e=t*this.getLength(),n=this.getCurveLengths();let i=0;for(;i<n.length;){if(n[i]>=e){const r=n[i]-e,o=this.curves[i],a=o.getLength(),l=a===0?0:1-r/a;return o.getPointAt(l)}i++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let n=0,i=this.curves.length;n<i;n++)e+=this.curves[n].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let n;for(let i=0,r=this.curves;i<r.length;i++){const o=r[i],a=o&&o.isEllipseCurve?t*2:o&&(o.isLineCurve||o.isLineCurve3)?1:o&&o.isSplineCurve?t*o.points.length:t,l=o.getPoints(a);for(let c=0;c<l.length;c++){const h=l[c];n&&n.equals(h)||(e.push(h),n=h)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const i=t.curves[e];this.curves.push(i.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,n=this.curves.length;e<n;e++){const i=this.curves[e];t.curves.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const i=t.curves[e];this.curves.push(new Sh[i.type]().fromJSON(i))}return this}}class Qr extends Cg{constructor(t){super(),this.type="Path",this.currentPoint=new j,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,n=t.length;e<n;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const n=new xo(this.currentPoint.clone(),new j(t,e));return this.curves.push(n),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,n,i){const r=new il(this.currentPoint.clone(),new j(t,e),new j(n,i));return this.curves.push(r),this.currentPoint.set(n,i),this}bezierCurveTo(t,e,n,i,r,o){const a=new nl(this.currentPoint.clone(),new j(t,e),new j(n,i),new j(r,o));return this.curves.push(a),this.currentPoint.set(r,o),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),n=new sl(e);return this.curves.push(n),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,n,i,r,o){const a=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(t+a,e+l,n,i,r,o),this}absarc(t,e,n,i,r,o){return this.absellipse(t,e,n,n,i,r,o),this}ellipse(t,e,n,i,r,o,a,l){const c=this.currentPoint.x,h=this.currentPoint.y;return this.absellipse(t+c,e+h,n,i,r,o,a,l),this}absellipse(t,e,n,i,r,o,a,l){const c=new go(t,e,n,i,r,o,a,l);if(this.curves.length>0){const u=c.getPoint(0);u.equals(this.currentPoint)||this.lineTo(u.x,u.y)}this.curves.push(c);const h=c.getPoint(1);return this.currentPoint.copy(h),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class ri extends Qr{constructor(t){super(t),this.uuid=Ve(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let n=0,i=this.holes.length;n<i;n++)e[n]=this.holes[n].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const i=t.holes[e];this.holes.push(i.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,n=this.holes.length;e<n;e++){const i=this.holes[e];t.holes.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const i=t.holes[e];this.holes.push(new Qr().fromJSON(i))}return this}}class on extends It{constructor(t,e=1){super(),this.type="Light",this.color=new it(t),this.intensity=e}dispose(){}copy(t){return super.copy(t),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),e}}on.prototype.isLight=!0;class Oh extends on{constructor(t,e,n){super(t,n),this.type="HemisphereLight",this.position.copy(It.DefaultUp),this.updateMatrix(),this.groundColor=new it(e)}copy(t){return on.prototype.copy.call(this,t),this.groundColor.copy(t.groundColor),this}}Oh.prototype.isHemisphereLight=!0;const bd=new ft,Md=new S,wd=new S;class zh{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new j(512,512),this.map=null,this.mapPass=null,this.matrix=new ft,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new ho,this._frameExtents=new j(1,1),this._viewportCount=1,this._viewports=[new Xt(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,n=this.matrix;Md.setFromMatrixPosition(t.matrixWorld),e.position.copy(Md),wd.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(wd),e.updateMatrixWorld(),bd.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(bd),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(e.projectionMatrix),n.multiply(e.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class Rg extends zh{constructor(){super(new ge(50,1,.5,500)),this.focus=1}updateMatrices(t){const e=this.camera,n=Xr*2*t.angle*this.focus,i=this.mapSize.width/this.mapSize.height,r=t.distance||e.far;(n!==e.fov||i!==e.aspect||r!==e.far)&&(e.fov=n,e.aspect=i,e.far=r,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}Rg.prototype.isSpotLightShadow=!0;class Nh extends on{constructor(t,e,n=0,i=Math.PI/3,r=0,o=1){super(t,e),this.type="SpotLight",this.position.copy(It.DefaultUp),this.updateMatrix(),this.target=new It,this.distance=n,this.angle=i,this.penumbra=r,this.decay=o,this.shadow=new Rg}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}Nh.prototype.isSpotLight=!0;const Sd=new ft,_r=new S,Ql=new S;class Pg extends zh{constructor(){super(new ge(90,1,.5,500)),this._frameExtents=new j(4,2),this._viewportCount=6,this._viewports=[new Xt(2,1,1,1),new Xt(0,1,1,1),new Xt(3,1,1,1),new Xt(1,1,1,1),new Xt(3,0,1,1),new Xt(1,0,1,1)],this._cubeDirections=[new S(1,0,0),new S(-1,0,0),new S(0,0,1),new S(0,0,-1),new S(0,1,0),new S(0,-1,0)],this._cubeUps=[new S(0,1,0),new S(0,1,0),new S(0,1,0),new S(0,1,0),new S(0,0,1),new S(0,0,-1)]}updateMatrices(t,e=0){const n=this.camera,i=this.matrix,r=t.distance||n.far;r!==n.far&&(n.far=r,n.updateProjectionMatrix()),_r.setFromMatrixPosition(t.matrixWorld),n.position.copy(_r),Ql.copy(n.position),Ql.add(this._cubeDirections[e]),n.up.copy(this._cubeUps[e]),n.lookAt(Ql),n.updateMatrixWorld(),i.makeTranslation(-_r.x,-_r.y,-_r.z),Sd.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Sd)}}Pg.prototype.isPointLightShadow=!0;class Hh extends on{constructor(t,e,n=0,i=1){super(t,e),this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new Pg}get power(){return this.intensity*4*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}Hh.prototype.isPointLight=!0;class Dg extends zh{constructor(){super(new uo(-5,5,5,-5,.5,500))}}Dg.prototype.isDirectionalLightShadow=!0;class Uh extends on{constructor(t,e){super(t,e),this.type="DirectionalLight",this.position.copy(It.DefaultUp),this.updateMatrix(),this.target=new It,this.shadow=new Dg}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}Uh.prototype.isDirectionalLight=!0;class Vh extends on{constructor(t,e){super(t,e),this.type="AmbientLight"}}Vh.prototype.isAmbientLight=!0;class Wh extends on{constructor(t,e,n=10,i=10){super(t,e),this.type="RectAreaLight",this.width=n,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}Wh.prototype.isRectAreaLight=!0;class Gh{constructor(){this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new S)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const n=t.x,i=t.y,r=t.z,o=this.coefficients;return e.copy(o[0]).multiplyScalar(.282095),e.addScaledVector(o[1],.488603*i),e.addScaledVector(o[2],.488603*r),e.addScaledVector(o[3],.488603*n),e.addScaledVector(o[4],1.092548*(n*i)),e.addScaledVector(o[5],1.092548*(i*r)),e.addScaledVector(o[6],.315392*(3*r*r-1)),e.addScaledVector(o[7],1.092548*(n*r)),e.addScaledVector(o[8],.546274*(n*n-i*i)),e}getIrradianceAt(t,e){const n=t.x,i=t.y,r=t.z,o=this.coefficients;return e.copy(o[0]).multiplyScalar(.886227),e.addScaledVector(o[1],2*.511664*i),e.addScaledVector(o[2],2*.511664*r),e.addScaledVector(o[3],2*.511664*n),e.addScaledVector(o[4],2*.429043*n*i),e.addScaledVector(o[5],2*.429043*i*r),e.addScaledVector(o[6],.743125*r*r-.247708),e.addScaledVector(o[7],2*.429043*n*r),e.addScaledVector(o[8],.429043*(n*n-i*i)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(t.coefficients[n],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let n=0;n<9;n++)this.coefficients[n].lerp(t.coefficients[n],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(t,e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(t,e+i*3);return this}toArray(t=[],e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(t,e+i*3);return t}static getBasisAt(t,e){const n=t.x,i=t.y,r=t.z;e[0]=.282095,e[1]=.488603*i,e[2]=.488603*r,e[3]=.488603*n,e[4]=1.092548*n*i,e[5]=1.092548*i*r,e[6]=.315392*(3*r*r-1),e[7]=1.092548*n*r,e[8]=.546274*(n*n-i*i)}}Gh.prototype.isSphericalHarmonics3=!0;class yo extends on{constructor(t=new Gh,e=1){super(void 0,e),this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}yo.prototype.isLightProbe=!0;class Ig extends Ie{constructor(t){super(t),this.textures={}}load(t,e,n,i){const r=this,o=new rn(r.manager);o.setPath(r.path),o.setRequestHeader(r.requestHeader),o.setWithCredentials(r.withCredentials),o.load(t,function(a){try{e(r.parse(JSON.parse(a)))}catch(l){i?i(l):console.error(l),r.manager.itemError(t)}},n,i)}parse(t){const e=this.textures;function n(r){return e[r]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",r),e[r]}const i=new iw[t.type];if(t.uuid!==void 0&&(i.uuid=t.uuid),t.name!==void 0&&(i.name=t.name),t.color!==void 0&&i.color!==void 0&&i.color.setHex(t.color),t.roughness!==void 0&&(i.roughness=t.roughness),t.metalness!==void 0&&(i.metalness=t.metalness),t.sheenTint!==void 0&&(i.sheenTint=new it().setHex(t.sheenTint)),t.emissive!==void 0&&i.emissive!==void 0&&i.emissive.setHex(t.emissive),t.specular!==void 0&&i.specular!==void 0&&i.specular.setHex(t.specular),t.specularIntensity!==void 0&&(i.specularIntensity=t.specularIntensity),t.specularTint!==void 0&&i.specularTint!==void 0&&i.specularTint.setHex(t.specularTint),t.shininess!==void 0&&(i.shininess=t.shininess),t.clearcoat!==void 0&&(i.clearcoat=t.clearcoat),t.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=t.clearcoatRoughness),t.transmission!==void 0&&(i.transmission=t.transmission),t.thickness!==void 0&&(i.thickness=t.thickness),t.attenuationDistance!==void 0&&(i.attenuationDistance=t.attenuationDistance),t.attenuationTint!==void 0&&i.attenuationTint!==void 0&&i.attenuationTint.setHex(t.attenuationTint),t.fog!==void 0&&(i.fog=t.fog),t.flatShading!==void 0&&(i.flatShading=t.flatShading),t.blending!==void 0&&(i.blending=t.blending),t.combine!==void 0&&(i.combine=t.combine),t.side!==void 0&&(i.side=t.side),t.shadowSide!==void 0&&(i.shadowSide=t.shadowSide),t.opacity!==void 0&&(i.opacity=t.opacity),t.format!==void 0&&(i.format=t.format),t.transparent!==void 0&&(i.transparent=t.transparent),t.alphaTest!==void 0&&(i.alphaTest=t.alphaTest),t.depthTest!==void 0&&(i.depthTest=t.depthTest),t.depthWrite!==void 0&&(i.depthWrite=t.depthWrite),t.colorWrite!==void 0&&(i.colorWrite=t.colorWrite),t.stencilWrite!==void 0&&(i.stencilWrite=t.stencilWrite),t.stencilWriteMask!==void 0&&(i.stencilWriteMask=t.stencilWriteMask),t.stencilFunc!==void 0&&(i.stencilFunc=t.stencilFunc),t.stencilRef!==void 0&&(i.stencilRef=t.stencilRef),t.stencilFuncMask!==void 0&&(i.stencilFuncMask=t.stencilFuncMask),t.stencilFail!==void 0&&(i.stencilFail=t.stencilFail),t.stencilZFail!==void 0&&(i.stencilZFail=t.stencilZFail),t.stencilZPass!==void 0&&(i.stencilZPass=t.stencilZPass),t.wireframe!==void 0&&(i.wireframe=t.wireframe),t.wireframeLinewidth!==void 0&&(i.wireframeLinewidth=t.wireframeLinewidth),t.wireframeLinecap!==void 0&&(i.wireframeLinecap=t.wireframeLinecap),t.wireframeLinejoin!==void 0&&(i.wireframeLinejoin=t.wireframeLinejoin),t.rotation!==void 0&&(i.rotation=t.rotation),t.linewidth!==1&&(i.linewidth=t.linewidth),t.dashSize!==void 0&&(i.dashSize=t.dashSize),t.gapSize!==void 0&&(i.gapSize=t.gapSize),t.scale!==void 0&&(i.scale=t.scale),t.polygonOffset!==void 0&&(i.polygonOffset=t.polygonOffset),t.polygonOffsetFactor!==void 0&&(i.polygonOffsetFactor=t.polygonOffsetFactor),t.polygonOffsetUnits!==void 0&&(i.polygonOffsetUnits=t.polygonOffsetUnits),t.dithering!==void 0&&(i.dithering=t.dithering),t.alphaToCoverage!==void 0&&(i.alphaToCoverage=t.alphaToCoverage),t.premultipliedAlpha!==void 0&&(i.premultipliedAlpha=t.premultipliedAlpha),t.visible!==void 0&&(i.visible=t.visible),t.toneMapped!==void 0&&(i.toneMapped=t.toneMapped),t.userData!==void 0&&(i.userData=t.userData),t.vertexColors!==void 0&&(typeof t.vertexColors=="number"?i.vertexColors=t.vertexColors>0:i.vertexColors=t.vertexColors),t.uniforms!==void 0)for(const r in t.uniforms){const o=t.uniforms[r];switch(i.uniforms[r]={},o.type){case"t":i.uniforms[r].value=n(o.value);break;case"c":i.uniforms[r].value=new it().setHex(o.value);break;case"v2":i.uniforms[r].value=new j().fromArray(o.value);break;case"v3":i.uniforms[r].value=new S().fromArray(o.value);break;case"v4":i.uniforms[r].value=new Xt().fromArray(o.value);break;case"m3":i.uniforms[r].value=new ue().fromArray(o.value);break;case"m4":i.uniforms[r].value=new ft().fromArray(o.value);break;default:i.uniforms[r].value=o.value}}if(t.defines!==void 0&&(i.defines=t.defines),t.vertexShader!==void 0&&(i.vertexShader=t.vertexShader),t.fragmentShader!==void 0&&(i.fragmentShader=t.fragmentShader),t.extensions!==void 0)for(const r in t.extensions)i.extensions[r]=t.extensions[r];if(t.shading!==void 0&&(i.flatShading=t.shading===1),t.size!==void 0&&(i.size=t.size),t.sizeAttenuation!==void 0&&(i.sizeAttenuation=t.sizeAttenuation),t.map!==void 0&&(i.map=n(t.map)),t.matcap!==void 0&&(i.matcap=n(t.matcap)),t.alphaMap!==void 0&&(i.alphaMap=n(t.alphaMap)),t.bumpMap!==void 0&&(i.bumpMap=n(t.bumpMap)),t.bumpScale!==void 0&&(i.bumpScale=t.bumpScale),t.normalMap!==void 0&&(i.normalMap=n(t.normalMap)),t.normalMapType!==void 0&&(i.normalMapType=t.normalMapType),t.normalScale!==void 0){let r=t.normalScale;Array.isArray(r)===!1&&(r=[r,r]),i.normalScale=new j().fromArray(r)}return t.displacementMap!==void 0&&(i.displacementMap=n(t.displacementMap)),t.displacementScale!==void 0&&(i.displacementScale=t.displacementScale),t.displacementBias!==void 0&&(i.displacementBias=t.displacementBias),t.roughnessMap!==void 0&&(i.roughnessMap=n(t.roughnessMap)),t.metalnessMap!==void 0&&(i.metalnessMap=n(t.metalnessMap)),t.emissiveMap!==void 0&&(i.emissiveMap=n(t.emissiveMap)),t.emissiveIntensity!==void 0&&(i.emissiveIntensity=t.emissiveIntensity),t.specularMap!==void 0&&(i.specularMap=n(t.specularMap)),t.specularIntensityMap!==void 0&&(i.specularIntensityMap=n(t.specularIntensityMap)),t.specularTintMap!==void 0&&(i.specularTintMap=n(t.specularTintMap)),t.envMap!==void 0&&(i.envMap=n(t.envMap)),t.envMapIntensity!==void 0&&(i.envMapIntensity=t.envMapIntensity),t.reflectivity!==void 0&&(i.reflectivity=t.reflectivity),t.refractionRatio!==void 0&&(i.refractionRatio=t.refractionRatio),t.lightMap!==void 0&&(i.lightMap=n(t.lightMap)),t.lightMapIntensity!==void 0&&(i.lightMapIntensity=t.lightMapIntensity),t.aoMap!==void 0&&(i.aoMap=n(t.aoMap)),t.aoMapIntensity!==void 0&&(i.aoMapIntensity=t.aoMapIntensity),t.gradientMap!==void 0&&(i.gradientMap=n(t.gradientMap)),t.clearcoatMap!==void 0&&(i.clearcoatMap=n(t.clearcoatMap)),t.clearcoatRoughnessMap!==void 0&&(i.clearcoatRoughnessMap=n(t.clearcoatRoughnessMap)),t.clearcoatNormalMap!==void 0&&(i.clearcoatNormalMap=n(t.clearcoatNormalMap)),t.clearcoatNormalScale!==void 0&&(i.clearcoatNormalScale=new j().fromArray(t.clearcoatNormalScale)),t.transmissionMap!==void 0&&(i.transmissionMap=n(t.transmissionMap)),t.thicknessMap!==void 0&&(i.thicknessMap=n(t.thicknessMap)),i}setTextures(t){return this.textures=t,this}}class Da{static decodeText(t){if(typeof TextDecoder<"u")return new TextDecoder().decode(t);let e="";for(let n=0,i=t.length;n<i;n++)e+=String.fromCharCode(t[n]);try{return decodeURIComponent(escape(e))}catch{return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return e===-1?"./":t.substr(0,e+1)}}class Xh extends bt{constructor(){super(),this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){const t=super.toJSON(this);return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}Xh.prototype.isInstancedBufferGeometry=!0;class Fg extends Ie{constructor(t){super(t)}load(t,e,n,i){const r=this,o=new rn(r.manager);o.setPath(r.path),o.setRequestHeader(r.requestHeader),o.setWithCredentials(r.withCredentials),o.load(t,function(a){try{e(r.parse(JSON.parse(a)))}catch(l){i?i(l):console.error(l),r.manager.itemError(t)}},n,i)}parse(t){const e={},n={};function i(f,p){if(e[p]!==void 0)return e[p];const y=f.interleavedBuffers[p],g=r(f,y.buffer),x=Ds(y.type,g),v=new is(x,y.stride);return v.uuid=y.uuid,e[p]=v,v}function r(f,p){if(n[p]!==void 0)return n[p];const y=f.arrayBuffers[p],g=new Uint32Array(y).buffer;return n[p]=g,g}const o=t.isInstancedBufferGeometry?new Xh:new bt,a=t.data.index;if(a!==void 0){const f=Ds(a.type,a.array);o.setIndex(new Nt(f,1))}const l=t.data.attributes;for(const f in l){const p=l[f];let m;if(p.isInterleavedBufferAttribute){const y=i(t.data,p.data);m=new ai(y,p.itemSize,p.offset,p.normalized)}else{const y=Ds(p.type,p.array),g=p.isInstancedBufferAttribute?qi:Nt;m=new g(y,p.itemSize,p.normalized)}p.name!==void 0&&(m.name=p.name),p.usage!==void 0&&m.setUsage(p.usage),p.updateRange!==void 0&&(m.updateRange.offset=p.updateRange.offset,m.updateRange.count=p.updateRange.count),o.setAttribute(f,m)}const c=t.data.morphAttributes;if(c)for(const f in c){const p=c[f],m=[];for(let y=0,g=p.length;y<g;y++){const x=p[y];let v;if(x.isInterleavedBufferAttribute){const _=i(t.data,x.data);v=new ai(_,x.itemSize,x.offset,x.normalized)}else{const _=Ds(x.type,x.array);v=new Nt(_,x.itemSize,x.normalized)}x.name!==void 0&&(v.name=x.name),m.push(v)}o.morphAttributes[f]=m}t.data.morphTargetsRelative&&(o.morphTargetsRelative=!0);const u=t.data.groups||t.data.drawcalls||t.data.offsets;if(u!==void 0)for(let f=0,p=u.length;f!==p;++f){const m=u[f];o.addGroup(m.start,m.count,m.materialIndex)}const d=t.data.boundingSphere;if(d!==void 0){const f=new S;d.center!==void 0&&f.fromArray(d.center),o.boundingSphere=new fi(f,d.radius)}return t.name&&(o.name=t.name),t.userData&&(o.userData=t.userData),o}}class lw extends Ie{constructor(t){super(t)}load(t,e,n,i){const r=this,o=this.path===""?Da.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||o;const a=new rn(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,function(l){let c=null;try{c=JSON.parse(l)}catch(u){i!==void 0&&i(u),console.error("THREE:ObjectLoader: Can't parse "+t+".",u.message);return}const h=c.metadata;if(h===void 0||h.type===void 0||h.type.toLowerCase()==="geometry"){console.error("THREE.ObjectLoader: Can't load "+t);return}r.parse(c,e)},n,i)}async loadAsync(t,e){const n=this,i=this.path===""?Da.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||i;const r=new rn(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials);const o=await r.loadAsync(t,e),a=JSON.parse(o),l=a.metadata;if(l===void 0||l.type===void 0||l.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+t);return await n.parseAsync(a)}parse(t,e){const n=this.parseAnimations(t.animations),i=this.parseShapes(t.shapes),r=this.parseGeometries(t.geometries,i),o=this.parseImages(t.images,function(){e!==void 0&&e(c)}),a=this.parseTextures(t.textures,o),l=this.parseMaterials(t.materials,a),c=this.parseObject(t.object,r,l,a,n),h=this.parseSkeletons(t.skeletons,c);if(this.bindSkeletons(c,h),e!==void 0){let u=!1;for(const d in o)if(o[d]instanceof HTMLImageElement){u=!0;break}u===!1&&e(c)}return c}async parseAsync(t){const e=this.parseAnimations(t.animations),n=this.parseShapes(t.shapes),i=this.parseGeometries(t.geometries,n),r=await this.parseImagesAsync(t.images),o=this.parseTextures(t.textures,r),a=this.parseMaterials(t.materials,o),l=this.parseObject(t.object,i,a,o,e),c=this.parseSkeletons(t.skeletons,l);return this.bindSkeletons(l,c),l}parseShapes(t){const e={};if(t!==void 0)for(let n=0,i=t.length;n<i;n++){const r=new ri().fromJSON(t[n]);e[r.uuid]=r}return e}parseSkeletons(t,e){const n={},i={};if(e.traverse(function(r){r.isBone&&(i[r.uuid]=r)}),t!==void 0)for(let r=0,o=t.length;r<o;r++){const a=new el().fromJSON(t[r],i);n[a.uuid]=a}return n}parseGeometries(t,e){const n={};if(t!==void 0){const i=new Fg;for(let r=0,o=t.length;r<o;r++){let a;const l=t[r];switch(l.type){case"BufferGeometry":case"InstancedBufferGeometry":a=i.parse(l);break;case"Geometry":console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");break;default:l.type in vd?a=vd[l.type].fromJSON(l,e):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`)}a.uuid=l.uuid,l.name!==void 0&&(a.name=l.name),a.isBufferGeometry===!0&&l.userData!==void 0&&(a.userData=l.userData),n[l.uuid]=a}}return n}parseMaterials(t,e){const n={},i={};if(t!==void 0){const r=new Ig;r.setTextures(e);for(let o=0,a=t.length;o<a;o++){const l=t[o];if(l.type==="MultiMaterial"){const c=[];for(let h=0;h<l.materials.length;h++){const u=l.materials[h];n[u.uuid]===void 0&&(n[u.uuid]=r.parse(u)),c.push(n[u.uuid])}i[l.uuid]=c}else n[l.uuid]===void 0&&(n[l.uuid]=r.parse(l)),i[l.uuid]=n[l.uuid]}}return i}parseAnimations(t){const e={};if(t!==void 0)for(let n=0;n<t.length;n++){const i=t[n],r=$r.parse(i);e[r.uuid]=r}return e}parseImages(t,e){const n=this,i={};let r;function o(l){return n.manager.itemStart(l),r.load(l,function(){n.manager.itemEnd(l)},void 0,function(){n.manager.itemError(l),n.manager.itemEnd(l)})}function a(l){if(typeof l=="string"){const c=l,h=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(c)?c:n.resourcePath+c;return o(h)}else return l.data?{data:Ds(l.type,l.data),width:l.width,height:l.height}:null}if(t!==void 0&&t.length>0){const l=new Bh(e);r=new Kr(l),r.setCrossOrigin(this.crossOrigin);for(let c=0,h=t.length;c<h;c++){const u=t[c],d=u.url;if(Array.isArray(d)){i[u.uuid]=[];for(let f=0,p=d.length;f<p;f++){const m=d[f],y=a(m);y!==null&&(y instanceof HTMLImageElement?i[u.uuid].push(y):i[u.uuid].push(new Ni(y.data,y.width,y.height)))}}else{const f=a(u.url);f!==null&&(i[u.uuid]=f)}}}return i}async parseImagesAsync(t){const e=this,n={};let i;async function r(o){if(typeof o=="string"){const a=o,l=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(a)?a:e.resourcePath+a;return await i.loadAsync(l)}else return o.data?{data:Ds(o.type,o.data),width:o.width,height:o.height}:null}if(t!==void 0&&t.length>0){i=new Kr(this.manager),i.setCrossOrigin(this.crossOrigin);for(let o=0,a=t.length;o<a;o++){const l=t[o],c=l.url;if(Array.isArray(c)){n[l.uuid]=[];for(let h=0,u=c.length;h<u;h++){const d=c[h],f=await r(d);f!==null&&(f instanceof HTMLImageElement?n[l.uuid].push(f):n[l.uuid].push(new Ni(f.data,f.width,f.height)))}}else{const h=await r(l.url);h!==null&&(n[l.uuid]=h)}}}return n}parseTextures(t,e){function n(r,o){return typeof r=="number"?r:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",r),o[r])}const i={};if(t!==void 0)for(let r=0,o=t.length;r<o;r++){const a=t[r];a.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',a.uuid),e[a.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",a.image);let l;const c=e[a.image];Array.isArray(c)?(l=new sr(c),c.length===6&&(l.needsUpdate=!0)):(c&&c.data?l=new Ni(c.data,c.width,c.height):l=new fe(c),c&&(l.needsUpdate=!0)),l.uuid=a.uuid,a.name!==void 0&&(l.name=a.name),a.mapping!==void 0&&(l.mapping=n(a.mapping,cw)),a.offset!==void 0&&l.offset.fromArray(a.offset),a.repeat!==void 0&&l.repeat.fromArray(a.repeat),a.center!==void 0&&l.center.fromArray(a.center),a.rotation!==void 0&&(l.rotation=a.rotation),a.wrap!==void 0&&(l.wrapS=n(a.wrap[0],Td),l.wrapT=n(a.wrap[1],Td)),a.format!==void 0&&(l.format=a.format),a.type!==void 0&&(l.type=a.type),a.encoding!==void 0&&(l.encoding=a.encoding),a.minFilter!==void 0&&(l.minFilter=n(a.minFilter,Ed)),a.magFilter!==void 0&&(l.magFilter=n(a.magFilter,Ed)),a.anisotropy!==void 0&&(l.anisotropy=a.anisotropy),a.flipY!==void 0&&(l.flipY=a.flipY),a.premultiplyAlpha!==void 0&&(l.premultiplyAlpha=a.premultiplyAlpha),a.unpackAlignment!==void 0&&(l.unpackAlignment=a.unpackAlignment),i[a.uuid]=l}return i}parseObject(t,e,n,i,r){let o;function a(d){return e[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",d),e[d]}function l(d){if(d!==void 0){if(Array.isArray(d)){const f=[];for(let p=0,m=d.length;p<m;p++){const y=d[p];n[y]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",y),f.push(n[y])}return f}return n[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",d),n[d]}}function c(d){return i[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",d),i[d]}let h,u;switch(t.type){case"Scene":o=new Za,t.background!==void 0&&(Number.isInteger(t.background)?o.background=new it(t.background):o.background=c(t.background)),t.environment!==void 0&&(o.environment=c(t.environment)),t.fog!==void 0&&(t.fog.type==="Fog"?o.fog=new po(t.fog.color,t.fog.near,t.fog.far):t.fog.type==="FogExp2"&&(o.fog=new fo(t.fog.color,t.fog.density)));break;case"PerspectiveCamera":o=new ge(t.fov,t.aspect,t.near,t.far),t.focus!==void 0&&(o.focus=t.focus),t.zoom!==void 0&&(o.zoom=t.zoom),t.filmGauge!==void 0&&(o.filmGauge=t.filmGauge),t.filmOffset!==void 0&&(o.filmOffset=t.filmOffset),t.view!==void 0&&(o.view=Object.assign({},t.view));break;case"OrthographicCamera":o=new uo(t.left,t.right,t.top,t.bottom,t.near,t.far),t.zoom!==void 0&&(o.zoom=t.zoom),t.view!==void 0&&(o.view=Object.assign({},t.view));break;case"AmbientLight":o=new Vh(t.color,t.intensity);break;case"DirectionalLight":o=new Uh(t.color,t.intensity);break;case"PointLight":o=new Hh(t.color,t.intensity,t.distance,t.decay);break;case"RectAreaLight":o=new Wh(t.color,t.intensity,t.width,t.height);break;case"SpotLight":o=new Nh(t.color,t.intensity,t.distance,t.angle,t.penumbra,t.decay);break;case"HemisphereLight":o=new Oh(t.color,t.groundColor,t.intensity);break;case"LightProbe":o=new yo().fromJSON(t);break;case"SkinnedMesh":h=a(t.geometry),u=l(t.material),o=new Qa(h,u),t.bindMode!==void 0&&(o.bindMode=t.bindMode),t.bindMatrix!==void 0&&o.bindMatrix.fromArray(t.bindMatrix),t.skeleton!==void 0&&(o.skeleton=t.skeleton);break;case"Mesh":h=a(t.geometry),u=l(t.material),o=new ce(h,u);break;case"InstancedMesh":h=a(t.geometry),u=l(t.material);const d=t.count,f=t.instanceMatrix,p=t.instanceColor;o=new mh(h,u,d),o.instanceMatrix=new qi(new Float32Array(f.array),16),p!==void 0&&(o.instanceColor=new qi(new Float32Array(p.array),p.itemSize));break;case"LOD":o=new pg;break;case"Line":o=new On(a(t.geometry),l(t.material));break;case"LineLoop":o=new gh(a(t.geometry),l(t.material));break;case"LineSegments":o=new Ne(a(t.geometry),l(t.material));break;case"PointCloud":case"Points":o=new mo(a(t.geometry),l(t.material));break;case"Sprite":o=new Ka(l(t.material));break;case"Group":o=new Fi;break;case"Bone":o=new tl;break;default:o=new It}if(o.uuid=t.uuid,t.name!==void 0&&(o.name=t.name),t.matrix!==void 0?(o.matrix.fromArray(t.matrix),t.matrixAutoUpdate!==void 0&&(o.matrixAutoUpdate=t.matrixAutoUpdate),o.matrixAutoUpdate&&o.matrix.decompose(o.position,o.quaternion,o.scale)):(t.position!==void 0&&o.position.fromArray(t.position),t.rotation!==void 0&&o.rotation.fromArray(t.rotation),t.quaternion!==void 0&&o.quaternion.fromArray(t.quaternion),t.scale!==void 0&&o.scale.fromArray(t.scale)),t.castShadow!==void 0&&(o.castShadow=t.castShadow),t.receiveShadow!==void 0&&(o.receiveShadow=t.receiveShadow),t.shadow&&(t.shadow.bias!==void 0&&(o.shadow.bias=t.shadow.bias),t.shadow.normalBias!==void 0&&(o.shadow.normalBias=t.shadow.normalBias),t.shadow.radius!==void 0&&(o.shadow.radius=t.shadow.radius),t.shadow.mapSize!==void 0&&o.shadow.mapSize.fromArray(t.shadow.mapSize),t.shadow.camera!==void 0&&(o.shadow.camera=this.parseObject(t.shadow.camera))),t.visible!==void 0&&(o.visible=t.visible),t.frustumCulled!==void 0&&(o.frustumCulled=t.frustumCulled),t.renderOrder!==void 0&&(o.renderOrder=t.renderOrder),t.userData!==void 0&&(o.userData=t.userData),t.layers!==void 0&&(o.layers.mask=t.layers),t.children!==void 0){const d=t.children;for(let f=0;f<d.length;f++)o.add(this.parseObject(d[f],e,n,i,r))}if(t.animations!==void 0){const d=t.animations;for(let f=0;f<d.length;f++){const p=d[f];o.animations.push(r[p])}}if(t.type==="LOD"){t.autoUpdate!==void 0&&(o.autoUpdate=t.autoUpdate);const d=t.levels;for(let f=0;f<d.length;f++){const p=d[f],m=o.getObjectByProperty("uuid",p.object);m!==void 0&&o.addLevel(m,p.distance)}}return o}bindSkeletons(t,e){Object.keys(e).length!==0&&t.traverse(function(n){if(n.isSkinnedMesh===!0&&n.skeleton!==void 0){const i=e[n.skeleton];i===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",n.skeleton):n.bind(i,n.bindMatrix)}})}setTexturePath(t){return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),this.setResourcePath(t)}}const cw={UVMapping:Ha,CubeReflectionMapping:er,CubeRefractionMapping:nr,EquirectangularReflectionMapping:Or,EquirectangularRefractionMapping:zr,CubeUVReflectionMapping:ir,CubeUVRefractionMapping:ao},Td={RepeatWrapping:Nr,ClampToEdgeWrapping:we,MirroredRepeatWrapping:Hr},Ed={NearestFilter:le,NearestMipmapNearestFilter:La,NearestMipmapLinearFilter:Ca,LinearFilter:he,LinearMipmapNearestFilter:nh,LinearMipmapLinearFilter:Qi};class kg extends Ie{constructor(t){super(t),typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,n,i){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,o=Zi.get(t);if(o!==void 0)return r.manager.itemStart(t),setTimeout(function(){e&&e(o),r.manager.itemEnd(t)},0),o;const a={};a.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",a.headers=this.requestHeader,fetch(t,a).then(function(l){return l.blob()}).then(function(l){return createImageBitmap(l,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(l){Zi.add(t,l),e&&e(l),r.manager.itemEnd(t)}).catch(function(l){i&&i(l),r.manager.itemError(t),r.manager.itemEnd(t)}),r.manager.itemStart(t)}}kg.prototype.isImageBitmapLoader=!0;class Bg{constructor(){this.type="ShapePath",this.color=new it,this.subPaths=[],this.currentPath=null}moveTo(t,e){return this.currentPath=new Qr,this.subPaths.push(this.currentPath),this.currentPath.moveTo(t,e),this}lineTo(t,e){return this.currentPath.lineTo(t,e),this}quadraticCurveTo(t,e,n,i){return this.currentPath.quadraticCurveTo(t,e,n,i),this}bezierCurveTo(t,e,n,i,r,o){return this.currentPath.bezierCurveTo(t,e,n,i,r,o),this}splineThru(t){return this.currentPath.splineThru(t),this}toShapes(t,e){function n(x){const v=[];for(let _=0,M=x.length;_<M;_++){const w=x[_],b=new ri;b.curves=w.curves,v.push(b)}return v}function i(x,v){const _=v.length;let M=!1;for(let w=_-1,b=0;b<_;w=b++){let E=v[w],P=v[b],R=P.x-E.x,C=P.y-E.y;if(Math.abs(C)>Number.EPSILON){if(C<0&&(E=v[b],R=-R,P=v[w],C=-C),x.y<E.y||x.y>P.y)continue;if(x.y===E.y){if(x.x===E.x)return!0}else{const U=C*(x.x-E.x)-R*(x.y-E.y);if(U===0)return!0;if(U<0)continue;M=!M}}else{if(x.y!==E.y)continue;if(P.x<=x.x&&x.x<=E.x||E.x<=x.x&&x.x<=P.x)return!0}}return M}const r=mn.isClockWise,o=this.subPaths;if(o.length===0)return[];if(e===!0)return n(o);let a,l,c;const h=[];if(o.length===1)return l=o[0],c=new ri,c.curves=l.curves,h.push(c),h;let u=!r(o[0].getPoints());u=t?!u:u;const d=[],f=[];let p=[],m=0,y;f[m]=void 0,p[m]=[];for(let x=0,v=o.length;x<v;x++)l=o[x],y=l.getPoints(),a=r(y),a=t?!a:a,a?(!u&&f[m]&&m++,f[m]={s:new ri,p:y},f[m].s.curves=l.curves,u&&m++,p[m]=[]):p[m].push({h:l,p:y[0]});if(!f[0])return n(o);if(f.length>1){let x=!1;const v=[];for(let _=0,M=f.length;_<M;_++)d[_]=[];for(let _=0,M=f.length;_<M;_++){const w=p[_];for(let b=0;b<w.length;b++){const E=w[b];let P=!0;for(let R=0;R<f.length;R++)i(E.p,f[R].p)&&(_!==R&&v.push({froms:_,tos:R,hole:b}),P?(P=!1,d[R].push(E)):x=!0);P&&d[_].push(E)}}v.length>0&&(x||(p=d))}let g;for(let x=0,v=f.length;x<v;x++){c=f[x].s,h.push(c),g=p[x];for(let _=0,M=g.length;_<M;_++)c.holes.push(g[_].h)}return h}}class qh{constructor(t){this.type="Font",this.data=t}generateShapes(t,e=100){const n=[],i=hw(t,e,this.data);for(let r=0,o=i.length;r<o;r++)Array.prototype.push.apply(n,i[r].toShapes());return n}}function hw(s,t,e){const n=Array.from(s),i=t/e.resolution,r=(e.boundingBox.yMax-e.boundingBox.yMin+e.underlineThickness)*i,o=[];let a=0,l=0;for(let c=0;c<n.length;c++){const h=n[c];if(h===`
`)a=0,l-=r;else{const u=uw(h,i,a,l,e);a+=u.offsetX,o.push(u.path)}}return o}function uw(s,t,e,n,i){const r=i.glyphs[s]||i.glyphs["?"];if(!r){console.error('THREE.Font: character "'+s+'" does not exists in font family '+i.familyName+".");return}const o=new Bg;let a,l,c,h,u,d,f,p;if(r.o){const m=r._cachedOutline||(r._cachedOutline=r.o.split(" "));for(let y=0,g=m.length;y<g;)switch(m[y++]){case"m":a=m[y++]*t+e,l=m[y++]*t+n,o.moveTo(a,l);break;case"l":a=m[y++]*t+e,l=m[y++]*t+n,o.lineTo(a,l);break;case"q":c=m[y++]*t+e,h=m[y++]*t+n,u=m[y++]*t+e,d=m[y++]*t+n,o.quadraticCurveTo(u,d,c,h);break;case"b":c=m[y++]*t+e,h=m[y++]*t+n,u=m[y++]*t+e,d=m[y++]*t+n,f=m[y++]*t+e,p=m[y++]*t+n,o.bezierCurveTo(u,d,f,p,c,h);break}}return{offsetX:r.ha*t,path:o}}qh.prototype.isFont=!0;class dw extends Ie{constructor(t){super(t)}load(t,e,n,i){const r=this,o=new rn(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(r.withCredentials),o.load(t,function(a){let l;try{l=JSON.parse(a)}catch{console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),l=JSON.parse(a.substring(65,a.length-2))}const c=r.parse(l);e&&e(c)},n,i)}parse(t){return new qh(t)}}let ea;const Yh={getContext:function(){return ea===void 0&&(ea=new(window.AudioContext||window.webkitAudioContext)),ea},setContext:function(s){ea=s}};class Og extends Ie{constructor(t){super(t)}load(t,e,n,i){const r=this,o=new rn(this.manager);o.setResponseType("arraybuffer"),o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(t,function(a){try{const l=a.slice(0);Yh.getContext().decodeAudioData(l,function(h){e(h)})}catch(l){i?i(l):console.error(l),r.manager.itemError(t)}},n,i)}}class zg extends yo{constructor(t,e,n=1){super(void 0,n);const i=new it().set(t),r=new it().set(e),o=new S(i.r,i.g,i.b),a=new S(r.r,r.g,r.b),l=Math.sqrt(Math.PI),c=l*Math.sqrt(.75);this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l),this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c)}}zg.prototype.isHemisphereLightProbe=!0;class Ng extends yo{constructor(t,e=1){super(void 0,e);const n=new it().set(t);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}Ng.prototype.isAmbientLightProbe=!0;const Ad=new ft,Ld=new ft;class fw{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new ge,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new ge,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(t){const e=this._cache;if(e.focus!==t.focus||e.fov!==t.fov||e.aspect!==t.aspect*this.aspect||e.near!==t.near||e.far!==t.far||e.zoom!==t.zoom||e.eyeSep!==this.eyeSep){e.focus=t.focus,e.fov=t.fov,e.aspect=t.aspect*this.aspect,e.near=t.near,e.far=t.far,e.zoom=t.zoom,e.eyeSep=this.eyeSep;const i=t.projectionMatrix.clone(),r=e.eyeSep/2,o=r*e.near/e.focus,a=e.near*Math.tan(zi*e.fov*.5)/e.zoom;let l,c;Ld.elements[12]=-r,Ad.elements[12]=r,l=-a*e.aspect+o,c=a*e.aspect+o,i.elements[0]=2*e.near/(c-l),i.elements[8]=(c+l)/(c-l),this.cameraL.projectionMatrix.copy(i),l=-a*e.aspect-o,c=a*e.aspect-o,i.elements[0]=2*e.near/(c-l),i.elements[8]=(c+l)/(c-l),this.cameraR.projectionMatrix.copy(i)}this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Ld),this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Ad)}}class Hg{constructor(t=!0){this.autoStart=t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=Cd(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=Cd();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}function Cd(){return(typeof performance>"u"?Date:performance).now()}const bi=new S,Rd=new Se,pw=new S,Mi=new S;class mw extends It{constructor(){super(),this.type="AudioListener",this.context=Yh.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new Hg}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(t){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=t,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}updateMatrixWorld(t){super.updateMatrixWorld(t);const e=this.context.listener,n=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(bi,Rd,pw),Mi.set(0,0,-1).applyQuaternion(Rd),e.positionX){const i=this.context.currentTime+this.timeDelta;e.positionX.linearRampToValueAtTime(bi.x,i),e.positionY.linearRampToValueAtTime(bi.y,i),e.positionZ.linearRampToValueAtTime(bi.z,i),e.forwardX.linearRampToValueAtTime(Mi.x,i),e.forwardY.linearRampToValueAtTime(Mi.y,i),e.forwardZ.linearRampToValueAtTime(Mi.z,i),e.upX.linearRampToValueAtTime(n.x,i),e.upY.linearRampToValueAtTime(n.y,i),e.upZ.linearRampToValueAtTime(n.z,i)}else e.setPosition(bi.x,bi.y,bi.z),e.setOrientation(Mi.x,Mi.y,Mi.z,n.x,n.y,n.z)}}class jh extends It{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(t){return t||(t=[]),this._connected===!0?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=t,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=t,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}const wi=new S,Pd=new Se,gw=new S,Si=new S;class xw extends jh{constructor(t){super(t),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(t){return this.panner.refDistance=t,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(t){return this.panner.rolloffFactor=t,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(t){return this.panner.distanceModel=t,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(t){return this.panner.maxDistance=t,this}setDirectionalCone(t,e,n){return this.panner.coneInnerAngle=t,this.panner.coneOuterAngle=e,this.panner.coneOuterGain=n,this}updateMatrixWorld(t){if(super.updateMatrixWorld(t),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(wi,Pd,gw),Si.set(0,0,1).applyQuaternion(Pd);const e=this.panner;if(e.positionX){const n=this.context.currentTime+this.listener.timeDelta;e.positionX.linearRampToValueAtTime(wi.x,n),e.positionY.linearRampToValueAtTime(wi.y,n),e.positionZ.linearRampToValueAtTime(wi.z,n),e.orientationX.linearRampToValueAtTime(Si.x,n),e.orientationY.linearRampToValueAtTime(Si.y,n),e.orientationZ.linearRampToValueAtTime(Si.z,n)}else e.setPosition(wi.x,wi.y,wi.z),e.setOrientation(Si.x,Si.y,Si.z)}}class Ug{constructor(t,e=2048){this.analyser=t.context.createAnalyser(),this.analyser.fftSize=e,this.data=new Uint8Array(this.analyser.frequencyBinCount),t.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let t=0;const e=this.getFrequencyData();for(let n=0;n<e.length;n++)t+=e[n];return t/e.length}}class Vg{constructor(t,e,n){this.binding=t,this.valueSize=n;let i,r,o;switch(e){case"quaternion":i=this._slerp,r=this._slerpAdditive,o=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(n*6),this._workIndex=5;break;case"string":case"bool":i=this._select,r=this._select,o=this._setAdditiveIdentityOther,this.buffer=new Array(n*5);break;default:i=this._lerp,r=this._lerpAdditive,o=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(n*5)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=r,this._setIdentity=o,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const n=this.buffer,i=this.valueSize,r=t*i+i;let o=this.cumulativeWeight;if(o===0){for(let a=0;a!==i;++a)n[r+a]=n[a];o=e}else{o+=e;const a=e/o;this._mixBufferRegion(n,r,0,a,i)}this.cumulativeWeight=o}accumulateAdditive(t){const e=this.buffer,n=this.valueSize,i=n*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(e,i,0,t,n),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,n=this.buffer,i=t*e+e,r=this.cumulativeWeight,o=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){const l=e*this._origIndex;this._mixBufferRegion(n,i,l,1-r,e)}o>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*e,1,e);for(let l=e,c=e+e;l!==c;++l)if(n[l]!==n[l+e]){a.setValue(n,i);break}}saveOriginalState(){const t=this.binding,e=this.buffer,n=this.valueSize,i=n*this._origIndex;t.getValue(e,i);for(let r=n,o=i;r!==o;++r)e[r]=e[i+r%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=this.valueSize*3;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let n=t;n<e;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[e+n]=this.buffer[t+n]}_select(t,e,n,i,r){if(i>=.5)for(let o=0;o!==r;++o)t[e+o]=t[n+o]}_slerp(t,e,n,i){Se.slerpFlat(t,e,t,e,t,n,i)}_slerpAdditive(t,e,n,i,r){const o=this._workIndex*r;Se.multiplyQuaternionsFlat(t,o,t,e,t,n),Se.slerpFlat(t,e,t,e,t,o,i)}_lerp(t,e,n,i,r){const o=1-i;for(let a=0;a!==r;++a){const l=e+a;t[l]=t[l]*o+t[n+a]*i}}_lerpAdditive(t,e,n,i,r){for(let o=0;o!==r;++o){const a=e+o;t[a]=t[a]+t[n+o]*i}}}const Jh="\\[\\]\\.:\\/",yw=new RegExp("["+Jh+"]","g"),Zh="[^"+Jh+"]",_w="[^"+Jh.replace("\\.","")+"]",vw=/((?:WC+[\/:])*)/.source.replace("WC",Zh),bw=/(WCOD+)?/.source.replace("WCOD",_w),Mw=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Zh),ww=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Zh),Sw=new RegExp("^"+vw+bw+Mw+ww+"$"),Tw=["material","materials","bones"];class Ew{constructor(t,e,n){const i=n||Ht.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,i)}getValue(t,e){this.bind();const n=this._targetGroup.nCachedObjects_,i=this._bindings[n];i!==void 0&&i.getValue(t,e)}setValue(t,e){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=n.length;i!==r;++i)n[i].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].unbind()}}class Ht{constructor(t,e,n){this.path=e,this.parsedPath=n||Ht.parseTrackName(e),this.node=Ht.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,n){return t&&t.isAnimationObjectGroup?new Ht.Composite(t,e,n):new Ht(t,e,n)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(yw,"")}static parseTrackName(t){const e=Sw.exec(t);if(!e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const n={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const r=n.nodeName.substring(i+1);Tw.indexOf(r)!==-1&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=r)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return n}static findNode(t,e){if(!e||e===""||e==="."||e===-1||e===t.name||e===t.uuid)return t;if(t.skeleton){const n=t.skeleton.getBoneByName(e);if(n!==void 0)return n}if(t.children){const n=function(r){for(let o=0;o<r.length;o++){const a=r[o];if(a.name===e||a.uuid===e)return a;const l=n(a.children);if(l)return l}return null},i=n(t.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)t[e++]=n[i]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,n=e.objectName,i=e.propertyName;let r=e.propertyIndex;if(t||(t=Ht.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(n){let c=e.objectIndex;switch(n){case"materials":if(!t.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}t=t.material.materials;break;case"bones":if(!t.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}t=t.skeleton.bones;for(let h=0;h<t.length;h++)if(t[h].name===c){c=h;break}break;default:if(t[n]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}t=t[n]}if(c!==void 0){if(t[c]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);return}t=t[c]}}const o=t[i];if(o===void 0){const c=e.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+c+"."+i+" but it wasn't found.",t);return}let a=this.Versioning.None;this.targetObject=t,t.needsUpdate!==void 0?a=this.Versioning.NeedsUpdate:t.matrixWorldNeedsUpdate!==void 0&&(a=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(r!==void 0){if(i==="morphTargetInfluences"){if(!t.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(t.geometry.isBufferGeometry){if(!t.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}t.morphTargetDictionary[r]!==void 0&&(r=t.morphTargetDictionary[r])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}l=this.BindingType.ArrayElement,this.resolvedProperty=o,this.propertyIndex=r}else o.fromArray!==void 0&&o.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=o):Array.isArray(o)?(l=this.BindingType.EntireArray,this.resolvedProperty=o):this.propertyName=i;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Ht.Composite=Ew;Ht.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};Ht.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};Ht.prototype.GetterByBindingType=[Ht.prototype._getValue_direct,Ht.prototype._getValue_array,Ht.prototype._getValue_arrayElement,Ht.prototype._getValue_toArray];Ht.prototype.SetterByBindingTypeAndVersioning=[[Ht.prototype._setValue_direct,Ht.prototype._setValue_direct_setNeedsUpdate,Ht.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Ht.prototype._setValue_array,Ht.prototype._setValue_array_setNeedsUpdate,Ht.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Ht.prototype._setValue_arrayElement,Ht.prototype._setValue_arrayElement_setNeedsUpdate,Ht.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Ht.prototype._setValue_fromArray,Ht.prototype._setValue_fromArray_setNeedsUpdate,Ht.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class Wg{constructor(){this.uuid=Ve(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const t={};this._indicesByUUID=t;for(let n=0,i=arguments.length;n!==i;++n)t[arguments[n].uuid]=n;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const e=this;this.stats={objects:{get total(){return e._objects.length},get inUse(){return this.total-e.nCachedObjects_}},get bindingsPerObject(){return e._bindings.length}}}add(){const t=this._objects,e=this._indicesByUUID,n=this._paths,i=this._parsedPaths,r=this._bindings,o=r.length;let a,l=t.length,c=this.nCachedObjects_;for(let h=0,u=arguments.length;h!==u;++h){const d=arguments[h],f=d.uuid;let p=e[f];if(p===void 0){p=l++,e[f]=p,t.push(d);for(let m=0,y=o;m!==y;++m)r[m].push(new Ht(d,n[m],i[m]))}else if(p<c){a=t[p];const m=--c,y=t[m];e[y.uuid]=p,t[p]=y,e[f]=m,t[m]=d;for(let g=0,x=o;g!==x;++g){const v=r[g],_=v[m];let M=v[p];v[p]=_,M===void 0&&(M=new Ht(d,n[g],i[g])),v[m]=M}}else t[p]!==a&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=c}remove(){const t=this._objects,e=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_;for(let o=0,a=arguments.length;o!==a;++o){const l=arguments[o],c=l.uuid,h=e[c];if(h!==void 0&&h>=r){const u=r++,d=t[u];e[d.uuid]=h,t[h]=d,e[c]=u,t[u]=l;for(let f=0,p=i;f!==p;++f){const m=n[f],y=m[u],g=m[h];m[h]=y,m[u]=g}}}this.nCachedObjects_=r}uncache(){const t=this._objects,e=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_,o=t.length;for(let a=0,l=arguments.length;a!==l;++a){const c=arguments[a],h=c.uuid,u=e[h];if(u!==void 0)if(delete e[h],u<r){const d=--r,f=t[d],p=--o,m=t[p];e[f.uuid]=u,t[u]=f,e[m.uuid]=d,t[d]=m,t.pop();for(let y=0,g=i;y!==g;++y){const x=n[y],v=x[d],_=x[p];x[u]=v,x[d]=_,x.pop()}}else{const d=--o,f=t[d];d>0&&(e[f.uuid]=u),t[u]=f,t.pop();for(let p=0,m=i;p!==m;++p){const y=n[p];y[u]=y[d],y.pop()}}}this.nCachedObjects_=r}subscribe_(t,e){const n=this._bindingsIndicesByPath;let i=n[t];const r=this._bindings;if(i!==void 0)return r[i];const o=this._paths,a=this._parsedPaths,l=this._objects,c=l.length,h=this.nCachedObjects_,u=new Array(c);i=r.length,n[t]=i,o.push(t),a.push(e),r.push(u);for(let d=h,f=l.length;d!==f;++d){const p=l[d];u[d]=new Ht(p,t,e)}return u}unsubscribe_(t){const e=this._bindingsIndicesByPath,n=e[t];if(n!==void 0){const i=this._paths,r=this._parsedPaths,o=this._bindings,a=o.length-1,l=o[a],c=t[a];e[c]=n,o[n]=l,o.pop(),r[n]=r[a],r.pop(),i[n]=i[a],i.pop()}}}Wg.prototype.isAnimationObjectGroup=!0;class Aw{constructor(t,e,n=null,i=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=n,this.blendMode=i;const r=e.tracks,o=r.length,a=new Array(o),l={endingStart:Di,endingEnd:Di};for(let c=0;c!==o;++c){const h=r[c].createInterpolant(null);a[c]=h,h.settings=l}this._interpolantSettings=l,this._interpolants=a,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=Dm,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,n){if(t.fadeOut(e),this.fadeIn(e),n){const i=this._clip.duration,r=t._clip.duration,o=r/i,a=i/r;t.warp(1,o,e),this.warp(a,1,e)}return this}crossFadeTo(t,e,n){return t.crossFadeFrom(this,e,n)}stopFading(){const t=this._weightInterpolant;return t!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,n){const i=this._mixer,r=i.time,o=this.timeScale;let a=this._timeScaleInterpolant;a===null&&(a=i._lendControlInterpolant(),this._timeScaleInterpolant=a);const l=a.parameterPositions,c=a.sampleValues;return l[0]=r,l[1]=r+n,c[0]=t/o,c[1]=e/o,this}stopWarping(){const t=this._timeScaleInterpolant;return t!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,n,i){if(!this.enabled){this._updateWeight(t);return}const r=this._startTime;if(r!==null){const l=(t-r)*n;if(l<0||n===0)return;this._startTime=null,e=n*l}e*=this._updateTimeScale(t);const o=this._updateTime(e),a=this._updateWeight(t);if(a>0){const l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case ih:for(let h=0,u=l.length;h!==u;++h)l[h].evaluate(o),c[h].accumulateAdditive(a);break;case Ua:default:for(let h=0,u=l.length;h!==u;++h)l[h].evaluate(o),c[h].accumulate(i,a)}}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const n=this._weightInterpolant;if(n!==null){const i=n.evaluate(t)[0];e*=i,t>n.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const n=this._timeScaleInterpolant;if(n!==null){const i=n.evaluate(t)[0];e*=i,t>n.parameterPositions[1]&&(this.stopWarping(),e===0?this.paused=!0:this.timeScale=e)}}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,n=this.loop;let i=this.time+t,r=this._loopCount;const o=n===Im;if(t===0)return r===-1?i:o&&(r&1)===1?e-i:i;if(n===Pm){r===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(i>=e)i=e;else if(i<0)i=0;else{this.time=i;break t}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(r===-1&&(t>=0?(r=0,this._setEndings(!0,this.repetitions===0,o)):this._setEndings(this.repetitions===0,!0,o)),i>=e||i<0){const a=Math.floor(i/e);i-=e*a,r+=Math.abs(a);const l=this.repetitions-r;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=t>0?e:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(l===1){const c=t<0;this._setEndings(c,!c,o)}else this._setEndings(!1,!1,o);this._loopCount=r,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:a})}}else this.time=i;if(o&&(r&1)===1)return e-i}return i}_setEndings(t,e,n){const i=this._interpolantSettings;n?(i.endingStart=Ii,i.endingEnd=Ii):(t?i.endingStart=this.zeroSlopeAtStart?Ii:Di:i.endingStart=Gr,e?i.endingEnd=this.zeroSlopeAtEnd?Ii:Di:i.endingEnd=Gr)}_scheduleFading(t,e,n){const i=this._mixer,r=i.time;let o=this._weightInterpolant;o===null&&(o=i._lendControlInterpolant(),this._weightInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=r,l[0]=e,a[1]=r+t,l[1]=n,this}}class Gg extends di{constructor(t){super(),this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const n=t._localRoot||this._root,i=t._clip.tracks,r=i.length,o=t._propertyBindings,a=t._interpolants,l=n.uuid,c=this._bindingsByRootAndName;let h=c[l];h===void 0&&(h={},c[l]=h);for(let u=0;u!==r;++u){const d=i[u],f=d.name;let p=h[f];if(p!==void 0)o[u]=p;else{if(p=o[u],p!==void 0){p._cacheIndex===null&&(++p.referenceCount,this._addInactiveBinding(p,l,f));continue}const m=e&&e._propertyBindings[u].binding.parsedPath;p=new Vg(Ht.create(n,f,m),d.ValueTypeName,d.getValueSize()),++p.referenceCount,this._addInactiveBinding(p,l,f),o[u]=p}a[u].resultBuffer=p.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(t._cacheIndex===null){const n=(t._localRoot||this._root).uuid,i=t._clip.uuid,r=this._actionsByClip[i];this._bindAction(t,r&&r.knownActions[0]),this._addInactiveAction(t,i,n)}const e=t._propertyBindings;for(let n=0,i=e.length;n!==i;++n){const r=e[n];r.useCount++===0&&(this._lendBinding(r),r.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let n=0,i=e.length;n!==i;++n){const r=e[n];--r.useCount===0&&(r.restoreOriginalState(),this._takeBackBinding(r))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return e!==null&&e<this._nActiveActions}_addInactiveAction(t,e,n){const i=this._actions,r=this._actionsByClip;let o=r[e];if(o===void 0)o={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,r[e]=o;else{const a=o.knownActions;t._byClipCacheIndex=a.length,a.push(t)}t._cacheIndex=i.length,i.push(t),o.actionByRoot[n]=t}_removeInactiveAction(t){const e=this._actions,n=e[e.length-1],i=t._cacheIndex;n._cacheIndex=i,e[i]=n,e.pop(),t._cacheIndex=null;const r=t._clip.uuid,o=this._actionsByClip,a=o[r],l=a.knownActions,c=l[l.length-1],h=t._byClipCacheIndex;c._byClipCacheIndex=h,l[h]=c,l.pop(),t._byClipCacheIndex=null;const u=a.actionByRoot,d=(t._localRoot||this._root).uuid;delete u[d],l.length===0&&delete o[r],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let n=0,i=e.length;n!==i;++n){const r=e[n];--r.referenceCount===0&&this._removeInactiveBinding(r)}}_lendAction(t){const e=this._actions,n=t._cacheIndex,i=this._nActiveActions++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_takeBackAction(t){const e=this._actions,n=t._cacheIndex,i=--this._nActiveActions,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_addInactiveBinding(t,e,n){const i=this._bindingsByRootAndName,r=this._bindings;let o=i[e];o===void 0&&(o={},i[e]=o),o[n]=t,t._cacheIndex=r.length,r.push(t)}_removeInactiveBinding(t){const e=this._bindings,n=t.binding,i=n.rootNode.uuid,r=n.path,o=this._bindingsByRootAndName,a=o[i],l=e[e.length-1],c=t._cacheIndex;l._cacheIndex=c,e[c]=l,e.pop(),delete a[r],Object.keys(a).length===0&&delete o[i]}_lendBinding(t){const e=this._bindings,n=t._cacheIndex,i=this._nActiveBindings++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_takeBackBinding(t){const e=this._bindings,n=t._cacheIndex,i=--this._nActiveBindings,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let n=t[e];return n===void 0&&(n=new Fh(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=e,t[e]=n),n}_takeBackControlInterpolant(t){const e=this._controlInterpolants,n=t.__cacheIndex,i=--this._nActiveControlInterpolants,r=e[i];t.__cacheIndex=i,e[i]=t,r.__cacheIndex=n,e[n]=r}clipAction(t,e,n){const i=e||this._root,r=i.uuid;let o=typeof t=="string"?$r.findByName(i,t):t;const a=o!==null?o.uuid:t,l=this._actionsByClip[a];let c=null;if(n===void 0&&(o!==null?n=o.blendMode:n=Ua),l!==void 0){const u=l.actionByRoot[r];if(u!==void 0&&u.blendMode===n)return u;c=l.knownActions[0],o===null&&(o=c._clip)}if(o===null)return null;const h=new Aw(this,o,e,n);return this._bindAction(h,c),this._addInactiveAction(h,a,r),h}existingAction(t,e){const n=e||this._root,i=n.uuid,r=typeof t=="string"?$r.findByName(n,t):t,o=r?r.uuid:t,a=this._actionsByClip[o];return a!==void 0&&a.actionByRoot[i]||null}stopAllAction(){const t=this._actions,e=this._nActiveActions;for(let n=e-1;n>=0;--n)t[n].stop();return this}update(t){t*=this.timeScale;const e=this._actions,n=this._nActiveActions,i=this.time+=t,r=Math.sign(t),o=this._accuIndex^=1;for(let c=0;c!==n;++c)e[c]._update(i,t,r,o);const a=this._bindings,l=this._nActiveBindings;for(let c=0;c!==l;++c)a[c].apply(o);return this}setTime(t){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,n=t.uuid,i=this._actionsByClip,r=i[n];if(r!==void 0){const o=r.knownActions;for(let a=0,l=o.length;a!==l;++a){const c=o[a];this._deactivateAction(c);const h=c._cacheIndex,u=e[e.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,u._cacheIndex=h,e[h]=u,e.pop(),this._removeInactiveBindingsForAction(c)}delete i[n]}}uncacheRoot(t){const e=t.uuid,n=this._actionsByClip;for(const o in n){const a=n[o].actionByRoot,l=a[e];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const i=this._bindingsByRootAndName,r=i[e];if(r!==void 0)for(const o in r){const a=r[o];a.restoreOriginalState(),this._removeInactiveBinding(a)}}uncacheAction(t,e){const n=this.existingAction(t,e);n!==null&&(this._deactivateAction(n),this._removeInactiveAction(n))}}Gg.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class al{constructor(t){typeof t=="string"&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),t=arguments[1]),this.value=t}clone(){return new al(this.value.clone===void 0?this.value:this.value.clone())}}class Xg extends is{constructor(t,e,n=1){super(t,e),this.meshPerAttribute=n}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}Xg.prototype.isInstancedInterleavedBuffer=!0;class qg{constructor(t,e,n,i,r){this.buffer=t,this.type=e,this.itemSize=n,this.elementSize=i,this.count=r,this.version=0}set needsUpdate(t){t===!0&&this.version++}setBuffer(t){return this.buffer=t,this}setType(t,e){return this.type=t,this.elementSize=e,this}setItemSize(t){return this.itemSize=t,this}setCount(t){return this.count=t,this}}qg.prototype.isGLBufferAttribute=!0;class Lw{constructor(t,e,n=0,i=1/0){this.ray=new pi(t,e),this.near=n,this.far=i,this.camera=null,this.layers=new ch,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(t,e){this.ray.set(t,e)}setFromCamera(t,e){e&&e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e&&e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)}intersectObject(t,e=!1,n=[]){return Nc(t,this,n,e),n.sort(Dd),n}intersectObjects(t,e=!1,n=[]){for(let i=0,r=t.length;i<r;i++)Nc(t[i],this,n,e);return n.sort(Dd),n}}function Dd(s,t){return s.distance-t.distance}function Nc(s,t,e,n){if(s.layers.test(t.layers)&&s.raycast(t,e),n===!0){const i=s.children;for(let r=0,o=i.length;r<o;r++)Nc(i[r],t,e,!0)}}class Cw{constructor(t=1,e=0,n=0){return this.radius=t,this.phi=e,this.theta=n,this}set(t,e,n){return this.radius=t,this.phi=e,this.theta=n,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+e*e+n*n),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,n),this.phi=Math.acos(Me(e/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class Rw{constructor(t=1,e=0,n=0){return this.radius=t,this.theta=e,this.y=n,this}set(t,e,n){return this.radius=t,this.theta=e,this.y=n,this}copy(t){return this.radius=t.radius,this.theta=t.theta,this.y=t.y,this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+n*n),this.theta=Math.atan2(t,n),this.y=e,this}clone(){return new this.constructor().copy(this)}}const Id=new j;class lr{constructor(t=new j(1/0,1/0),e=new j(-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=Id.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y)}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return Id.copy(t).clamp(this.min,this.max).sub(t).length()}intersect(t){return this.min.max(t.min),this.max.min(t.max),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}lr.prototype.isBox2=!0;const Fd=new S,na=new S;class Yg{constructor(t=new S,e=new S){this.start=t,this.end=e}set(t,e){return this.start.copy(t),this.end.copy(e),this}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,e){return this.delta(e).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,e){Fd.subVectors(t,this.start),na.subVectors(this.end,this.start);const n=na.dot(na);let r=na.dot(Fd)/n;return e&&(r=Me(r,0,1)),r}closestPointToPoint(t,e,n){const i=this.closestPointToPointParameter(t,e);return this.delta(n).multiplyScalar(i).add(this.start)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}class jg extends It{constructor(t){super(),this.material=t,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}}jg.prototype.isImmediateRenderObject=!0;const kd=new S;class Pw extends It{constructor(t,e){super(),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=e;const n=new bt,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let o=0,a=1,l=32;o<l;o++,a++){const c=o/l*Math.PI*2,h=a/l*Math.PI*2;i.push(Math.cos(c),Math.sin(c),1,Math.cos(h),Math.sin(h),1)}n.setAttribute("position",new at(i,3));const r=new _e({fog:!1,toneMapped:!1});this.cone=new Ne(n,r),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const t=this.light.distance?this.light.distance:1e3,e=t*Math.tan(this.light.angle);this.cone.scale.set(e,e,t),kd.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(kd),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const Kn=new S,ia=new ft,tc=new ft;class Jg extends Ne{constructor(t){const e=Zg(t),n=new bt,i=[],r=[],o=new it(0,0,1),a=new it(0,1,0);for(let c=0;c<e.length;c++){const h=e[c];h.parent&&h.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),r.push(o.r,o.g,o.b),r.push(a.r,a.g,a.b))}n.setAttribute("position",new at(i,3)),n.setAttribute("color",new at(r,3));const l=new _e({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(n,l),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const e=this.bones,n=this.geometry,i=n.getAttribute("position");tc.copy(this.root.matrixWorld).invert();for(let r=0,o=0;r<e.length;r++){const a=e[r];a.parent&&a.parent.isBone&&(ia.multiplyMatrices(tc,a.matrixWorld),Kn.setFromMatrixPosition(ia),i.setXYZ(o,Kn.x,Kn.y,Kn.z),ia.multiplyMatrices(tc,a.parent.matrixWorld),Kn.setFromMatrixPosition(ia),i.setXYZ(o+1,Kn.x,Kn.y,Kn.z),o+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}}function Zg(s){const t=[];s&&s.isBone&&t.push(s);for(let e=0;e<s.children.length;e++)t.push.apply(t,Zg(s.children[e]));return t}class Dw extends ce{constructor(t,e,n){const i=new Ji(e,4,2),r=new Nn({wireframe:!0,fog:!1,toneMapped:!1});super(i,r),this.light=t,this.light.updateMatrixWorld(),this.color=n,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const Iw=new S,Bd=new it,Od=new it;class Fw extends It{constructor(t,e,n){super(),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=n;const i=new Yi(e);i.rotateY(Math.PI*.5),this.material=new Nn({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const r=i.getAttribute("position"),o=new Float32Array(r.count*3);i.setAttribute("color",new Nt(o,3)),this.add(new ce(i,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const t=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const e=t.geometry.getAttribute("color");Bd.copy(this.light.color),Od.copy(this.light.groundColor);for(let n=0,i=e.count;n<i;n++){const r=n<i/2?Bd:Od;e.setXYZ(n,r.r,r.g,r.b)}e.needsUpdate=!0}t.lookAt(Iw.setFromMatrixPosition(this.light.matrixWorld).negate())}}class $g extends Ne{constructor(t=10,e=10,n=4473924,i=8947848){n=new it(n),i=new it(i);const r=e/2,o=t/e,a=t/2,l=[],c=[];for(let d=0,f=0,p=-a;d<=e;d++,p+=o){l.push(-a,0,p,a,0,p),l.push(p,0,-a,p,0,a);const m=d===r?n:i;m.toArray(c,f),f+=3,m.toArray(c,f),f+=3,m.toArray(c,f),f+=3,m.toArray(c,f),f+=3}const h=new bt;h.setAttribute("position",new at(l,3)),h.setAttribute("color",new at(c,3));const u=new _e({vertexColors:!0,toneMapped:!1});super(h,u),this.type="GridHelper"}}class kw extends Ne{constructor(t=10,e=16,n=8,i=64,r=4473924,o=8947848){r=new it(r),o=new it(o);const a=[],l=[];for(let u=0;u<=e;u++){const d=u/e*(Math.PI*2),f=Math.sin(d)*t,p=Math.cos(d)*t;a.push(0,0,0),a.push(f,0,p);const m=u&1?r:o;l.push(m.r,m.g,m.b),l.push(m.r,m.g,m.b)}for(let u=0;u<=n;u++){const d=u&1?r:o,f=t-t/n*u;for(let p=0;p<i;p++){let m=p/i*(Math.PI*2),y=Math.sin(m)*f,g=Math.cos(m)*f;a.push(y,0,g),l.push(d.r,d.g,d.b),m=(p+1)/i*(Math.PI*2),y=Math.sin(m)*f,g=Math.cos(m)*f,a.push(y,0,g),l.push(d.r,d.g,d.b)}}const c=new bt;c.setAttribute("position",new at(a,3)),c.setAttribute("color",new at(l,3));const h=new _e({vertexColors:!0,toneMapped:!1});super(c,h),this.type="PolarGridHelper"}}const zd=new S,sa=new S,Nd=new S;class Bw extends It{constructor(t,e,n){super(),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,e===void 0&&(e=1);let i=new bt;i.setAttribute("position",new at([-e,e,0,e,e,0,e,-e,0,-e,-e,0,-e,e,0],3));const r=new _e({fog:!1,toneMapped:!1});this.lightPlane=new On(i,r),this.add(this.lightPlane),i=new bt,i.setAttribute("position",new at([0,0,0,0,0,1],3)),this.targetLine=new On(i,r),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){zd.setFromMatrixPosition(this.light.matrixWorld),sa.setFromMatrixPosition(this.light.target.matrixWorld),Nd.subVectors(sa,zd),this.lightPlane.lookAt(sa),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(sa),this.targetLine.scale.z=Nd.length()}}const ra=new S,Qt=new co;class Ow extends Ne{constructor(t){const e=new bt,n=new _e({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],r=[],o={},a=new it(16755200),l=new it(16711680),c=new it(43775),h=new it(16777215),u=new it(3355443);d("n1","n2",a),d("n2","n4",a),d("n4","n3",a),d("n3","n1",a),d("f1","f2",a),d("f2","f4",a),d("f4","f3",a),d("f3","f1",a),d("n1","f1",a),d("n2","f2",a),d("n3","f3",a),d("n4","f4",a),d("p","n1",l),d("p","n2",l),d("p","n3",l),d("p","n4",l),d("u1","u2",c),d("u2","u3",c),d("u3","u1",c),d("c","t",h),d("p","c",u),d("cn1","cn2",u),d("cn3","cn4",u),d("cf1","cf2",u),d("cf3","cf4",u);function d(p,m,y){f(p,y),f(m,y)}function f(p,m){i.push(0,0,0),r.push(m.r,m.g,m.b),o[p]===void 0&&(o[p]=[]),o[p].push(i.length/3-1)}e.setAttribute("position",new at(i,3)),e.setAttribute("color",new at(r,3)),super(e,n),this.type="CameraHelper",this.camera=t,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=o,this.update()}update(){const t=this.geometry,e=this.pointMap,n=1,i=1;Qt.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),ie("c",e,t,Qt,0,0,-1),ie("t",e,t,Qt,0,0,1),ie("n1",e,t,Qt,-n,-i,-1),ie("n2",e,t,Qt,n,-i,-1),ie("n3",e,t,Qt,-n,i,-1),ie("n4",e,t,Qt,n,i,-1),ie("f1",e,t,Qt,-n,-i,1),ie("f2",e,t,Qt,n,-i,1),ie("f3",e,t,Qt,-n,i,1),ie("f4",e,t,Qt,n,i,1),ie("u1",e,t,Qt,n*.7,i*1.1,-1),ie("u2",e,t,Qt,-n*.7,i*1.1,-1),ie("u3",e,t,Qt,0,i*2,-1),ie("cf1",e,t,Qt,-n,0,1),ie("cf2",e,t,Qt,n,0,1),ie("cf3",e,t,Qt,0,-i,1),ie("cf4",e,t,Qt,0,i,1),ie("cn1",e,t,Qt,-n,0,-1),ie("cn2",e,t,Qt,n,0,-1),ie("cn3",e,t,Qt,0,-i,-1),ie("cn4",e,t,Qt,0,i,-1),t.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function ie(s,t,e,n,i,r,o){ra.set(i,r,o).unproject(n);const a=t[s];if(a!==void 0){const l=e.getAttribute("position");for(let c=0,h=a.length;c<h;c++)l.setXYZ(a[c],ra.x,ra.y,ra.z)}}const oa=new Ge;class Kg extends Ne{constructor(t,e=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(24),r=new bt;r.setIndex(new Nt(n,1)),r.setAttribute("position",new Nt(i,3)),super(r,new _e({color:e,toneMapped:!1})),this.object=t,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(t){if(t!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&oa.setFromObject(this.object),oa.isEmpty())return;const e=oa.min,n=oa.max,i=this.geometry.attributes.position,r=i.array;r[0]=n.x,r[1]=n.y,r[2]=n.z,r[3]=e.x,r[4]=n.y,r[5]=n.z,r[6]=e.x,r[7]=e.y,r[8]=n.z,r[9]=n.x,r[10]=e.y,r[11]=n.z,r[12]=n.x,r[13]=n.y,r[14]=e.z,r[15]=e.x,r[16]=n.y,r[17]=e.z,r[18]=e.x,r[19]=e.y,r[20]=e.z,r[21]=n.x,r[22]=e.y,r[23]=e.z,i.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(t){return this.object=t,this.update(),this}copy(t){return Ne.prototype.copy.call(this,t),this.object=t.object,this}}class zw extends Ne{constructor(t,e=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],r=new bt;r.setIndex(new Nt(n,1)),r.setAttribute("position",new at(i,3)),super(r,new _e({color:e,toneMapped:!1})),this.box=t,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(t){const e=this.box;e.isEmpty()||(e.getCenter(this.position),e.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(t))}}class Nw extends On{constructor(t,e=1,n=16776960){const i=n,r=[1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],o=new bt;o.setAttribute("position",new at(r,3)),o.computeBoundingSphere(),super(o,new _e({color:i,toneMapped:!1})),this.type="PlaneHelper",this.plane=t,this.size=e;const a=[1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],l=new bt;l.setAttribute("position",new at(a,3)),l.computeBoundingSphere(),this.add(new ce(l,new Nn({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(t){let e=-this.plane.constant;Math.abs(e)<1e-8&&(e=1e-8),this.scale.set(.5*this.size,.5*this.size,e),this.children[0].material.side=e<0?se:Vi,this.lookAt(this.plane.normal),super.updateMatrixWorld(t)}}const Hd=new S;let aa,ec;class Hw extends It{constructor(t=new S(0,0,1),e=new S(0,0,0),n=1,i=16776960,r=n*.2,o=r*.2){super(),this.type="ArrowHelper",aa===void 0&&(aa=new bt,aa.setAttribute("position",new at([0,0,0,0,1,0],3)),ec=new li(0,.5,1,5,1),ec.translate(0,-.5,0)),this.position.copy(e),this.line=new On(aa,new _e({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new ce(ec,new Nn({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(t),this.setLength(n,r,o)}setDirection(t){if(t.y>.99999)this.quaternion.set(0,0,0,1);else if(t.y<-.99999)this.quaternion.set(1,0,0,0);else{Hd.set(t.z,0,-t.x).normalize();const e=Math.acos(t.y);this.quaternion.setFromAxisAngle(Hd,e)}}setLength(t,e=t*.2,n=e*.2){this.line.scale.set(1,Math.max(1e-4,t-e),1),this.line.updateMatrix(),this.cone.scale.set(n,e,n),this.cone.position.y=t,this.cone.updateMatrix()}setColor(t){this.line.material.color.set(t),this.cone.material.color.set(t)}copy(t){return super.copy(t,!1),this.line.copy(t.line),this.cone.copy(t.cone),this}}class Qg extends Ne{constructor(t=1){const e=[0,0,0,t,0,0,0,0,0,0,t,0,0,0,0,0,0,t],n=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],i=new bt;i.setAttribute("position",new at(e,3)),i.setAttribute("color",new at(n,3));const r=new _e({vertexColors:!0,toneMapped:!1});super(i,r),this.type="AxesHelper"}setColors(t,e,n){const i=new it,r=this.geometry.attributes.color.array;return i.set(t),i.toArray(r,0),i.toArray(r,3),i.set(e),i.toArray(r,6),i.toArray(r,9),i.set(n),i.toArray(r,12),i.toArray(r,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}const tx=new Float32Array(1),Uw=new Int32Array(tx.buffer);class Vw{static toHalfFloat(t){tx[0]=t;const e=Uw[0];let n=e>>16&32768,i=e>>12&2047;const r=e>>23&255;return r<103?n:r>142?(n|=31744,n|=(r==255?0:1)&&e&8388607,n):r<113?(i|=2048,n|=(i>>114-r)+(i>>113-r&1),n):(n|=r-112<<10|i>>1,n+=i&1,n)}}const Ww=0,Gw=1,Xw=0,qw=1,Yw=2;function jw(s){return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),s}function Jw(s=[]){return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),s.isMultiMaterial=!0,s.materials=s,s.clone=function(){return s.slice()},s}function Zw(s,t){return console.warn("THREE.PointCloud has been renamed to THREE.Points."),new mo(s,t)}function $w(s){return console.warn("THREE.Particle has been renamed to THREE.Sprite."),new Ka(s)}function Kw(s,t){return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),new mo(s,t)}function Qw(s){return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),new ss(s)}function tS(s){return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),new ss(s)}function eS(s){return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),new ss(s)}function nS(s,t,e){return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),new S(s,t,e)}function iS(s,t){return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."),new Nt(s,t).setUsage(Hs)}function sS(s,t){return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),new Gm(s,t)}function rS(s,t){return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),new Xm(s,t)}function oS(s,t){return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),new qm(s,t)}function aS(s,t){return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),new Ym(s,t)}function lS(s,t){return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),new Ga(s,t)}function cS(s,t){return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),new jm(s,t)}function hS(s,t){return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),new Xa(s,t)}function uS(s,t){return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),new at(s,t)}function dS(s,t){return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),new Zm(s,t)}We.create=function(s,t){return console.log("THREE.Curve.create() has been deprecated"),s.prototype=Object.create(We.prototype),s.prototype.constructor=s,s.prototype.getPoint=t,s};Qr.prototype.fromPoints=function(s){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(s)};function fS(s){return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),new Qg(s)}function pS(s,t){return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),new Kg(s,t)}function mS(s,t){return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),new Ne(new yh(s.geometry),new _e({color:t!==void 0?t:16777215}))}$g.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};Jg.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};function gS(s,t){return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),new Ne(new Th(s.geometry),new _e({color:t!==void 0?t:16777215}))}Ie.prototype.extractUrlBase=function(s){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),Da.extractUrlBase(s)};Ie.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};function xS(s){return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),new rn(s)}function yS(s){return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),new Ag(s)}lr.prototype.center=function(s){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(s)};lr.prototype.empty=function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()};lr.prototype.isIntersectionBox=function(s){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(s)};lr.prototype.size=function(s){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(s)};Ge.prototype.center=function(s){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(s)};Ge.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()};Ge.prototype.isIntersectionBox=function(s){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(s)};Ge.prototype.isIntersectionSphere=function(s){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(s)};Ge.prototype.size=function(s){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(s)};fi.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()};ho.prototype.setFromMatrix=function(s){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(s)};Yg.prototype.center=function(s){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(s)};ue.prototype.flattenToArrayOffset=function(s,t){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(s,t)};ue.prototype.multiplyVector3=function(s){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),s.applyMatrix3(this)};ue.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")};ue.prototype.applyToBufferAttribute=function(s){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),s.applyMatrix3(this)};ue.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")};ue.prototype.getInverse=function(s){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(s).invert()};ft.prototype.extractPosition=function(s){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(s)};ft.prototype.flattenToArrayOffset=function(s,t){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(s,t)};ft.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new S().setFromMatrixColumn(this,3)};ft.prototype.setRotationFromQuaternion=function(s){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(s)};ft.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")};ft.prototype.multiplyVector3=function(s){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),s.applyMatrix4(this)};ft.prototype.multiplyVector4=function(s){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),s.applyMatrix4(this)};ft.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")};ft.prototype.rotateAxis=function(s){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),s.transformDirection(this)};ft.prototype.crossVector=function(s){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),s.applyMatrix4(this)};ft.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")};ft.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")};ft.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")};ft.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")};ft.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")};ft.prototype.applyToBufferAttribute=function(s){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),s.applyMatrix4(this)};ft.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")};ft.prototype.makeFrustum=function(s,t,e,n,i,r){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(s,t,n,e,i,r)};ft.prototype.getInverse=function(s){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(s).invert()};fn.prototype.isIntersectionLine=function(s){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(s)};Se.prototype.multiplyVector3=function(s){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),s.applyQuaternion(this)};Se.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()};pi.prototype.isIntersectionBox=function(s){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(s)};pi.prototype.isIntersectionPlane=function(s){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(s)};pi.prototype.isIntersectionSphere=function(s){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(s)};re.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()};re.prototype.barycoordFromPoint=function(s,t){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(s,t)};re.prototype.midpoint=function(s){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(s)};re.prototypenormal=function(s){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(s)};re.prototype.plane=function(s){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(s)};re.barycoordFromPoint=function(s,t,e,n,i){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),re.getBarycoord(s,t,e,n,i)};re.normal=function(s,t,e,n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),re.getNormal(s,t,e,n)};ri.prototype.extractAllPoints=function(s){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(s)};ri.prototype.extrude=function(s){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new sn(this,s)};ri.prototype.makeGeometry=function(s){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new ji(this,s)};j.prototype.fromAttribute=function(s,t,e){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(s,t,e)};j.prototype.distanceToManhattan=function(s){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(s)};j.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};S.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")};S.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")};S.prototype.getPositionFromMatrix=function(s){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(s)};S.prototype.getScaleFromMatrix=function(s){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(s)};S.prototype.getColumnFromMatrix=function(s,t){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(t,s)};S.prototype.applyProjection=function(s){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(s)};S.prototype.fromAttribute=function(s,t,e){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(s,t,e)};S.prototype.distanceToManhattan=function(s){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(s)};S.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};Xt.prototype.fromAttribute=function(s,t,e){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(s,t,e)};Xt.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};It.prototype.getChildByName=function(s){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(s)};It.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")};It.prototype.translate=function(s,t){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(t,s)};It.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")};It.prototype.applyMatrix=function(s){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(s)};Object.defineProperties(It.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(s){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=s}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});ce.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")};Object.defineProperties(ce.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),Fm},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});Qa.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};ge.prototype.setLens=function(s,t){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),t!==void 0&&(this.filmGauge=t),this.setFocalLength(s)};Object.defineProperties(on.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(s){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=s}},shadowCameraLeft:{set:function(s){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=s}},shadowCameraRight:{set:function(s){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=s}},shadowCameraTop:{set:function(s){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=s}},shadowCameraBottom:{set:function(s){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=s}},shadowCameraNear:{set:function(s){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=s}},shadowCameraFar:{set:function(s){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=s}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(s){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=s}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(s){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=s}},shadowMapHeight:{set:function(s){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=s}}});Object.defineProperties(Nt.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===Hs},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(Hs)}}});Nt.prototype.setDynamic=function(s){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(s===!0?Hs:Ns),this};Nt.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},Nt.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};bt.prototype.addIndex=function(s){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(s)};bt.prototype.addAttribute=function(s,t){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(t&&t.isBufferAttribute)&&!(t&&t.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(s,new Nt(arguments[1],arguments[2]))):s==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(t),this):this.setAttribute(s,t)};bt.prototype.addDrawCall=function(s,t,e){e!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(s,t)};bt.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()};bt.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")};bt.prototype.removeAttribute=function(s){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(s)};bt.prototype.applyMatrix=function(s){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(s)};Object.defineProperties(bt.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});is.prototype.setDynamic=function(s){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(s===!0?Hs:Ns),this};is.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};sn.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")};sn.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")};sn.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")};Za.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")};al.prototype.onUpdate=function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this};Object.defineProperties(ye.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new it}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(s){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=s===Qc}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(s){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=s}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}});Object.defineProperties(Bn.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(s){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=s}}});qt.prototype.clearTarget=function(s,t,e,n){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(s),this.clear(t,e,n)};qt.prototype.animate=function(s){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(s)};qt.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()};qt.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()};qt.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision};qt.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()};qt.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")};qt.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")};qt.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")};qt.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")};qt.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")};qt.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")};qt.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures};qt.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")};qt.prototype.enableScissorTest=function(s){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(s)};qt.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")};qt.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")};qt.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")};qt.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")};qt.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")};qt.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")};qt.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")};qt.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")};qt.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")};qt.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()};Object.defineProperties(qt.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(s){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=s}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(s){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=s}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(s){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=s===!0?lo:ke}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}});Object.defineProperties(hg.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});function _S(s,t,e){return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."),new Ya(s,e)}Object.defineProperties(nn.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(s){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=s}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(s){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=s}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(s){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=s}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(s){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=s}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(s){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=s}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(s){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=s}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(s){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=s}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(s){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=s}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(s){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=s}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(s){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=s}}});jh.prototype.load=function(s){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const t=this;return new Og().load(s,function(n){t.setBuffer(n)}),this};Ug.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()};qa.prototype.updateCubeMap=function(s,t){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(s,t)};qa.prototype.clear=function(s,t,e,n){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(s,t,e,n)};es.crossOrigin=void 0;es.loadTexture=function(s,t,e,n){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const i=new Lg;i.setCrossOrigin(this.crossOrigin);const r=i.load(s,e,void 0,n);return t&&(r.mapping=t),r};es.loadTextureCube=function(s,t,e,n){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const i=new Eg;i.setCrossOrigin(this.crossOrigin);const r=i.load(s,e,void 0,n);return t&&(r.mapping=t),r};es.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};es.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};function vS(){console.error("THREE.CanvasRenderer has been removed")}function bS(){console.error("THREE.JSONLoader has been removed.")}const MS={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},detach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")}};function wS(){console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:$c}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=$c);const SS=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:Op,AddEquation:Pi,AddOperation:Ip,AdditiveAnimationBlendMode:ih,AdditiveBlending:yc,AlphaFormat:Xp,AlwaysDepth:Ep,AlwaysStencilFunc:Nm,AmbientLight:Vh,AmbientLightProbe:Ng,AnimationClip:$r,AnimationLoader:ow,AnimationMixer:Gg,AnimationObjectGroup:Wg,AnimationUtils:Jt,ArcCurve:_h,ArrayCamera:ph,ArrowHelper:Hw,Audio:jh,AudioAnalyser:Ug,AudioContext:Yh,AudioListener:mw,AudioLoader:Og,AxesHelper:Qg,AxisHelper:fS,BackSide:se,BasicDepthPacking:Bm,BasicShadowMap:c0,BinaryTextureLoader:yS,Bone:tl,BooleanKeyframeTrack:rs,BoundingBoxHelper:pS,Box2:lr,Box3:Ge,Box3Helper:zw,BoxBufferGeometry:kn,BoxGeometry:kn,BoxHelper:Kg,BufferAttribute:Nt,BufferGeometry:bt,BufferGeometryLoader:Fg,ByteType:Np,Cache:Zi,Camera:co,CameraHelper:Ow,CanvasRenderer:vS,CanvasTexture:gg,CatmullRomCurve3:bh,CineonToneMapping:Bp,CircleBufferGeometry:Vs,CircleGeometry:Vs,ClampToEdgeWrapping:we,Clock:Hg,Color:it,ColorKeyframeTrack:kh,CompressedTexture:xh,CompressedTextureLoader:aw,ConeBufferGeometry:Ws,ConeGeometry:Ws,CubeCamera:qa,CubeReflectionMapping:er,CubeRefractionMapping:nr,CubeTexture:sr,CubeTextureLoader:Eg,CubeUVReflectionMapping:ir,CubeUVRefractionMapping:ao,CubicBezierCurve:nl,CubicBezierCurve3:Mh,CubicInterpolant:Mg,CullFaceBack:xc,CullFaceFront:up,CullFaceFrontBack:l0,CullFaceNone:hp,Curve:We,CurvePath:Cg,CustomBlending:fp,CustomToneMapping:zp,CylinderBufferGeometry:li,CylinderGeometry:li,Cylindrical:Rw,DataTexture:Ni,DataTexture2DArray:dh,DataTexture3D:fh,DataTextureLoader:Ag,DataUtils:Vw,DecrementStencilOp:v0,DecrementWrapStencilOp:M0,DefaultLoadingManager:Tg,DepthFormat:Oi,DepthStencilFormat:zs,DepthTexture:xg,DirectionalLight:Uh,DirectionalLightHelper:Bw,DiscreteInterpolant:wg,DodecahedronBufferGeometry:Gs,DodecahedronGeometry:Gs,DoubleSide:Wi,DstAlphaFactor:vp,DstColorFactor:Mp,DynamicBufferAttribute:iS,DynamicCopyUsage:B0,DynamicDrawUsage:Hs,DynamicReadUsage:I0,EdgesGeometry:yh,EdgesHelper:mS,EllipseCurve:go,EqualDepth:Lp,EqualStencilFunc:E0,EquirectangularReflectionMapping:Or,EquirectangularRefractionMapping:zr,Euler:ns,EventDispatcher:di,ExtrudeBufferGeometry:sn,ExtrudeGeometry:sn,FaceColors:qw,FileLoader:rn,FlatShading:Qc,Float16BufferAttribute:Jm,Float32Attribute:uS,Float32BufferAttribute:at,Float64Attribute:dS,Float64BufferAttribute:Zm,FloatType:Cn,Fog:po,FogExp2:fo,Font:qh,FontLoader:dw,FrontSide:Vi,Frustum:ho,GLBufferAttribute:qg,GLSL1:z0,GLSL3:Ic,GammaEncoding:Va,GreaterDepth:Rp,GreaterEqualDepth:Cp,GreaterEqualStencilFunc:R0,GreaterStencilFunc:L0,GridHelper:$g,Group:Fi,HalfFloatType:Bi,HemisphereLight:Oh,HemisphereLightHelper:Fw,HemisphereLightProbe:zg,IcosahedronBufferGeometry:Xs,IcosahedronGeometry:Xs,ImageBitmapLoader:kg,ImageLoader:Kr,ImageUtils:es,ImmediateRenderObject:jg,IncrementStencilOp:_0,IncrementWrapStencilOp:b0,InstancedBufferAttribute:qi,InstancedBufferGeometry:Xh,InstancedInterleavedBuffer:Xg,InstancedMesh:mh,Int16Attribute:aS,Int16BufferAttribute:Ym,Int32Attribute:cS,Int32BufferAttribute:jm,Int8Attribute:sS,Int8BufferAttribute:Gm,IntType:Up,InterleavedBuffer:is,InterleavedBufferAttribute:ai,Interpolant:zn,InterpolateDiscrete:Vr,InterpolateLinear:Wr,InterpolateSmooth:wa,InvertStencilOp:w0,JSONLoader:bS,KeepStencilOp:Sa,KeyframeTrack:an,LOD:pg,LatheBufferGeometry:qs,LatheGeometry:qs,Layers:ch,LensFlare:wS,LessDepth:Ap,LessEqualDepth:Aa,LessEqualStencilFunc:A0,LessStencilFunc:T0,Light:on,LightProbe:yo,Line:On,Line3:Yg,LineBasicMaterial:_e,LineCurve:xo,LineCurve3:yg,LineDashedMaterial:Ih,LineLoop:gh,LinePieces:Gw,LineSegments:Ne,LineStrip:Ww,LinearEncoding:ke,LinearFilter:he,LinearInterpolant:Fh,LinearMipMapLinearFilter:p0,LinearMipMapNearestFilter:f0,LinearMipmapLinearFilter:Qi,LinearMipmapNearestFilter:nh,LinearToneMapping:Fp,Loader:Ie,LoaderUtils:Da,LoadingManager:Bh,LogLuvEncoding:km,LoopOnce:Pm,LoopPingPong:Im,LoopRepeat:Dm,LuminanceAlphaFormat:Yp,LuminanceFormat:qp,MOUSE:o0,Material:ye,MaterialLoader:Ig,Math:_u,MathUtils:_u,Matrix3:ue,Matrix4:ft,MaxEquation:Mc,Mesh:ce,MeshBasicMaterial:Nn,MeshDepthMaterial:ja,MeshDistanceMaterial:Ja,MeshFaceMaterial:jw,MeshLambertMaterial:Ph,MeshMatcapMaterial:Dh,MeshNormalMaterial:Rh,MeshPhongMaterial:Lh,MeshPhysicalMaterial:Ah,MeshStandardMaterial:ol,MeshToonMaterial:Ch,MinEquation:bc,MirroredRepeatWrapping:Hr,MixOperation:Dp,MultiMaterial:Jw,MultiplyBlending:vc,MultiplyOperation:oo,NearestFilter:le,NearestMipMapLinearFilter:d0,NearestMipMapNearestFilter:u0,NearestMipmapLinearFilter:Ca,NearestMipmapNearestFilter:La,NeverDepth:Tp,NeverStencilFunc:S0,NoBlending:In,NoColors:Xw,NoToneMapping:ni,NormalAnimationBlendMode:Ua,NormalBlending:Fs,NotEqualDepth:Pp,NotEqualStencilFunc:C0,NumberKeyframeTrack:Jr,Object3D:It,ObjectLoader:lw,ObjectSpaceNormalMap:zm,OctahedronBufferGeometry:Yi,OctahedronGeometry:Yi,OneFactor:xp,OneMinusDstAlphaFactor:bp,OneMinusDstColorFactor:wp,OneMinusSrcAlphaFactor:eh,OneMinusSrcColorFactor:_p,OrthographicCamera:uo,PCFShadowMap:Kc,PCFSoftShadowMap:dp,PMREMGenerator:ng,ParametricBufferGeometry:Ra,ParametricGeometry:Ra,Particle:$w,ParticleBasicMaterial:tS,ParticleSystem:Kw,ParticleSystemMaterial:eS,Path:Qr,PerspectiveCamera:ge,Plane:fn,PlaneBufferGeometry:Xi,PlaneGeometry:Xi,PlaneHelper:Nw,PointCloud:Zw,PointCloudMaterial:Qw,PointLight:Hh,PointLightHelper:Dw,Points:mo,PointsMaterial:ss,PolarGridHelper:kw,PolyhedronBufferGeometry:xn,PolyhedronGeometry:xn,PositionalAudio:xw,PropertyBinding:Ht,PropertyMixer:Vg,QuadraticBezierCurve:il,QuadraticBezierCurve3:wh,Quaternion:Se,QuaternionKeyframeTrack:ar,QuaternionLinearInterpolant:Sg,REVISION:$c,RGBADepthPacking:Om,RGBAFormat:Fe,RGBAIntegerFormat:tm,RGBA_ASTC_10x10_Format:fm,RGBA_ASTC_10x5_Format:hm,RGBA_ASTC_10x6_Format:um,RGBA_ASTC_10x8_Format:dm,RGBA_ASTC_12x10_Format:pm,RGBA_ASTC_12x12_Format:mm,RGBA_ASTC_4x4_Format:nm,RGBA_ASTC_5x4_Format:im,RGBA_ASTC_5x5_Format:sm,RGBA_ASTC_6x5_Format:rm,RGBA_ASTC_6x6_Format:om,RGBA_ASTC_8x5_Format:am,RGBA_ASTC_8x6_Format:lm,RGBA_ASTC_8x8_Format:cm,RGBA_BPTC_Format:gm,RGBA_ETC2_EAC_Format:Dc,RGBA_PVRTC_2BPPV1_Format:Rc,RGBA_PVRTC_4BPPV1_Format:Cc,RGBA_S3TC_DXT1_Format:Sc,RGBA_S3TC_DXT3_Format:Tc,RGBA_S3TC_DXT5_Format:Ec,RGBDEncoding:oh,RGBEEncoding:Wa,RGBEFormat:jp,RGBFormat:Fn,RGBIntegerFormat:Qp,RGBM16Encoding:rh,RGBM7Encoding:sh,RGB_ETC1_Format:em,RGB_ETC2_Format:Pc,RGB_PVRTC_2BPPV1_Format:Lc,RGB_PVRTC_4BPPV1_Format:Ac,RGB_S3TC_DXT1_Format:wc,RGFormat:$p,RGIntegerFormat:Kp,RawShaderMaterial:rr,Ray:pi,Raycaster:Lw,RectAreaLight:Wh,RedFormat:Jp,RedIntegerFormat:Zp,ReinhardToneMapping:kp,RepeatWrapping:Nr,ReplaceStencilOp:y0,ReverseSubtractEquation:mp,RingBufferGeometry:Ys,RingGeometry:Ys,SRGB8_ALPHA8_ASTC_10x10_Format:Lm,SRGB8_ALPHA8_ASTC_10x5_Format:Tm,SRGB8_ALPHA8_ASTC_10x6_Format:Em,SRGB8_ALPHA8_ASTC_10x8_Format:Am,SRGB8_ALPHA8_ASTC_12x10_Format:Cm,SRGB8_ALPHA8_ASTC_12x12_Format:Rm,SRGB8_ALPHA8_ASTC_4x4_Format:xm,SRGB8_ALPHA8_ASTC_5x4_Format:ym,SRGB8_ALPHA8_ASTC_5x5_Format:_m,SRGB8_ALPHA8_ASTC_6x5_Format:vm,SRGB8_ALPHA8_ASTC_6x6_Format:bm,SRGB8_ALPHA8_ASTC_8x5_Format:Mm,SRGB8_ALPHA8_ASTC_8x6_Format:wm,SRGB8_ALPHA8_ASTC_8x8_Format:Sm,Scene:Za,SceneUtils:MS,ShaderChunk:Dt,ShaderLib:tn,ShaderMaterial:Bn,ShadowMaterial:Eh,Shape:ri,ShapeBufferGeometry:ji,ShapeGeometry:ji,ShapePath:Bg,ShapeUtils:mn,ShortType:Hp,Skeleton:el,SkeletonHelper:Jg,SkinnedMesh:Qa,SmoothShading:h0,Sphere:fi,SphereBufferGeometry:Ji,SphereGeometry:Ji,Spherical:Cw,SphericalHarmonics3:Gh,SplineCurve:sl,SpotLight:Nh,SpotLightHelper:Pw,Sprite:Ka,SpriteMaterial:$a,SrcAlphaFactor:th,SrcAlphaSaturateFactor:Sp,SrcColorFactor:yp,StaticCopyUsage:k0,StaticDrawUsage:Ns,StaticReadUsage:D0,StereoCamera:fw,StreamCopyUsage:O0,StreamDrawUsage:P0,StreamReadUsage:F0,StringKeyframeTrack:os,SubtractEquation:pp,SubtractiveBlending:_c,TOUCH:a0,TangentSpaceNormalMap:ts,TetrahedronBufferGeometry:js,TetrahedronGeometry:js,TextBufferGeometry:Pa,TextGeometry:Pa,Texture:fe,TextureLoader:Lg,TorusBufferGeometry:Js,TorusGeometry:Js,TorusKnotBufferGeometry:Zs,TorusKnotGeometry:Zs,Triangle:re,TriangleFanDrawMode:g0,TriangleStripDrawMode:m0,TrianglesDrawMode:Fm,TubeBufferGeometry:$s,TubeGeometry:$s,UVMapping:Ha,Uint16Attribute:lS,Uint16BufferAttribute:Ga,Uint32Attribute:hS,Uint32BufferAttribute:Xa,Uint8Attribute:rS,Uint8BufferAttribute:Xm,Uint8ClampedAttribute:oS,Uint8ClampedBufferAttribute:qm,Uniform:al,UniformsLib:et,UniformsUtils:Km,UnsignedByteType:Gi,UnsignedInt248Type:ks,UnsignedIntType:Cr,UnsignedShort4444Type:Vp,UnsignedShort5551Type:Wp,UnsignedShort565Type:Gp,UnsignedShortType:Ur,VSMShadowMap:Ps,Vector2:j,Vector3:S,Vector4:Xt,VectorKeyframeTrack:Zr,Vertex:nS,VertexColors:Yw,VideoTexture:mg,WebGL1Renderer:dg,WebGLCubeRenderTarget:Ya,WebGLMultipleRenderTargets:Vm,WebGLMultisampleRenderTarget:lh,WebGLRenderTarget:nn,WebGLRenderTargetCube:_S,WebGLRenderer:qt,WebGLUtils:ug,WireframeGeometry:Th,WireframeHelper:gS,WrapAroundEnding:Gr,XHRLoader:xS,ZeroCurvatureEnding:Di,ZeroFactor:gp,ZeroSlopeEnding:Ii,ZeroStencilOp:x0,sRGBEncoding:lo},Symbol.toStringTag,{value:"Module"}));Number.prototype.clamp=function(s,t){return Math.min(Math.max(this,s),t)};function TS(){return typeof navigator<"u"?/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||window.innerWidth<600:null}function la(s,t){return s==null&&(s=0),t==null&&(t=1),s+Math.random()*(t-s)}const ES=s=>document.querySelector(s),AS=s=>typeof s=="number"?"#"+("00000"+s.toString(16)).slice(-6):s,Ud=s=>.299*s.r+.587*s.g+.114*s.b;function ex(s){for(;s.children&&s.children.length>0;)ex(s.children[0]),s.remove(s.children[0]);s.geometry&&s.geometry.dispose(),s.material&&(Object.keys(s.material).forEach(t=>{s.material[t]&&s.material[t]!==null&&typeof s.material[t].dispose=="function"&&s.material[t].dispose()}),s.material.dispose())}const ll=typeof window=="object";let ca=ll&&window.THREE||{};ll&&!window.VANTA&&(window.VANTA={});const Rn=ll&&window.VANTA||{};Rn.register=(s,t)=>Rn[s]=e=>new t(e);Rn.version="0.5.24";const nc=function(){return Array.prototype.unshift.call(arguments,"[VANTA]"),console.error.apply(this,arguments)};Rn.VantaBase=class{constructor(t={}){if(!ll)return!1;Rn.current=this,this.windowMouseMoveWrapper=this.windowMouseMoveWrapper.bind(this),this.windowTouchWrapper=this.windowTouchWrapper.bind(this),this.windowGyroWrapper=this.windowGyroWrapper.bind(this),this.resize=this.resize.bind(this),this.animationLoop=this.animationLoop.bind(this),this.restart=this.restart.bind(this);const e=typeof this.getDefaultOptions=="function"?this.getDefaultOptions():this.defaultOptions;if(this.options=Object.assign({mouseControls:!0,touchControls:!0,gyroControls:!1,minHeight:200,minWidth:200,scale:1,scaleMobile:1},e),(t instanceof HTMLElement||typeof t=="string")&&(t={el:t}),Object.assign(this.options,t),this.options.THREE&&(ca=this.options.THREE),this.el=this.options.el,this.el==null)nc('Instance needs "el" param!');else if(!(this.options.el instanceof HTMLElement)){const i=this.el;if(this.el=ES(i),!this.el){nc("Cannot find element",i);return}}this.prepareEl(),this.initThree(),this.setSize();try{this.init()}catch(i){nc("Init error",i),this.renderer&&this.renderer.domElement&&this.el.removeChild(this.renderer.domElement),this.options.backgroundColor&&(console.log("[VANTA] Falling back to backgroundColor"),this.el.style.background=AS(this.options.backgroundColor));return}this.initMouse(),this.resize(),this.animationLoop();const n=window.addEventListener;n("resize",this.resize),window.requestAnimationFrame(this.resize),this.options.mouseControls&&(n("scroll",this.windowMouseMoveWrapper),n("mousemove",this.windowMouseMoveWrapper)),this.options.touchControls&&(n("touchstart",this.windowTouchWrapper),n("touchmove",this.windowTouchWrapper)),this.options.gyroControls&&n("deviceorientation",this.windowGyroWrapper)}setOptions(t={}){Object.assign(this.options,t),this.triggerMouseMove()}prepareEl(){let t,e;if(typeof Node<"u"&&Node.TEXT_NODE)for(t=0;t<this.el.childNodes.length;t++){const n=this.el.childNodes[t];if(n.nodeType===Node.TEXT_NODE){const i=document.createElement("span");i.textContent=n.textContent,n.parentElement.insertBefore(i,n),n.remove()}}for(t=0;t<this.el.children.length;t++)e=this.el.children[t],getComputedStyle(e).position==="static"&&(e.style.position="relative"),getComputedStyle(e).zIndex==="auto"&&(e.style.zIndex=1);getComputedStyle(this.el).position==="static"&&(this.el.style.position="relative")}applyCanvasStyles(t,e={}){Object.assign(t.style,{position:"absolute",zIndex:0,top:0,left:0,background:""}),Object.assign(t.style,e),t.classList.add("vanta-canvas")}initThree(){if(!ca.WebGLRenderer){console.warn("[VANTA] No THREE defined on window");return}this.renderer=new ca.WebGLRenderer({alpha:!0,antialias:!0}),this.el.appendChild(this.renderer.domElement),this.applyCanvasStyles(this.renderer.domElement),isNaN(this.options.backgroundAlpha)&&(this.options.backgroundAlpha=1),this.scene=new ca.Scene}getCanvasElement(){if(this.renderer)return this.renderer.domElement;if(this.p5renderer)return this.p5renderer.canvas}getCanvasRect(){const t=this.getCanvasElement();return t?t.getBoundingClientRect():!1}windowMouseMoveWrapper(t){const e=this.getCanvasRect();if(!e)return!1;const n=t.clientX-e.left,i=t.clientY-e.top;n>=0&&i>=0&&n<=e.width&&i<=e.height&&(this.mouseX=n,this.mouseY=i,this.options.mouseEase||this.triggerMouseMove(n,i))}windowTouchWrapper(t){const e=this.getCanvasRect();if(!e)return!1;if(t.touches.length===1){const n=t.touches[0].clientX-e.left,i=t.touches[0].clientY-e.top;n>=0&&i>=0&&n<=e.width&&i<=e.height&&(this.mouseX=n,this.mouseY=i,this.options.mouseEase||this.triggerMouseMove(n,i))}}windowGyroWrapper(t){const e=this.getCanvasRect();if(!e)return!1;const n=Math.round(t.alpha*2)-e.left,i=Math.round(t.beta*2)-e.top;n>=0&&i>=0&&n<=e.width&&i<=e.height&&(this.mouseX=n,this.mouseY=i,this.options.mouseEase||this.triggerMouseMove(n,i))}triggerMouseMove(t,e){t===void 0&&e===void 0&&(this.options.mouseEase?(t=this.mouseEaseX,e=this.mouseEaseY):(t=this.mouseX,e=this.mouseY)),this.uniforms&&(this.uniforms.iMouse.value.x=t/this.scale,this.uniforms.iMouse.value.y=e/this.scale);const n=t/this.width,i=e/this.height;typeof this.onMouseMove=="function"&&this.onMouseMove(n,i)}setSize(){this.scale||(this.scale=1),TS()&&this.options.scaleMobile?this.scale=this.options.scaleMobile:this.options.scale&&(this.scale=this.options.scale),this.width=Math.max(this.el.offsetWidth,this.options.minWidth),this.height=Math.max(this.el.offsetHeight,this.options.minHeight)}initMouse(){(!this.mouseX&&!this.mouseY||this.mouseX===this.options.minWidth/2&&this.mouseY===this.options.minHeight/2)&&(this.mouseX=this.width/2,this.mouseY=this.height/2,this.triggerMouseMove(this.mouseX,this.mouseY))}resize(){this.setSize(),this.camera&&(this.camera.aspect=this.width/this.height,typeof this.camera.updateProjectionMatrix=="function"&&this.camera.updateProjectionMatrix()),this.renderer&&(this.renderer.setSize(this.width,this.height),this.renderer.setPixelRatio(window.devicePixelRatio/this.scale)),typeof this.onResize=="function"&&this.onResize()}isOnScreen(){const t=this.el.offsetHeight,e=this.el.getBoundingClientRect(),n=window.pageYOffset||(document.documentElement||document.body.parentNode||document.body).scrollTop,i=e.top+n,r=i-window.innerHeight,o=i+t;return r<=n&&n<=o}animationLoop(){this.t||(this.t=0),this.t2||(this.t2=0);const t=performance.now();if(this.prevNow){let e=(t-this.prevNow)/16.666666666666668;e=Math.max(.2,Math.min(e,5)),this.t+=e,this.t2+=(this.options.speed||1)*e,this.uniforms&&(this.uniforms.iTime.value=this.t2*.016667)}return this.prevNow=t,this.options.mouseEase&&(this.mouseEaseX=this.mouseEaseX||this.mouseX||0,this.mouseEaseY=this.mouseEaseY||this.mouseY||0,Math.abs(this.mouseEaseX-this.mouseX)+Math.abs(this.mouseEaseY-this.mouseY)>.1&&(this.mouseEaseX+=(this.mouseX-this.mouseEaseX)*.05,this.mouseEaseY+=(this.mouseY-this.mouseEaseY)*.05,this.triggerMouseMove(this.mouseEaseX,this.mouseEaseY))),(this.isOnScreen()||this.options.forceAnimate)&&(typeof this.onUpdate=="function"&&this.onUpdate(),this.scene&&this.camera&&(this.renderer.render(this.scene,this.camera),this.renderer.setClearColor(this.options.backgroundColor,this.options.backgroundAlpha)),this.fps&&this.fps.update&&this.fps.update(),typeof this.afterRender=="function"&&this.afterRender()),this.req=window.requestAnimationFrame(this.animationLoop)}restart(){if(this.scene)for(;this.scene.children.length;)this.scene.remove(this.scene.children[0]);typeof this.onRestart=="function"&&this.onRestart(),this.init()}init(){typeof this.onInit=="function"&&this.onInit()}destroy(){typeof this.onDestroy=="function"&&this.onDestroy();const t=window.removeEventListener;t("touchstart",this.windowTouchWrapper),t("touchmove",this.windowTouchWrapper),t("scroll",this.windowMouseMoveWrapper),t("mousemove",this.windowMouseMoveWrapper),t("deviceorientation",this.windowGyroWrapper),t("resize",this.resize),window.cancelAnimationFrame(this.req);const e=this.scene;e&&e.children&&ex(e),this.renderer&&(this.renderer.domElement&&this.el.removeChild(this.renderer.domElement),this.renderer=null,this.scene=null),Rn.current===this&&(Rn.current=null)}};const LS=Rn.VantaBase,Hc=typeof window=="object";let At=Hc&&window.THREE;class nx extends LS{static initClass(){this.prototype.defaultOptions={color:16727937,color2:16777215,size:1,backgroundColor:2299196,points:10,maxDistance:20,spacing:15,showDots:!0}}constructor(t){At=t.THREE||At,super(t)}genPoint(t,e,n){let i;if(this.points||(this.points=[]),this.options.showDots){const r=new At.SphereGeometry(.25,12,12),o=new At.MeshLambertMaterial({color:this.options.color});i=new At.Mesh(r,o)}else i=new At.Object3D;return this.cont.add(i),i.ox=t,i.oy=e,i.oz=n,i.position.set(t,e,n),i.r=0,this.points.push(i)}onInit(){this.cont=new At.Group,this.cont.position.set(-50,-20,0),this.scene.add(this.cont);let t=this.options.points,{spacing:e}=this.options;const n=t*t*2;this.linePositions=new Float32Array(n*n*3),this.lineColors=new Float32Array(n*n*3);const i=Ud(new At.Color(this.options.color)),r=Ud(new At.Color(this.options.backgroundColor));this.blending=i>r?"additive":"subtractive";const o=new At.BufferGeometry;o.setAttribute("position",new At.BufferAttribute(this.linePositions,3).setUsage(At.DynamicDrawUsage)),o.setAttribute("color",new At.BufferAttribute(this.lineColors,3).setUsage(At.DynamicDrawUsage)),o.computeBoundingSphere(),o.setDrawRange(0,0);const a=new At.LineBasicMaterial({vertexColors:At.VertexColors,blending:this.blending==="additive"?At.AdditiveBlending:null,transparent:!0});this.linesMesh=new At.LineSegments(o,a),this.cont.add(this.linesMesh);for(let v=0;v<=t;v++)for(let _=0;_<=t;_++){const w=(v-t/2)*e;let b=(_-t/2)*e;this.genPoint(w,0,b)}this.camera=new At.PerspectiveCamera(20,this.width/this.height,.01,1e4),this.camera.position.set(50,100,150),this.scene.add(this.camera);const l=new At.AmbientLight(16777215,.75);this.scene.add(l),this.spot=new At.SpotLight(16777215,1),this.spot.position.set(0,200,0),this.spot.distance=400,this.spot.target=this.cont,this.scene.add(this.spot),this.cont2=new At.Group,this.cont2.position.set(0,15,0),this.scene.add(this.cont2);const c=new At.LineBasicMaterial({color:this.options.color2}),h=[];for(let v=0;v<80;v++){const _=la(18,24),M=_+la(1,6),w=la(-1,1),b=Math.sqrt(1-w*w),E=la(0,Math.PI*2),P=Math.sin(E)*b,R=Math.cos(E)*b;h.push(new At.Vector3(R*_,P*_,w*_)),h.push(new At.Vector3(R*M,P*M,w*M))}const u=new At.BufferGeometry().setFromPoints(h);this.linesMesh2=new At.LineSegments(u,c),this.linesMesh2.position.set(0,0,0),this.cont2.add(this.linesMesh2);const d=new At.LineBasicMaterial({color:this.options.color2,linewidth:2}),f=[];f.push(new At.Vector3(0,30,0)),f.push(new At.Vector3(0,-30,0));const p=4;for(let v=0;v<p;v++){let _=.15*Math.cos(v/p*Math.PI*2),M=.15*Math.sin(v/p*Math.PI*2),w=[17.9,12,8,5,3,2,1.5,1.1,.8,.6,.45,.3,.2,.1,.05,.03,.02,.01];for(let b=0;b<w.length;b++){let E=w[b],P=6*(b+1);f.push(new At.Vector3(_*P,E,M*P)),f.push(new At.Vector3(_*P,-E,M*P))}}const m=new At.BufferGeometry().setFromPoints(f);this.linesMesh3=new At.LineSegments(m,d),this.linesMesh3.position.set(0,0,0),this.cont2.add(this.linesMesh3);const y=new At.LineBasicMaterial({color:this.options.color}),g=new At.SphereGeometry(18*this.options.size,18,14),x=new At.EdgesGeometry(g);this.sphere=new At.LineSegments(x,y),this.sphere.position.set(0,0,0),this.cont2.add(this.sphere),this.cont2.rotation.x=-.25}onUpdate(){let t;this.helper!=null&&this.helper.update(),this.controls!=null&&this.controls.update();const e=this.camera;Math.abs(e.tx-e.position.x)>.01&&(t=e.tx-e.position.x,e.position.x+=t*.02),Math.abs(e.ty-e.position.y)>.01&&(t=e.ty-e.position.y,e.position.y+=t*.02),Hc&&window.innerWidth<480?e.lookAt(new At.Vector3(-10,0,0)):Hc&&window.innerWidth<720?e.lookAt(new At.Vector3(-20,0,0)):e.lookAt(new At.Vector3(-40,0,0));let n=0,i=0,r=0;const o=new At.Color(this.options.backgroundColor),a=new At.Color(this.options.color),l=new At.Color(this.options.color2),c=a.clone().sub(o);this.rayCaster&&this.rayCaster.setFromCamera(new At.Vector2(this.rcMouseX,this.rcMouseY),this.camera),this.linesMesh2&&(this.linesMesh2.rotation.z+=.002,this.linesMesh2.rotation.x+=8e-4,this.linesMesh2.rotation.y+=5e-4),this.sphere&&(this.sphere.rotation.y+=.002,this.linesMesh3.rotation.y-=.004);for(let h=0;h<this.points.length;h++){let u,d;const f=this.points[h];this.rayCaster?d=this.rayCaster.ray.distanceToPoint(f.position):d=1e3;const p=d.clamp(5,15);f.scale.z=((15-p)*.25).clamp(1,100),f.scale.x=f.scale.y=f.scale.z,f.position.y=2*Math.sin(f.position.x/10+this.t*.01+f.position.z/10*.5);for(let m=h;m<this.points.length;m++){const y=this.points[m],g=f.position.x-y.position.x,x=f.position.y-y.position.y,v=f.position.z-y.position.z;if(u=Math.sqrt(g*g+x*x+v*v),u<this.options.maxDistance){let _,M=(1-u/this.options.maxDistance)*2;M=M.clamp(0,1),this.blending==="additive"?_=new At.Color(0).lerp(c,M):_=o.clone().lerp(a,M),this.linePositions[n++]=f.position.x,this.linePositions[n++]=f.position.y,this.linePositions[n++]=f.position.z,this.linePositions[n++]=y.position.x,this.linePositions[n++]=y.position.y,this.linePositions[n++]=y.position.z,this.lineColors[i++]=_.r,this.lineColors[i++]=_.g,this.lineColors[i++]=_.b,this.lineColors[i++]=_.r,this.lineColors[i++]=_.g,this.lineColors[i++]=_.b,r++}}}return this.linesMesh.geometry.setDrawRange(0,r*2),this.linesMesh.geometry.attributes.position.needsUpdate=!0,this.linesMesh.geometry.attributes.color.needsUpdate=!0,this.sphere.material.color.set(a),this.linesMesh2.material.color.set(l),this.linesMesh3.material.color.set(l),this.t*.001}onMouseMove(t,e){const n=this.camera;n.oy||(n.oy=n.position.y,n.ox=n.position.x,n.oz=n.position.z);const i=Math.atan2(n.oz,n.ox),r=Math.sqrt(n.oz*n.oz+n.ox*n.ox),o=i+(t-.5)*1.5*(this.options.mouseCoeffX||1);n.tz=r*Math.sin(o),n.tx=r*Math.cos(o),n.ty=n.oy+(e-.5)*80*(this.options.mouseCoeffY||1),this.rayCaster,this.rcMouseX=t*2-1,this.rcMouseY=-t*2+1}onRestart(){this.scene.remove(this.linesMesh),this.points=[]}}nx.initClass();const CS=Rn.register("GLOBE",nx);/*!
 * @kurkle/color v0.3.4
 * https://github.com/kurkle/color#readme
 * (c) 2024 Jukka Kurkela
 * Released under the MIT License
 */function _o(s){return s+.5|0}const Qn=(s,t,e)=>Math.max(Math.min(s,e),t);function Er(s){return Qn(_o(s*2.55),0,255)}function oi(s){return Qn(_o(s*255),0,255)}function Ln(s){return Qn(_o(s/2.55)/100,0,1)}function Vd(s){return Qn(_o(s*100),0,100)}const qe={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,a:10,b:11,c:12,d:13,e:14,f:15},Uc=[..."0123456789ABCDEF"],RS=s=>Uc[s&15],PS=s=>Uc[(s&240)>>4]+Uc[s&15],ha=s=>(s&240)>>4===(s&15),DS=s=>ha(s.r)&&ha(s.g)&&ha(s.b)&&ha(s.a);function IS(s){var t=s.length,e;return s[0]==="#"&&(t===4||t===5?e={r:255&qe[s[1]]*17,g:255&qe[s[2]]*17,b:255&qe[s[3]]*17,a:t===5?qe[s[4]]*17:255}:(t===7||t===9)&&(e={r:qe[s[1]]<<4|qe[s[2]],g:qe[s[3]]<<4|qe[s[4]],b:qe[s[5]]<<4|qe[s[6]],a:t===9?qe[s[7]]<<4|qe[s[8]]:255})),e}const FS=(s,t)=>s<255?t(s):"";function kS(s){var t=DS(s)?RS:PS;return s?"#"+t(s.r)+t(s.g)+t(s.b)+FS(s.a,t):void 0}const BS=/^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;function ix(s,t,e){const n=t*Math.min(e,1-e),i=(r,o=(r+s/30)%12)=>e-n*Math.max(Math.min(o-3,9-o,1),-1);return[i(0),i(8),i(4)]}function OS(s,t,e){const n=(i,r=(i+s/60)%6)=>e-e*t*Math.max(Math.min(r,4-r,1),0);return[n(5),n(3),n(1)]}function zS(s,t,e){const n=ix(s,1,.5);let i;for(t+e>1&&(i=1/(t+e),t*=i,e*=i),i=0;i<3;i++)n[i]*=1-t-e,n[i]+=t;return n}function NS(s,t,e,n,i){return s===i?(t-e)/n+(t<e?6:0):t===i?(e-s)/n+2:(s-t)/n+4}function $h(s){const e=s.r/255,n=s.g/255,i=s.b/255,r=Math.max(e,n,i),o=Math.min(e,n,i),a=(r+o)/2;let l,c,h;return r!==o&&(h=r-o,c=a>.5?h/(2-r-o):h/(r+o),l=NS(e,n,i,h,r),l=l*60+.5),[l|0,c||0,a]}function Kh(s,t,e,n){return(Array.isArray(t)?s(t[0],t[1],t[2]):s(t,e,n)).map(oi)}function Qh(s,t,e){return Kh(ix,s,t,e)}function HS(s,t,e){return Kh(zS,s,t,e)}function US(s,t,e){return Kh(OS,s,t,e)}function sx(s){return(s%360+360)%360}function VS(s){const t=BS.exec(s);let e=255,n;if(!t)return;t[5]!==n&&(e=t[6]?Er(+t[5]):oi(+t[5]));const i=sx(+t[2]),r=+t[3]/100,o=+t[4]/100;return t[1]==="hwb"?n=HS(i,r,o):t[1]==="hsv"?n=US(i,r,o):n=Qh(i,r,o),{r:n[0],g:n[1],b:n[2],a:e}}function WS(s,t){var e=$h(s);e[0]=sx(e[0]+t),e=Qh(e),s.r=e[0],s.g=e[1],s.b=e[2]}function GS(s){if(!s)return;const t=$h(s),e=t[0],n=Vd(t[1]),i=Vd(t[2]);return s.a<255?`hsla(${e}, ${n}%, ${i}%, ${Ln(s.a)})`:`hsl(${e}, ${n}%, ${i}%)`}const Wd={x:"dark",Z:"light",Y:"re",X:"blu",W:"gr",V:"medium",U:"slate",A:"ee",T:"ol",S:"or",B:"ra",C:"lateg",D:"ights",R:"in",Q:"turquois",E:"hi",P:"ro",O:"al",N:"le",M:"de",L:"yello",F:"en",K:"ch",G:"arks",H:"ea",I:"ightg",J:"wh"},Gd={OiceXe:"f0f8ff",antiquewEte:"faebd7",aqua:"ffff",aquamarRe:"7fffd4",azuY:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"0",blanKedOmond:"ffebcd",Xe:"ff",XeviTet:"8a2be2",bPwn:"a52a2a",burlywood:"deb887",caMtXe:"5f9ea0",KartYuse:"7fff00",KocTate:"d2691e",cSO:"ff7f50",cSnflowerXe:"6495ed",cSnsilk:"fff8dc",crimson:"dc143c",cyan:"ffff",xXe:"8b",xcyan:"8b8b",xgTMnPd:"b8860b",xWay:"a9a9a9",xgYF:"6400",xgYy:"a9a9a9",xkhaki:"bdb76b",xmagFta:"8b008b",xTivegYF:"556b2f",xSange:"ff8c00",xScEd:"9932cc",xYd:"8b0000",xsOmon:"e9967a",xsHgYF:"8fbc8f",xUXe:"483d8b",xUWay:"2f4f4f",xUgYy:"2f4f4f",xQe:"ced1",xviTet:"9400d3",dAppRk:"ff1493",dApskyXe:"bfff",dimWay:"696969",dimgYy:"696969",dodgerXe:"1e90ff",fiYbrick:"b22222",flSOwEte:"fffaf0",foYstWAn:"228b22",fuKsia:"ff00ff",gaRsbSo:"dcdcdc",ghostwEte:"f8f8ff",gTd:"ffd700",gTMnPd:"daa520",Way:"808080",gYF:"8000",gYFLw:"adff2f",gYy:"808080",honeyMw:"f0fff0",hotpRk:"ff69b4",RdianYd:"cd5c5c",Rdigo:"4b0082",ivSy:"fffff0",khaki:"f0e68c",lavFMr:"e6e6fa",lavFMrXsh:"fff0f5",lawngYF:"7cfc00",NmoncEffon:"fffacd",ZXe:"add8e6",ZcSO:"f08080",Zcyan:"e0ffff",ZgTMnPdLw:"fafad2",ZWay:"d3d3d3",ZgYF:"90ee90",ZgYy:"d3d3d3",ZpRk:"ffb6c1",ZsOmon:"ffa07a",ZsHgYF:"20b2aa",ZskyXe:"87cefa",ZUWay:"778899",ZUgYy:"778899",ZstAlXe:"b0c4de",ZLw:"ffffe0",lime:"ff00",limegYF:"32cd32",lRF:"faf0e6",magFta:"ff00ff",maPon:"800000",VaquamarRe:"66cdaa",VXe:"cd",VScEd:"ba55d3",VpurpN:"9370db",VsHgYF:"3cb371",VUXe:"7b68ee",VsprRggYF:"fa9a",VQe:"48d1cc",VviTetYd:"c71585",midnightXe:"191970",mRtcYam:"f5fffa",mistyPse:"ffe4e1",moccasR:"ffe4b5",navajowEte:"ffdead",navy:"80",Tdlace:"fdf5e6",Tive:"808000",TivedBb:"6b8e23",Sange:"ffa500",SangeYd:"ff4500",ScEd:"da70d6",pOegTMnPd:"eee8aa",pOegYF:"98fb98",pOeQe:"afeeee",pOeviTetYd:"db7093",papayawEp:"ffefd5",pHKpuff:"ffdab9",peru:"cd853f",pRk:"ffc0cb",plum:"dda0dd",powMrXe:"b0e0e6",purpN:"800080",YbeccapurpN:"663399",Yd:"ff0000",Psybrown:"bc8f8f",PyOXe:"4169e1",saddNbPwn:"8b4513",sOmon:"fa8072",sandybPwn:"f4a460",sHgYF:"2e8b57",sHshell:"fff5ee",siFna:"a0522d",silver:"c0c0c0",skyXe:"87ceeb",UXe:"6a5acd",UWay:"708090",UgYy:"708090",snow:"fffafa",sprRggYF:"ff7f",stAlXe:"4682b4",tan:"d2b48c",teO:"8080",tEstN:"d8bfd8",tomato:"ff6347",Qe:"40e0d0",viTet:"ee82ee",JHt:"f5deb3",wEte:"ffffff",wEtesmoke:"f5f5f5",Lw:"ffff00",LwgYF:"9acd32"};function XS(){const s={},t=Object.keys(Gd),e=Object.keys(Wd);let n,i,r,o,a;for(n=0;n<t.length;n++){for(o=a=t[n],i=0;i<e.length;i++)r=e[i],a=a.replace(r,Wd[r]);r=parseInt(Gd[o],16),s[a]=[r>>16&255,r>>8&255,r&255]}return s}let ua;function qS(s){ua||(ua=XS(),ua.transparent=[0,0,0,0]);const t=ua[s.toLowerCase()];return t&&{r:t[0],g:t[1],b:t[2],a:t.length===4?t[3]:255}}const YS=/^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;function jS(s){const t=YS.exec(s);let e=255,n,i,r;if(t){if(t[7]!==n){const o=+t[7];e=t[8]?Er(o):Qn(o*255,0,255)}return n=+t[1],i=+t[3],r=+t[5],n=255&(t[2]?Er(n):Qn(n,0,255)),i=255&(t[4]?Er(i):Qn(i,0,255)),r=255&(t[6]?Er(r):Qn(r,0,255)),{r:n,g:i,b:r,a:e}}}function JS(s){return s&&(s.a<255?`rgba(${s.r}, ${s.g}, ${s.b}, ${Ln(s.a)})`:`rgb(${s.r}, ${s.g}, ${s.b})`)}const ic=s=>s<=.0031308?s*12.92:Math.pow(s,1/2.4)*1.055-.055,Cs=s=>s<=.04045?s/12.92:Math.pow((s+.055)/1.055,2.4);function ZS(s,t,e){const n=Cs(Ln(s.r)),i=Cs(Ln(s.g)),r=Cs(Ln(s.b));return{r:oi(ic(n+e*(Cs(Ln(t.r))-n))),g:oi(ic(i+e*(Cs(Ln(t.g))-i))),b:oi(ic(r+e*(Cs(Ln(t.b))-r))),a:s.a+e*(t.a-s.a)}}function da(s,t,e){if(s){let n=$h(s);n[t]=Math.max(0,Math.min(n[t]+n[t]*e,t===0?360:1)),n=Qh(n),s.r=n[0],s.g=n[1],s.b=n[2]}}function rx(s,t){return s&&Object.assign(t||{},s)}function Xd(s){var t={r:0,g:0,b:0,a:255};return Array.isArray(s)?s.length>=3&&(t={r:s[0],g:s[1],b:s[2],a:255},s.length>3&&(t.a=oi(s[3]))):(t=rx(s,{r:0,g:0,b:0,a:1}),t.a=oi(t.a)),t}function $S(s){return s.charAt(0)==="r"?jS(s):VS(s)}class to{constructor(t){if(t instanceof to)return t;const e=typeof t;let n;e==="object"?n=Xd(t):e==="string"&&(n=IS(t)||qS(t)||$S(t)),this._rgb=n,this._valid=!!n}get valid(){return this._valid}get rgb(){var t=rx(this._rgb);return t&&(t.a=Ln(t.a)),t}set rgb(t){this._rgb=Xd(t)}rgbString(){return this._valid?JS(this._rgb):void 0}hexString(){return this._valid?kS(this._rgb):void 0}hslString(){return this._valid?GS(this._rgb):void 0}mix(t,e){if(t){const n=this.rgb,i=t.rgb;let r;const o=e===r?.5:e,a=2*o-1,l=n.a-i.a,c=((a*l===-1?a:(a+l)/(1+a*l))+1)/2;r=1-c,n.r=255&c*n.r+r*i.r+.5,n.g=255&c*n.g+r*i.g+.5,n.b=255&c*n.b+r*i.b+.5,n.a=o*n.a+(1-o)*i.a,this.rgb=n}return this}interpolate(t,e){return t&&(this._rgb=ZS(this._rgb,t._rgb,e)),this}clone(){return new to(this.rgb)}alpha(t){return this._rgb.a=oi(t),this}clearer(t){const e=this._rgb;return e.a*=1-t,this}greyscale(){const t=this._rgb,e=_o(t.r*.3+t.g*.59+t.b*.11);return t.r=t.g=t.b=e,this}opaquer(t){const e=this._rgb;return e.a*=1+t,this}negate(){const t=this._rgb;return t.r=255-t.r,t.g=255-t.g,t.b=255-t.b,this}lighten(t){return da(this._rgb,2,t),this}darken(t){return da(this._rgb,2,-t),this}saturate(t){return da(this._rgb,1,t),this}desaturate(t){return da(this._rgb,1,-t),this}rotate(t){return WS(this._rgb,t),this}}/*!
 * Chart.js v4.5.1
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */function Tn(){}const KS=(()=>{let s=0;return()=>s++})();function zt(s){return s==null}function $t(s){if(Array.isArray&&Array.isArray(s))return!0;const t=Object.prototype.toString.call(s);return t.slice(0,7)==="[object"&&t.slice(-6)==="Array]"}function kt(s){return s!==null&&Object.prototype.toString.call(s)==="[object Object]"}function xe(s){return(typeof s=="number"||s instanceof Number)&&isFinite(+s)}function cn(s,t){return xe(s)?s:t}function Pt(s,t){return typeof s>"u"?t:s}const QS=(s,t)=>typeof s=="string"&&s.endsWith("%")?parseFloat(s)/100:+s/t,ox=(s,t)=>typeof s=="string"&&s.endsWith("%")?parseFloat(s)/100*t:+s;function jt(s,t,e){if(s&&typeof s.call=="function")return s.apply(e,t)}function Gt(s,t,e,n){let i,r,o;if($t(s))for(r=s.length,i=0;i<r;i++)t.call(e,s[i],i);else if(kt(s))for(o=Object.keys(s),r=o.length,i=0;i<r;i++)t.call(e,s[o[i]],o[i])}function Ia(s,t){let e,n,i,r;if(!s||!t||s.length!==t.length)return!1;for(e=0,n=s.length;e<n;++e)if(i=s[e],r=t[e],i.datasetIndex!==r.datasetIndex||i.index!==r.index)return!1;return!0}function Fa(s){if($t(s))return s.map(Fa);if(kt(s)){const t=Object.create(null),e=Object.keys(s),n=e.length;let i=0;for(;i<n;++i)t[e[i]]=Fa(s[e[i]]);return t}return s}function ax(s){return["__proto__","prototype","constructor"].indexOf(s)===-1}function t1(s,t,e,n){if(!ax(s))return;const i=t[s],r=e[s];kt(i)&&kt(r)?eo(i,r,n):t[s]=Fa(r)}function eo(s,t,e){const n=$t(t)?t:[t],i=n.length;if(!kt(s))return s;e=e||{};const r=e.merger||t1;let o;for(let a=0;a<i;++a){if(o=n[a],!kt(o))continue;const l=Object.keys(o);for(let c=0,h=l.length;c<h;++c)r(l[c],s,o,e)}return s}function Ir(s,t){return eo(s,t,{merger:e1})}function e1(s,t,e){if(!ax(s))return;const n=t[s],i=e[s];kt(n)&&kt(i)?Ir(n,i):Object.prototype.hasOwnProperty.call(t,s)||(t[s]=Fa(i))}const qd={"":s=>s,x:s=>s.x,y:s=>s.y};function n1(s){const t=s.split("."),e=[];let n="";for(const i of t)n+=i,n.endsWith("\\")?n=n.slice(0,-1)+".":(e.push(n),n="");return e}function i1(s){const t=n1(s);return e=>{for(const n of t){if(n==="")break;e=e&&e[n]}return e}}function hi(s,t){return(qd[t]||(qd[t]=i1(t)))(s)}function tu(s){return s.charAt(0).toUpperCase()+s.slice(1)}const no=s=>typeof s<"u",ui=s=>typeof s=="function",Yd=(s,t)=>{if(s.size!==t.size)return!1;for(const e of s)if(!t.has(e))return!1;return!0};function s1(s){return s.type==="mouseup"||s.type==="click"||s.type==="contextmenu"}const Vt=Math.PI,Zt=2*Vt,r1=Zt+Vt,ka=Number.POSITIVE_INFINITY,o1=Vt/180,oe=Vt/2,Ti=Vt/4,jd=Vt*2/3,lx=Math.log10,gn=Math.sign;function Fr(s,t,e){return Math.abs(s-t)<e}function Jd(s){const t=Math.round(s);s=Fr(s,t,s/1e3)?t:s;const e=Math.pow(10,Math.floor(lx(s))),n=s/e;return(n<=1?1:n<=2?2:n<=5?5:10)*e}function a1(s){const t=[],e=Math.sqrt(s);let n;for(n=1;n<e;n++)s%n===0&&(t.push(n),t.push(s/n));return e===(e|0)&&t.push(e),t.sort((i,r)=>i-r).pop(),t}function l1(s){return typeof s=="symbol"||typeof s=="object"&&s!==null&&!(Symbol.toPrimitive in s||"toString"in s||"valueOf"in s)}function Ks(s){return!l1(s)&&!isNaN(parseFloat(s))&&isFinite(s)}function c1(s,t){const e=Math.round(s);return e-t<=s&&e+t>=s}function h1(s,t,e){let n,i,r;for(n=0,i=s.length;n<i;n++)r=s[n][e],isNaN(r)||(t.min=Math.min(t.min,r),t.max=Math.max(t.max,r))}function en(s){return s*(Vt/180)}function eu(s){return s*(180/Vt)}function Zd(s){if(!xe(s))return;let t=1,e=0;for(;Math.round(s*t)/t!==s;)t*=10,e++;return e}function cx(s,t){const e=t.x-s.x,n=t.y-s.y,i=Math.sqrt(e*e+n*n);let r=Math.atan2(n,e);return r<-.5*Vt&&(r+=Zt),{angle:r,distance:i}}function Vc(s,t){return Math.sqrt(Math.pow(t.x-s.x,2)+Math.pow(t.y-s.y,2))}function u1(s,t){return(s-t+r1)%Zt-Vt}function Ce(s){return(s%Zt+Zt)%Zt}function io(s,t,e,n){const i=Ce(s),r=Ce(t),o=Ce(e),a=Ce(r-i),l=Ce(o-i),c=Ce(i-r),h=Ce(i-o);return i===r||i===o||n&&r===o||a>l&&c<h}function Re(s,t,e){return Math.max(t,Math.min(e,s))}function d1(s){return Re(s,-32768,32767)}function Pn(s,t,e,n=1e-6){return s>=Math.min(t,e)-n&&s<=Math.max(t,e)+n}function nu(s,t,e){e=e||(o=>s[o]<t);let n=s.length-1,i=0,r;for(;n-i>1;)r=i+n>>1,e(r)?i=r:n=r;return{lo:i,hi:n}}const ki=(s,t,e,n)=>nu(s,e,n?i=>{const r=s[i][t];return r<e||r===e&&s[i+1][t]===e}:i=>s[i][t]<e),f1=(s,t,e)=>nu(s,e,n=>s[n][t]>=e);function p1(s,t,e){let n=0,i=s.length;for(;n<i&&s[n]<t;)n++;for(;i>n&&s[i-1]>e;)i--;return n>0||i<s.length?s.slice(n,i):s}const hx=["push","pop","shift","splice","unshift"];function m1(s,t){if(s._chartjs){s._chartjs.listeners.push(t);return}Object.defineProperty(s,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[t]}}),hx.forEach(e=>{const n="_onData"+tu(e),i=s[e];Object.defineProperty(s,e,{configurable:!0,enumerable:!1,value(...r){const o=i.apply(this,r);return s._chartjs.listeners.forEach(a=>{typeof a[n]=="function"&&a[n](...r)}),o}})})}function $d(s,t){const e=s._chartjs;if(!e)return;const n=e.listeners,i=n.indexOf(t);i!==-1&&n.splice(i,1),!(n.length>0)&&(hx.forEach(r=>{delete s[r]}),delete s._chartjs)}function ux(s){const t=new Set(s);return t.size===s.length?s:Array.from(t)}const dx=(function(){return typeof window>"u"?function(s){return s()}:window.requestAnimationFrame})();function fx(s,t){let e=[],n=!1;return function(...i){e=i,n||(n=!0,dx.call(window,()=>{n=!1,s.apply(t,e)}))}}function g1(s,t){let e;return function(...n){return t?(clearTimeout(e),e=setTimeout(s,t,n)):s.apply(this,n),t}}const iu=s=>s==="start"?"left":s==="end"?"right":"center",Le=(s,t,e)=>s==="start"?t:s==="end"?e:(t+e)/2,x1=(s,t,e,n)=>s===(n?"left":"right")?e:s==="center"?(t+e)/2:t;function px(s,t,e){const n=t.length;let i=0,r=n;if(s._sorted){const{iScale:o,vScale:a,_parsed:l}=s,c=s.dataset&&s.dataset.options?s.dataset.options.spanGaps:null,h=o.axis,{min:u,max:d,minDefined:f,maxDefined:p}=o.getUserBounds();if(f){if(i=Math.min(ki(l,h,u).lo,e?n:ki(t,h,o.getPixelForValue(u)).lo),c){const m=l.slice(0,i+1).reverse().findIndex(y=>!zt(y[a.axis]));i-=Math.max(0,m)}i=Re(i,0,n-1)}if(p){let m=Math.max(ki(l,o.axis,d,!0).hi+1,e?0:ki(t,h,o.getPixelForValue(d),!0).hi+1);if(c){const y=l.slice(m-1).findIndex(g=>!zt(g[a.axis]));m+=Math.max(0,y)}r=Re(m,i,n)-i}else r=n-i}return{start:i,count:r}}function mx(s){const{xScale:t,yScale:e,_scaleRanges:n}=s,i={xmin:t.min,xmax:t.max,ymin:e.min,ymax:e.max};if(!n)return s._scaleRanges=i,!0;const r=n.xmin!==t.min||n.xmax!==t.max||n.ymin!==e.min||n.ymax!==e.max;return Object.assign(n,i),r}const fa=s=>s===0||s===1,Kd=(s,t,e)=>-(Math.pow(2,10*(s-=1))*Math.sin((s-t)*Zt/e)),Qd=(s,t,e)=>Math.pow(2,-10*s)*Math.sin((s-t)*Zt/e)+1,kr={linear:s=>s,easeInQuad:s=>s*s,easeOutQuad:s=>-s*(s-2),easeInOutQuad:s=>(s/=.5)<1?.5*s*s:-.5*(--s*(s-2)-1),easeInCubic:s=>s*s*s,easeOutCubic:s=>(s-=1)*s*s+1,easeInOutCubic:s=>(s/=.5)<1?.5*s*s*s:.5*((s-=2)*s*s+2),easeInQuart:s=>s*s*s*s,easeOutQuart:s=>-((s-=1)*s*s*s-1),easeInOutQuart:s=>(s/=.5)<1?.5*s*s*s*s:-.5*((s-=2)*s*s*s-2),easeInQuint:s=>s*s*s*s*s,easeOutQuint:s=>(s-=1)*s*s*s*s+1,easeInOutQuint:s=>(s/=.5)<1?.5*s*s*s*s*s:.5*((s-=2)*s*s*s*s+2),easeInSine:s=>-Math.cos(s*oe)+1,easeOutSine:s=>Math.sin(s*oe),easeInOutSine:s=>-.5*(Math.cos(Vt*s)-1),easeInExpo:s=>s===0?0:Math.pow(2,10*(s-1)),easeOutExpo:s=>s===1?1:-Math.pow(2,-10*s)+1,easeInOutExpo:s=>fa(s)?s:s<.5?.5*Math.pow(2,10*(s*2-1)):.5*(-Math.pow(2,-10*(s*2-1))+2),easeInCirc:s=>s>=1?s:-(Math.sqrt(1-s*s)-1),easeOutCirc:s=>Math.sqrt(1-(s-=1)*s),easeInOutCirc:s=>(s/=.5)<1?-.5*(Math.sqrt(1-s*s)-1):.5*(Math.sqrt(1-(s-=2)*s)+1),easeInElastic:s=>fa(s)?s:Kd(s,.075,.3),easeOutElastic:s=>fa(s)?s:Qd(s,.075,.3),easeInOutElastic(s){return fa(s)?s:s<.5?.5*Kd(s*2,.1125,.45):.5+.5*Qd(s*2-1,.1125,.45)},easeInBack(s){return s*s*((1.70158+1)*s-1.70158)},easeOutBack(s){return(s-=1)*s*((1.70158+1)*s+1.70158)+1},easeInOutBack(s){let t=1.70158;return(s/=.5)<1?.5*(s*s*(((t*=1.525)+1)*s-t)):.5*((s-=2)*s*(((t*=1.525)+1)*s+t)+2)},easeInBounce:s=>1-kr.easeOutBounce(1-s),easeOutBounce(s){return s<1/2.75?7.5625*s*s:s<2/2.75?7.5625*(s-=1.5/2.75)*s+.75:s<2.5/2.75?7.5625*(s-=2.25/2.75)*s+.9375:7.5625*(s-=2.625/2.75)*s+.984375},easeInOutBounce:s=>s<.5?kr.easeInBounce(s*2)*.5:kr.easeOutBounce(s*2-1)*.5+.5};function su(s){if(s&&typeof s=="object"){const t=s.toString();return t==="[object CanvasPattern]"||t==="[object CanvasGradient]"}return!1}function tf(s){return su(s)?s:new to(s)}function sc(s){return su(s)?s:new to(s).saturate(.5).darken(.1).hexString()}const y1=["x","y","borderWidth","radius","tension"],_1=["color","borderColor","backgroundColor"];function v1(s){s.set("animation",{delay:void 0,duration:1e3,easing:"easeOutQuart",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0}),s.describe("animation",{_fallback:!1,_indexable:!1,_scriptable:t=>t!=="onProgress"&&t!=="onComplete"&&t!=="fn"}),s.set("animations",{colors:{type:"color",properties:_1},numbers:{type:"number",properties:y1}}),s.describe("animations",{_fallback:"animation"}),s.set("transitions",{active:{animation:{duration:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:"transparent"},visible:{type:"boolean",duration:0}}},hide:{animations:{colors:{to:"transparent"},visible:{type:"boolean",easing:"linear",fn:t=>t|0}}}})}function b1(s){s.set("layout",{autoPadding:!0,padding:{top:0,right:0,bottom:0,left:0}})}const ef=new Map;function M1(s,t){t=t||{};const e=s+JSON.stringify(t);let n=ef.get(e);return n||(n=new Intl.NumberFormat(s,t),ef.set(e,n)),n}function cl(s,t,e){return M1(t,e).format(s)}const w1={values(s){return $t(s)?s:""+s},numeric(s,t,e){if(s===0)return"0";const n=this.chart.options.locale;let i,r=s;if(e.length>1){const c=Math.max(Math.abs(e[0].value),Math.abs(e[e.length-1].value));(c<1e-4||c>1e15)&&(i="scientific"),r=S1(s,e)}const o=lx(Math.abs(r)),a=isNaN(o)?1:Math.max(Math.min(-1*Math.floor(o),20),0),l={notation:i,minimumFractionDigits:a,maximumFractionDigits:a};return Object.assign(l,this.options.ticks.format),cl(s,n,l)}};function S1(s,t){let e=t.length>3?t[2].value-t[1].value:t[1].value-t[0].value;return Math.abs(e)>=1&&s!==Math.floor(s)&&(e=s-Math.floor(s)),e}var ru={formatters:w1};function T1(s){s.set("scale",{display:!0,offset:!1,reverse:!1,beginAtZero:!1,bounds:"ticks",clip:!0,grace:0,grid:{display:!0,lineWidth:1,drawOnChartArea:!0,drawTicks:!0,tickLength:8,tickWidth:(t,e)=>e.lineWidth,tickColor:(t,e)=>e.color,offset:!1},border:{display:!0,dash:[],dashOffset:0,width:1},title:{display:!1,text:"",padding:{top:4,bottom:4}},ticks:{minRotation:0,maxRotation:50,mirror:!1,textStrokeWidth:0,textStrokeColor:"",padding:3,display:!0,autoSkip:!0,autoSkipPadding:3,labelOffset:0,callback:ru.formatters.values,minor:{},major:{},align:"center",crossAlign:"near",showLabelBackdrop:!1,backdropColor:"rgba(255, 255, 255, 0.75)",backdropPadding:2}}),s.route("scale.ticks","color","","color"),s.route("scale.grid","color","","borderColor"),s.route("scale.border","color","","borderColor"),s.route("scale.title","color","","color"),s.describe("scale",{_fallback:!1,_scriptable:t=>!t.startsWith("before")&&!t.startsWith("after")&&t!=="callback"&&t!=="parser",_indexable:t=>t!=="borderDash"&&t!=="tickBorderDash"&&t!=="dash"}),s.describe("scales",{_fallback:"scale"}),s.describe("scale.ticks",{_scriptable:t=>t!=="backdropPadding"&&t!=="callback",_indexable:t=>t!=="backdropPadding"})}const $i=Object.create(null),Wc=Object.create(null);function Br(s,t){if(!t)return s;const e=t.split(".");for(let n=0,i=e.length;n<i;++n){const r=e[n];s=s[r]||(s[r]=Object.create(null))}return s}function rc(s,t,e){return typeof t=="string"?eo(Br(s,t),e):eo(Br(s,""),t)}class E1{constructor(t,e){this.animation=void 0,this.backgroundColor="rgba(0,0,0,0.1)",this.borderColor="rgba(0,0,0,0.1)",this.color="#666",this.datasets={},this.devicePixelRatio=n=>n.chart.platform.getDevicePixelRatio(),this.elements={},this.events=["mousemove","mouseout","click","touchstart","touchmove"],this.font={family:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",size:12,style:"normal",lineHeight:1.2,weight:null},this.hover={},this.hoverBackgroundColor=(n,i)=>sc(i.backgroundColor),this.hoverBorderColor=(n,i)=>sc(i.borderColor),this.hoverColor=(n,i)=>sc(i.color),this.indexAxis="x",this.interaction={mode:"nearest",intersect:!0,includeInvisible:!1},this.maintainAspectRatio=!0,this.onHover=null,this.onClick=null,this.parsing=!0,this.plugins={},this.responsive=!0,this.scale=void 0,this.scales={},this.showLine=!0,this.drawActiveElementsOnTop=!0,this.describe(t),this.apply(e)}set(t,e){return rc(this,t,e)}get(t){return Br(this,t)}describe(t,e){return rc(Wc,t,e)}override(t,e){return rc($i,t,e)}route(t,e,n,i){const r=Br(this,t),o=Br(this,n),a="_"+e;Object.defineProperties(r,{[a]:{value:r[e],writable:!0},[e]:{enumerable:!0,get(){const l=this[a],c=o[i];return kt(l)?Object.assign({},c,l):Pt(l,c)},set(l){this[a]=l}}})}apply(t){t.forEach(e=>e(this))}}var te=new E1({_scriptable:s=>!s.startsWith("on"),_indexable:s=>s!=="events",hover:{_fallback:"interaction"},interaction:{_scriptable:!1,_indexable:!1}},[v1,b1,T1]);function A1(s){return!s||zt(s.size)||zt(s.family)?null:(s.style?s.style+" ":"")+(s.weight?s.weight+" ":"")+s.size+"px "+s.family}function Ba(s,t,e,n,i){let r=t[i];return r||(r=t[i]=s.measureText(i).width,e.push(i)),r>n&&(n=r),n}function L1(s,t,e,n){n=n||{};let i=n.data=n.data||{},r=n.garbageCollect=n.garbageCollect||[];n.font!==t&&(i=n.data={},r=n.garbageCollect=[],n.font=t),s.save(),s.font=t;let o=0;const a=e.length;let l,c,h,u,d;for(l=0;l<a;l++)if(u=e[l],u!=null&&!$t(u))o=Ba(s,i,r,o,u);else if($t(u))for(c=0,h=u.length;c<h;c++)d=u[c],d!=null&&!$t(d)&&(o=Ba(s,i,r,o,d));s.restore();const f=r.length/2;if(f>e.length){for(l=0;l<f;l++)delete i[r[l]];r.splice(0,f)}return o}function Ei(s,t,e){const n=s.currentDevicePixelRatio,i=e!==0?Math.max(e/2,.5):0;return Math.round((t-i)*n)/n+i}function nf(s,t){!t&&!s||(t=t||s.getContext("2d"),t.save(),t.resetTransform(),t.clearRect(0,0,s.width,s.height),t.restore())}function Gc(s,t,e,n){gx(s,t,e,n,null)}function gx(s,t,e,n,i){let r,o,a,l,c,h,u,d;const f=t.pointStyle,p=t.rotation,m=t.radius;let y=(p||0)*o1;if(f&&typeof f=="object"&&(r=f.toString(),r==="[object HTMLImageElement]"||r==="[object HTMLCanvasElement]")){s.save(),s.translate(e,n),s.rotate(y),s.drawImage(f,-f.width/2,-f.height/2,f.width,f.height),s.restore();return}if(!(isNaN(m)||m<=0)){switch(s.beginPath(),f){default:i?s.ellipse(e,n,i/2,m,0,0,Zt):s.arc(e,n,m,0,Zt),s.closePath();break;case"triangle":h=i?i/2:m,s.moveTo(e+Math.sin(y)*h,n-Math.cos(y)*m),y+=jd,s.lineTo(e+Math.sin(y)*h,n-Math.cos(y)*m),y+=jd,s.lineTo(e+Math.sin(y)*h,n-Math.cos(y)*m),s.closePath();break;case"rectRounded":c=m*.516,l=m-c,o=Math.cos(y+Ti)*l,u=Math.cos(y+Ti)*(i?i/2-c:l),a=Math.sin(y+Ti)*l,d=Math.sin(y+Ti)*(i?i/2-c:l),s.arc(e-u,n-a,c,y-Vt,y-oe),s.arc(e+d,n-o,c,y-oe,y),s.arc(e+u,n+a,c,y,y+oe),s.arc(e-d,n+o,c,y+oe,y+Vt),s.closePath();break;case"rect":if(!p){l=Math.SQRT1_2*m,h=i?i/2:l,s.rect(e-h,n-l,2*h,2*l);break}y+=Ti;case"rectRot":u=Math.cos(y)*(i?i/2:m),o=Math.cos(y)*m,a=Math.sin(y)*m,d=Math.sin(y)*(i?i/2:m),s.moveTo(e-u,n-a),s.lineTo(e+d,n-o),s.lineTo(e+u,n+a),s.lineTo(e-d,n+o),s.closePath();break;case"crossRot":y+=Ti;case"cross":u=Math.cos(y)*(i?i/2:m),o=Math.cos(y)*m,a=Math.sin(y)*m,d=Math.sin(y)*(i?i/2:m),s.moveTo(e-u,n-a),s.lineTo(e+u,n+a),s.moveTo(e+d,n-o),s.lineTo(e-d,n+o);break;case"star":u=Math.cos(y)*(i?i/2:m),o=Math.cos(y)*m,a=Math.sin(y)*m,d=Math.sin(y)*(i?i/2:m),s.moveTo(e-u,n-a),s.lineTo(e+u,n+a),s.moveTo(e+d,n-o),s.lineTo(e-d,n+o),y+=Ti,u=Math.cos(y)*(i?i/2:m),o=Math.cos(y)*m,a=Math.sin(y)*m,d=Math.sin(y)*(i?i/2:m),s.moveTo(e-u,n-a),s.lineTo(e+u,n+a),s.moveTo(e+d,n-o),s.lineTo(e-d,n+o);break;case"line":o=i?i/2:Math.cos(y)*m,a=Math.sin(y)*m,s.moveTo(e-o,n-a),s.lineTo(e+o,n+a);break;case"dash":s.moveTo(e,n),s.lineTo(e+Math.cos(y)*(i?i/2:m),n+Math.sin(y)*m);break;case!1:s.closePath();break}s.fill(),t.borderWidth>0&&s.stroke()}}function Dn(s,t,e){return e=e||.5,!t||s&&s.x>t.left-e&&s.x<t.right+e&&s.y>t.top-e&&s.y<t.bottom+e}function hl(s,t){s.save(),s.beginPath(),s.rect(t.left,t.top,t.right-t.left,t.bottom-t.top),s.clip()}function ul(s){s.restore()}function C1(s,t,e,n,i){if(!t)return s.lineTo(e.x,e.y);if(i==="middle"){const r=(t.x+e.x)/2;s.lineTo(r,t.y),s.lineTo(r,e.y)}else i==="after"!=!!n?s.lineTo(t.x,e.y):s.lineTo(e.x,t.y);s.lineTo(e.x,e.y)}function R1(s,t,e,n){if(!t)return s.lineTo(e.x,e.y);s.bezierCurveTo(n?t.cp1x:t.cp2x,n?t.cp1y:t.cp2y,n?e.cp2x:e.cp1x,n?e.cp2y:e.cp1y,e.x,e.y)}function P1(s,t){t.translation&&s.translate(t.translation[0],t.translation[1]),zt(t.rotation)||s.rotate(t.rotation),t.color&&(s.fillStyle=t.color),t.textAlign&&(s.textAlign=t.textAlign),t.textBaseline&&(s.textBaseline=t.textBaseline)}function D1(s,t,e,n,i){if(i.strikethrough||i.underline){const r=s.measureText(n),o=t-r.actualBoundingBoxLeft,a=t+r.actualBoundingBoxRight,l=e-r.actualBoundingBoxAscent,c=e+r.actualBoundingBoxDescent,h=i.strikethrough?(l+c)/2:c;s.strokeStyle=s.fillStyle,s.beginPath(),s.lineWidth=i.decorationWidth||2,s.moveTo(o,h),s.lineTo(a,h),s.stroke()}}function I1(s,t){const e=s.fillStyle;s.fillStyle=t.color,s.fillRect(t.left,t.top,t.width,t.height),s.fillStyle=e}function Ki(s,t,e,n,i,r={}){const o=$t(t)?t:[t],a=r.strokeWidth>0&&r.strokeColor!=="";let l,c;for(s.save(),s.font=i.string,P1(s,r),l=0;l<o.length;++l)c=o[l],r.backdrop&&I1(s,r.backdrop),a&&(r.strokeColor&&(s.strokeStyle=r.strokeColor),zt(r.strokeWidth)||(s.lineWidth=r.strokeWidth),s.strokeText(c,e,n,r.maxWidth)),s.fillText(c,e,n,r.maxWidth),D1(s,e,n,c,r),n+=Number(i.lineHeight);s.restore()}function so(s,t){const{x:e,y:n,w:i,h:r,radius:o}=t;s.arc(e+o.topLeft,n+o.topLeft,o.topLeft,1.5*Vt,Vt,!0),s.lineTo(e,n+r-o.bottomLeft),s.arc(e+o.bottomLeft,n+r-o.bottomLeft,o.bottomLeft,Vt,oe,!0),s.lineTo(e+i-o.bottomRight,n+r),s.arc(e+i-o.bottomRight,n+r-o.bottomRight,o.bottomRight,oe,0,!0),s.lineTo(e+i,n+o.topRight),s.arc(e+i-o.topRight,n+o.topRight,o.topRight,0,-oe,!0),s.lineTo(e+o.topLeft,n)}const F1=/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,k1=/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;function B1(s,t){const e=(""+s).match(F1);if(!e||e[1]==="normal")return t*1.2;switch(s=+e[2],e[3]){case"px":return s;case"%":s/=100;break}return t*s}const O1=s=>+s||0;function ou(s,t){const e={},n=kt(t),i=n?Object.keys(t):t,r=kt(s)?n?o=>Pt(s[o],s[t[o]]):o=>s[o]:()=>s;for(const o of i)e[o]=O1(r(o));return e}function xx(s){return ou(s,{top:"y",right:"x",bottom:"y",left:"x"})}function Hi(s){return ou(s,["topLeft","topRight","bottomLeft","bottomRight"])}function De(s){const t=xx(s);return t.width=t.left+t.right,t.height=t.top+t.bottom,t}function de(s,t){s=s||{},t=t||te.font;let e=Pt(s.size,t.size);typeof e=="string"&&(e=parseInt(e,10));let n=Pt(s.style,t.style);n&&!(""+n).match(k1)&&(console.warn('Invalid font style specified: "'+n+'"'),n=void 0);const i={family:Pt(s.family,t.family),lineHeight:B1(Pt(s.lineHeight,t.lineHeight),e),size:e,style:n,weight:Pt(s.weight,t.weight),string:""};return i.string=A1(i),i}function pa(s,t,e,n){let i,r,o;for(i=0,r=s.length;i<r;++i)if(o=s[i],o!==void 0&&o!==void 0)return o}function z1(s,t,e){const{min:n,max:i}=s,r=ox(t,(i-n)/2),o=(a,l)=>e&&a===0?0:a+l;return{min:o(n,-Math.abs(r)),max:o(i,r)}}function mi(s,t){return Object.assign(Object.create(s),t)}function au(s,t=[""],e,n,i=()=>s[0]){const r=e||s;typeof n>"u"&&(n=bx("_fallback",s));const o={[Symbol.toStringTag]:"Object",_cacheable:!0,_scopes:s,_rootScopes:r,_fallback:n,_getTarget:i,override:a=>au([a,...s],t,r,n)};return new Proxy(o,{deleteProperty(a,l){return delete a[l],delete a._keys,delete s[0][l],!0},get(a,l){return _x(a,l,()=>q1(l,t,s,a))},getOwnPropertyDescriptor(a,l){return Reflect.getOwnPropertyDescriptor(a._scopes[0],l)},getPrototypeOf(){return Reflect.getPrototypeOf(s[0])},has(a,l){return rf(a).includes(l)},ownKeys(a){return rf(a)},set(a,l,c){const h=a._storage||(a._storage=i());return a[l]=h[l]=c,delete a._keys,!0}})}function Qs(s,t,e,n){const i={_cacheable:!1,_proxy:s,_context:t,_subProxy:e,_stack:new Set,_descriptors:yx(s,n),setContext:r=>Qs(s,r,e,n),override:r=>Qs(s.override(r),t,e,n)};return new Proxy(i,{deleteProperty(r,o){return delete r[o],delete s[o],!0},get(r,o,a){return _x(r,o,()=>H1(r,o,a))},getOwnPropertyDescriptor(r,o){return r._descriptors.allKeys?Reflect.has(s,o)?{enumerable:!0,configurable:!0}:void 0:Reflect.getOwnPropertyDescriptor(s,o)},getPrototypeOf(){return Reflect.getPrototypeOf(s)},has(r,o){return Reflect.has(s,o)},ownKeys(){return Reflect.ownKeys(s)},set(r,o,a){return s[o]=a,delete r[o],!0}})}function yx(s,t={scriptable:!0,indexable:!0}){const{_scriptable:e=t.scriptable,_indexable:n=t.indexable,_allKeys:i=t.allKeys}=s;return{allKeys:i,scriptable:e,indexable:n,isScriptable:ui(e)?e:()=>e,isIndexable:ui(n)?n:()=>n}}const N1=(s,t)=>s?s+tu(t):t,lu=(s,t)=>kt(t)&&s!=="adapters"&&(Object.getPrototypeOf(t)===null||t.constructor===Object);function _x(s,t,e){if(Object.prototype.hasOwnProperty.call(s,t)||t==="constructor")return s[t];const n=e();return s[t]=n,n}function H1(s,t,e){const{_proxy:n,_context:i,_subProxy:r,_descriptors:o}=s;let a=n[t];return ui(a)&&o.isScriptable(t)&&(a=U1(t,a,s,e)),$t(a)&&a.length&&(a=V1(t,a,s,o.isIndexable)),lu(t,a)&&(a=Qs(a,i,r&&r[t],o)),a}function U1(s,t,e,n){const{_proxy:i,_context:r,_subProxy:o,_stack:a}=e;if(a.has(s))throw new Error("Recursion detected: "+Array.from(a).join("->")+"->"+s);a.add(s);let l=t(r,o||n);return a.delete(s),lu(s,l)&&(l=cu(i._scopes,i,s,l)),l}function V1(s,t,e,n){const{_proxy:i,_context:r,_subProxy:o,_descriptors:a}=e;if(typeof r.index<"u"&&n(s))return t[r.index%t.length];if(kt(t[0])){const l=t,c=i._scopes.filter(h=>h!==l);t=[];for(const h of l){const u=cu(c,i,s,h);t.push(Qs(u,r,o&&o[s],a))}}return t}function vx(s,t,e){return ui(s)?s(t,e):s}const W1=(s,t)=>s===!0?t:typeof s=="string"?hi(t,s):void 0;function G1(s,t,e,n,i){for(const r of t){const o=W1(e,r);if(o){s.add(o);const a=vx(o._fallback,e,i);if(typeof a<"u"&&a!==e&&a!==n)return a}else if(o===!1&&typeof n<"u"&&e!==n)return null}return!1}function cu(s,t,e,n){const i=t._rootScopes,r=vx(t._fallback,e,n),o=[...s,...i],a=new Set;a.add(n);let l=sf(a,o,e,r||e,n);return l===null||typeof r<"u"&&r!==e&&(l=sf(a,o,r,l,n),l===null)?!1:au(Array.from(a),[""],i,r,()=>X1(t,e,n))}function sf(s,t,e,n,i){for(;e;)e=G1(s,t,e,n,i);return e}function X1(s,t,e){const n=s._getTarget();t in n||(n[t]={});const i=n[t];return $t(i)&&kt(e)?e:i||{}}function q1(s,t,e,n){let i;for(const r of t)if(i=bx(N1(r,s),e),typeof i<"u")return lu(s,i)?cu(e,n,s,i):i}function bx(s,t){for(const e of t){if(!e)continue;const n=e[s];if(typeof n<"u")return n}}function rf(s){let t=s._keys;return t||(t=s._keys=Y1(s._scopes)),t}function Y1(s){const t=new Set;for(const e of s)for(const n of Object.keys(e).filter(i=>!i.startsWith("_")))t.add(n);return Array.from(t)}function Mx(s,t,e,n){const{iScale:i}=s,{key:r="r"}=this._parsing,o=new Array(n);let a,l,c,h;for(a=0,l=n;a<l;++a)c=a+e,h=t[c],o[a]={r:i.parse(hi(h,r),c)};return o}const j1=Number.EPSILON||1e-14,tr=(s,t)=>t<s.length&&!s[t].skip&&s[t],wx=s=>s==="x"?"y":"x";function J1(s,t,e,n){const i=s.skip?t:s,r=t,o=e.skip?t:e,a=Vc(r,i),l=Vc(o,r);let c=a/(a+l),h=l/(a+l);c=isNaN(c)?0:c,h=isNaN(h)?0:h;const u=n*c,d=n*h;return{previous:{x:r.x-u*(o.x-i.x),y:r.y-u*(o.y-i.y)},next:{x:r.x+d*(o.x-i.x),y:r.y+d*(o.y-i.y)}}}function Z1(s,t,e){const n=s.length;let i,r,o,a,l,c=tr(s,0);for(let h=0;h<n-1;++h)if(l=c,c=tr(s,h+1),!(!l||!c)){if(Fr(t[h],0,j1)){e[h]=e[h+1]=0;continue}i=e[h]/t[h],r=e[h+1]/t[h],a=Math.pow(i,2)+Math.pow(r,2),!(a<=9)&&(o=3/Math.sqrt(a),e[h]=i*o*t[h],e[h+1]=r*o*t[h])}}function $1(s,t,e="x"){const n=wx(e),i=s.length;let r,o,a,l=tr(s,0);for(let c=0;c<i;++c){if(o=a,a=l,l=tr(s,c+1),!a)continue;const h=a[e],u=a[n];o&&(r=(h-o[e])/3,a[`cp1${e}`]=h-r,a[`cp1${n}`]=u-r*t[c]),l&&(r=(l[e]-h)/3,a[`cp2${e}`]=h+r,a[`cp2${n}`]=u+r*t[c])}}function K1(s,t="x"){const e=wx(t),n=s.length,i=Array(n).fill(0),r=Array(n);let o,a,l,c=tr(s,0);for(o=0;o<n;++o)if(a=l,l=c,c=tr(s,o+1),!!l){if(c){const h=c[t]-l[t];i[o]=h!==0?(c[e]-l[e])/h:0}r[o]=a?c?gn(i[o-1])!==gn(i[o])?0:(i[o-1]+i[o])/2:i[o-1]:i[o]}Z1(s,i,r),$1(s,r,t)}function ma(s,t,e){return Math.max(Math.min(s,e),t)}function Q1(s,t){let e,n,i,r,o,a=Dn(s[0],t);for(e=0,n=s.length;e<n;++e)o=r,r=a,a=e<n-1&&Dn(s[e+1],t),r&&(i=s[e],o&&(i.cp1x=ma(i.cp1x,t.left,t.right),i.cp1y=ma(i.cp1y,t.top,t.bottom)),a&&(i.cp2x=ma(i.cp2x,t.left,t.right),i.cp2y=ma(i.cp2y,t.top,t.bottom)))}function tT(s,t,e,n,i){let r,o,a,l;if(t.spanGaps&&(s=s.filter(c=>!c.skip)),t.cubicInterpolationMode==="monotone")K1(s,i);else{let c=n?s[s.length-1]:s[0];for(r=0,o=s.length;r<o;++r)a=s[r],l=J1(c,a,s[Math.min(r+1,o-(n?0:1))%o],t.tension),a.cp1x=l.previous.x,a.cp1y=l.previous.y,a.cp2x=l.next.x,a.cp2y=l.next.y,c=a}t.capBezierPoints&&Q1(s,e)}function hu(){return typeof window<"u"&&typeof document<"u"}function uu(s){let t=s.parentNode;return t&&t.toString()==="[object ShadowRoot]"&&(t=t.host),t}function Oa(s,t,e){let n;return typeof s=="string"?(n=parseInt(s,10),s.indexOf("%")!==-1&&(n=n/100*t.parentNode[e])):n=s,n}const dl=s=>s.ownerDocument.defaultView.getComputedStyle(s,null);function eT(s,t){return dl(s).getPropertyValue(t)}const nT=["top","right","bottom","left"];function Ui(s,t,e){const n={};e=e?"-"+e:"";for(let i=0;i<4;i++){const r=nT[i];n[r]=parseFloat(s[t+"-"+r+e])||0}return n.width=n.left+n.right,n.height=n.top+n.bottom,n}const iT=(s,t,e)=>(s>0||t>0)&&(!e||!e.shadowRoot);function sT(s,t){const e=s.touches,n=e&&e.length?e[0]:s,{offsetX:i,offsetY:r}=n;let o=!1,a,l;if(iT(i,r,s.target))a=i,l=r;else{const c=t.getBoundingClientRect();a=n.clientX-c.left,l=n.clientY-c.top,o=!0}return{x:a,y:l,box:o}}function Ci(s,t){if("native"in s)return s;const{canvas:e,currentDevicePixelRatio:n}=t,i=dl(e),r=i.boxSizing==="border-box",o=Ui(i,"padding"),a=Ui(i,"border","width"),{x:l,y:c,box:h}=sT(s,e),u=o.left+(h&&a.left),d=o.top+(h&&a.top);let{width:f,height:p}=t;return r&&(f-=o.width+a.width,p-=o.height+a.height),{x:Math.round((l-u)/f*e.width/n),y:Math.round((c-d)/p*e.height/n)}}function rT(s,t,e){let n,i;if(t===void 0||e===void 0){const r=s&&uu(s);if(!r)t=s.clientWidth,e=s.clientHeight;else{const o=r.getBoundingClientRect(),a=dl(r),l=Ui(a,"border","width"),c=Ui(a,"padding");t=o.width-c.width-l.width,e=o.height-c.height-l.height,n=Oa(a.maxWidth,r,"clientWidth"),i=Oa(a.maxHeight,r,"clientHeight")}}return{width:t,height:e,maxWidth:n||ka,maxHeight:i||ka}}const ti=s=>Math.round(s*10)/10;function oT(s,t,e,n){const i=dl(s),r=Ui(i,"margin"),o=Oa(i.maxWidth,s,"clientWidth")||ka,a=Oa(i.maxHeight,s,"clientHeight")||ka,l=rT(s,t,e);let{width:c,height:h}=l;if(i.boxSizing==="content-box"){const d=Ui(i,"border","width"),f=Ui(i,"padding");c-=f.width+d.width,h-=f.height+d.height}return c=Math.max(0,c-r.width),h=Math.max(0,n?c/n:h-r.height),c=ti(Math.min(c,o,l.maxWidth)),h=ti(Math.min(h,a,l.maxHeight)),c&&!h&&(h=ti(c/2)),(t!==void 0||e!==void 0)&&n&&l.height&&h>l.height&&(h=l.height,c=ti(Math.floor(h*n))),{width:c,height:h}}function of(s,t,e){const n=t||1,i=ti(s.height*n),r=ti(s.width*n);s.height=ti(s.height),s.width=ti(s.width);const o=s.canvas;return o.style&&(e||!o.style.height&&!o.style.width)&&(o.style.height=`${s.height}px`,o.style.width=`${s.width}px`),s.currentDevicePixelRatio!==n||o.height!==i||o.width!==r?(s.currentDevicePixelRatio=n,o.height=i,o.width=r,s.ctx.setTransform(n,0,0,n,0,0),!0):!1}const aT=(function(){let s=!1;try{const t={get passive(){return s=!0,!1}};hu()&&(window.addEventListener("test",null,t),window.removeEventListener("test",null,t))}catch{}return s})();function af(s,t){const e=eT(s,t),n=e&&e.match(/^(\d+)(\.\d+)?px$/);return n?+n[1]:void 0}function Ri(s,t,e,n){return{x:s.x+e*(t.x-s.x),y:s.y+e*(t.y-s.y)}}function lT(s,t,e,n){return{x:s.x+e*(t.x-s.x),y:n==="middle"?e<.5?s.y:t.y:n==="after"?e<1?s.y:t.y:e>0?t.y:s.y}}function cT(s,t,e,n){const i={x:s.cp2x,y:s.cp2y},r={x:t.cp1x,y:t.cp1y},o=Ri(s,i,e),a=Ri(i,r,e),l=Ri(r,t,e),c=Ri(o,a,e),h=Ri(a,l,e);return Ri(c,h,e)}const hT=function(s,t){return{x(e){return s+s+t-e},setWidth(e){t=e},textAlign(e){return e==="center"?e:e==="right"?"left":"right"},xPlus(e,n){return e-n},leftForLtr(e,n){return e-n}}},uT=function(){return{x(s){return s},setWidth(s){},textAlign(s){return s},xPlus(s,t){return s+t},leftForLtr(s,t){return s}}};function Os(s,t,e){return s?hT(t,e):uT()}function Sx(s,t){let e,n;(t==="ltr"||t==="rtl")&&(e=s.canvas.style,n=[e.getPropertyValue("direction"),e.getPropertyPriority("direction")],e.setProperty("direction",t,"important"),s.prevTextDirection=n)}function Tx(s,t){t!==void 0&&(delete s.prevTextDirection,s.canvas.style.setProperty("direction",t[0],t[1]))}function Ex(s){return s==="angle"?{between:io,compare:u1,normalize:Ce}:{between:Pn,compare:(t,e)=>t-e,normalize:t=>t}}function lf({start:s,end:t,count:e,loop:n,style:i}){return{start:s%e,end:t%e,loop:n&&(t-s+1)%e===0,style:i}}function dT(s,t,e){const{property:n,start:i,end:r}=e,{between:o,normalize:a}=Ex(n),l=t.length;let{start:c,end:h,loop:u}=s,d,f;if(u){for(c+=l,h+=l,d=0,f=l;d<f&&o(a(t[c%l][n]),i,r);++d)c--,h--;c%=l,h%=l}return h<c&&(h+=l),{start:c,end:h,loop:u,style:s.style}}function Ax(s,t,e){if(!e)return[s];const{property:n,start:i,end:r}=e,o=t.length,{compare:a,between:l,normalize:c}=Ex(n),{start:h,end:u,loop:d,style:f}=dT(s,t,e),p=[];let m=!1,y=null,g,x,v;const _=()=>l(i,v,g)&&a(i,v)!==0,M=()=>a(r,g)===0||l(r,v,g),w=()=>m||_(),b=()=>!m||M();for(let E=h,P=h;E<=u;++E)x=t[E%o],!x.skip&&(g=c(x[n]),g!==v&&(m=l(g,i,r),y===null&&w()&&(y=a(g,i)===0?E:P),y!==null&&b()&&(p.push(lf({start:y,end:E,loop:d,count:o,style:f})),y=null),P=E,v=g));return y!==null&&p.push(lf({start:y,end:u,loop:d,count:o,style:f})),p}function Lx(s,t){const e=[],n=s.segments;for(let i=0;i<n.length;i++){const r=Ax(n[i],s.points,t);r.length&&e.push(...r)}return e}function fT(s,t,e,n){let i=0,r=t-1;if(e&&!n)for(;i<t&&!s[i].skip;)i++;for(;i<t&&s[i].skip;)i++;for(i%=t,e&&(r+=i);r>i&&s[r%t].skip;)r--;return r%=t,{start:i,end:r}}function pT(s,t,e,n){const i=s.length,r=[];let o=t,a=s[t],l;for(l=t+1;l<=e;++l){const c=s[l%i];c.skip||c.stop?a.skip||(n=!1,r.push({start:t%i,end:(l-1)%i,loop:n}),t=o=c.stop?l:null):(o=l,a.skip&&(t=l)),a=c}return o!==null&&r.push({start:t%i,end:o%i,loop:n}),r}function mT(s,t){const e=s.points,n=s.options.spanGaps,i=e.length;if(!i)return[];const r=!!s._loop,{start:o,end:a}=fT(e,i,r,n);if(n===!0)return cf(s,[{start:o,end:a,loop:r}],e,t);const l=a<o?a+i:a,c=!!s._fullLoop&&o===0&&a===i-1;return cf(s,pT(e,o,l,c),e,t)}function cf(s,t,e,n){return!n||!n.setContext||!e?t:gT(s,t,e,n)}function gT(s,t,e,n){const i=s._chart.getContext(),r=hf(s.options),{_datasetIndex:o,options:{spanGaps:a}}=s,l=e.length,c=[];let h=r,u=t[0].start,d=u;function f(p,m,y,g){const x=a?-1:1;if(p!==m){for(p+=l;e[p%l].skip;)p-=x;for(;e[m%l].skip;)m+=x;p%l!==m%l&&(c.push({start:p%l,end:m%l,loop:y,style:g}),h=g,u=m%l)}}for(const p of t){u=a?u:p.start;let m=e[u%l],y;for(d=u+1;d<=p.end;d++){const g=e[d%l];y=hf(n.setContext(mi(i,{type:"segment",p0:m,p1:g,p0DataIndex:(d-1)%l,p1DataIndex:d%l,datasetIndex:o}))),xT(y,h)&&f(u,d-1,p.loop,h),m=g,h=y}u<d-1&&f(u,d-1,p.loop,h)}return c}function hf(s){return{backgroundColor:s.backgroundColor,borderCapStyle:s.borderCapStyle,borderDash:s.borderDash,borderDashOffset:s.borderDashOffset,borderJoinStyle:s.borderJoinStyle,borderWidth:s.borderWidth,borderColor:s.borderColor}}function xT(s,t){if(!t)return!1;const e=[],n=function(i,r){return su(r)?(e.includes(r)||e.push(r),e.indexOf(r)):r};return JSON.stringify(s,n)!==JSON.stringify(t,n)}function ga(s,t,e){return s.options.clip?s[e]:t[e]}function yT(s,t){const{xScale:e,yScale:n}=s;return e&&n?{left:ga(e,t,"left"),right:ga(e,t,"right"),top:ga(n,t,"top"),bottom:ga(n,t,"bottom")}:t}function Cx(s,t){const e=t._clip;if(e.disabled)return!1;const n=yT(t,s.chartArea);return{left:e.left===!1?0:n.left-(e.left===!0?0:e.left),right:e.right===!1?s.width:n.right+(e.right===!0?0:e.right),top:e.top===!1?0:n.top-(e.top===!0?0:e.top),bottom:e.bottom===!1?s.height:n.bottom+(e.bottom===!0?0:e.bottom)}}/*!
 * Chart.js v4.5.1
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */class _T{constructor(){this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}_notify(t,e,n,i){const r=e.listeners[i],o=e.duration;r.forEach(a=>a({chart:t,initial:e.initial,numSteps:o,currentStep:Math.min(n-e.start,o)}))}_refresh(){this._request||(this._running=!0,this._request=dx.call(window,()=>{this._update(),this._request=null,this._running&&this._refresh()}))}_update(t=Date.now()){let e=0;this._charts.forEach((n,i)=>{if(!n.running||!n.items.length)return;const r=n.items;let o=r.length-1,a=!1,l;for(;o>=0;--o)l=r[o],l._active?(l._total>n.duration&&(n.duration=l._total),l.tick(t),a=!0):(r[o]=r[r.length-1],r.pop());a&&(i.draw(),this._notify(i,n,t,"progress")),r.length||(n.running=!1,this._notify(i,n,t,"complete"),n.initial=!1),e+=r.length}),this._lastDate=t,e===0&&(this._running=!1)}_getAnims(t){const e=this._charts;let n=e.get(t);return n||(n={running:!1,initial:!0,items:[],listeners:{complete:[],progress:[]}},e.set(t,n)),n}listen(t,e,n){this._getAnims(t).listeners[e].push(n)}add(t,e){!e||!e.length||this._getAnims(t).items.push(...e)}has(t){return this._getAnims(t).items.length>0}start(t){const e=this._charts.get(t);e&&(e.running=!0,e.start=Date.now(),e.duration=e.items.reduce((n,i)=>Math.max(n,i._duration),0),this._refresh())}running(t){if(!this._running)return!1;const e=this._charts.get(t);return!(!e||!e.running||!e.items.length)}stop(t){const e=this._charts.get(t);if(!e||!e.items.length)return;const n=e.items;let i=n.length-1;for(;i>=0;--i)n[i].cancel();e.items=[],this._notify(t,e,Date.now(),"complete")}remove(t){return this._charts.delete(t)}}var En=new _T;const uf="transparent",vT={boolean(s,t,e){return e>.5?t:s},color(s,t,e){const n=tf(s||uf),i=n.valid&&tf(t||uf);return i&&i.valid?i.mix(n,e).hexString():t},number(s,t,e){return s+(t-s)*e}};class bT{constructor(t,e,n,i){const r=e[n];i=pa([t.to,i,r,t.from]);const o=pa([t.from,r,i]);this._active=!0,this._fn=t.fn||vT[t.type||typeof o],this._easing=kr[t.easing]||kr.linear,this._start=Math.floor(Date.now()+(t.delay||0)),this._duration=this._total=Math.floor(t.duration),this._loop=!!t.loop,this._target=e,this._prop=n,this._from=o,this._to=i,this._promises=void 0}active(){return this._active}update(t,e,n){if(this._active){this._notify(!1);const i=this._target[this._prop],r=n-this._start,o=this._duration-r;this._start=n,this._duration=Math.floor(Math.max(o,t.duration)),this._total+=r,this._loop=!!t.loop,this._to=pa([t.to,e,i,t.from]),this._from=pa([t.from,i,e])}}cancel(){this._active&&(this.tick(Date.now()),this._active=!1,this._notify(!1))}tick(t){const e=t-this._start,n=this._duration,i=this._prop,r=this._from,o=this._loop,a=this._to;let l;if(this._active=r!==a&&(o||e<n),!this._active){this._target[i]=a,this._notify(!0);return}if(e<0){this._target[i]=r;return}l=e/n%2,l=o&&l>1?2-l:l,l=this._easing(Math.min(1,Math.max(0,l))),this._target[i]=this._fn(r,a,l)}wait(){const t=this._promises||(this._promises=[]);return new Promise((e,n)=>{t.push({res:e,rej:n})})}_notify(t){const e=t?"res":"rej",n=this._promises||[];for(let i=0;i<n.length;i++)n[i][e]()}}class Rx{constructor(t,e){this._chart=t,this._properties=new Map,this.configure(e)}configure(t){if(!kt(t))return;const e=Object.keys(te.animation),n=this._properties;Object.getOwnPropertyNames(t).forEach(i=>{const r=t[i];if(!kt(r))return;const o={};for(const a of e)o[a]=r[a];($t(r.properties)&&r.properties||[i]).forEach(a=>{(a===i||!n.has(a))&&n.set(a,o)})})}_animateOptions(t,e){const n=e.options,i=wT(t,n);if(!i)return[];const r=this._createAnimations(i,n);return n.$shared&&MT(t.options.$animations,n).then(()=>{t.options=n},()=>{}),r}_createAnimations(t,e){const n=this._properties,i=[],r=t.$animations||(t.$animations={}),o=Object.keys(e),a=Date.now();let l;for(l=o.length-1;l>=0;--l){const c=o[l];if(c.charAt(0)==="$")continue;if(c==="options"){i.push(...this._animateOptions(t,e));continue}const h=e[c];let u=r[c];const d=n.get(c);if(u)if(d&&u.active()){u.update(d,h,a);continue}else u.cancel();if(!d||!d.duration){t[c]=h;continue}r[c]=u=new bT(d,t,c,h),i.push(u)}return i}update(t,e){if(this._properties.size===0){Object.assign(t,e);return}const n=this._createAnimations(t,e);if(n.length)return En.add(this._chart,n),!0}}function MT(s,t){const e=[],n=Object.keys(t);for(let i=0;i<n.length;i++){const r=s[n[i]];r&&r.active()&&e.push(r.wait())}return Promise.all(e)}function wT(s,t){if(!t)return;let e=s.options;if(!e){s.options=t;return}return e.$shared&&(s.options=e=Object.assign({},e,{$shared:!1,$animations:{}})),e}function df(s,t){const e=s&&s.options||{},n=e.reverse,i=e.min===void 0?t:0,r=e.max===void 0?t:0;return{start:n?r:i,end:n?i:r}}function ST(s,t,e){if(e===!1)return!1;const n=df(s,e),i=df(t,e);return{top:i.end,right:n.end,bottom:i.start,left:n.start}}function TT(s){let t,e,n,i;return kt(s)?(t=s.top,e=s.right,n=s.bottom,i=s.left):t=e=n=i=s,{top:t,right:e,bottom:n,left:i,disabled:s===!1}}function Px(s,t){const e=[],n=s._getSortedDatasetMetas(t);let i,r;for(i=0,r=n.length;i<r;++i)e.push(n[i].index);return e}function ff(s,t,e,n={}){const i=s.keys,r=n.mode==="single";let o,a,l,c;if(t===null)return;let h=!1;for(o=0,a=i.length;o<a;++o){if(l=+i[o],l===e){if(h=!0,n.all)continue;break}c=s.values[l],xe(c)&&(r||t===0||gn(t)===gn(c))&&(t+=c)}return!h&&!n.all?0:t}function ET(s,t){const{iScale:e,vScale:n}=t,i=e.axis==="x"?"x":"y",r=n.axis==="x"?"x":"y",o=Object.keys(s),a=new Array(o.length);let l,c,h;for(l=0,c=o.length;l<c;++l)h=o[l],a[l]={[i]:h,[r]:s[h]};return a}function oc(s,t){const e=s&&s.options.stacked;return e||e===void 0&&t.stack!==void 0}function AT(s,t,e){return`${s.id}.${t.id}.${e.stack||e.type}`}function LT(s){const{min:t,max:e,minDefined:n,maxDefined:i}=s.getUserBounds();return{min:n?t:Number.NEGATIVE_INFINITY,max:i?e:Number.POSITIVE_INFINITY}}function CT(s,t,e){const n=s[t]||(s[t]={});return n[e]||(n[e]={})}function pf(s,t,e,n){for(const i of t.getMatchingVisibleMetas(n).reverse()){const r=s[i.index];if(e&&r>0||!e&&r<0)return i.index}return null}function mf(s,t){const{chart:e,_cachedMeta:n}=s,i=e._stacks||(e._stacks={}),{iScale:r,vScale:o,index:a}=n,l=r.axis,c=o.axis,h=AT(r,o,n),u=t.length;let d;for(let f=0;f<u;++f){const p=t[f],{[l]:m,[c]:y}=p,g=p._stacks||(p._stacks={});d=g[c]=CT(i,h,m),d[a]=y,d._top=pf(d,o,!0,n.type),d._bottom=pf(d,o,!1,n.type);const x=d._visualValues||(d._visualValues={});x[a]=y}}function ac(s,t){const e=s.scales;return Object.keys(e).filter(n=>e[n].axis===t).shift()}function RT(s,t){return mi(s,{active:!1,dataset:void 0,datasetIndex:t,index:t,mode:"default",type:"dataset"})}function PT(s,t,e){return mi(s,{active:!1,dataIndex:t,parsed:void 0,raw:void 0,element:e,index:t,mode:"default",type:"data"})}function vr(s,t){const e=s.controller.index,n=s.vScale&&s.vScale.axis;if(n){t=t||s._parsed;for(const i of t){const r=i._stacks;if(!r||r[n]===void 0||r[n][e]===void 0)return;delete r[n][e],r[n]._visualValues!==void 0&&r[n]._visualValues[e]!==void 0&&delete r[n]._visualValues[e]}}}const lc=s=>s==="reset"||s==="none",gf=(s,t)=>t?s:Object.assign({},s),DT=(s,t,e)=>s&&!t.hidden&&t._stacked&&{keys:Px(e,!0),values:null};class as{static defaults={};static datasetElementType=null;static dataElementType=null;constructor(t,e){this.chart=t,this._ctx=t.ctx,this.index=e,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.supportsDecimation=!1,this.$context=void 0,this._syncList=[],this.datasetElementType=new.target.datasetElementType,this.dataElementType=new.target.dataElementType,this.initialize()}initialize(){const t=this._cachedMeta;this.configure(),this.linkScales(),t._stacked=oc(t.vScale,t),this.addElements(),this.options.fill&&!this.chart.isPluginEnabled("filler")&&console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options")}updateIndex(t){this.index!==t&&vr(this._cachedMeta),this.index=t}linkScales(){const t=this.chart,e=this._cachedMeta,n=this.getDataset(),i=(u,d,f,p)=>u==="x"?d:u==="r"?p:f,r=e.xAxisID=Pt(n.xAxisID,ac(t,"x")),o=e.yAxisID=Pt(n.yAxisID,ac(t,"y")),a=e.rAxisID=Pt(n.rAxisID,ac(t,"r")),l=e.indexAxis,c=e.iAxisID=i(l,r,o,a),h=e.vAxisID=i(l,o,r,a);e.xScale=this.getScaleForId(r),e.yScale=this.getScaleForId(o),e.rScale=this.getScaleForId(a),e.iScale=this.getScaleForId(c),e.vScale=this.getScaleForId(h)}getDataset(){return this.chart.data.datasets[this.index]}getMeta(){return this.chart.getDatasetMeta(this.index)}getScaleForId(t){return this.chart.scales[t]}_getOtherScale(t){const e=this._cachedMeta;return t===e.iScale?e.vScale:e.iScale}reset(){this._update("reset")}_destroy(){const t=this._cachedMeta;this._data&&$d(this._data,this),t._stacked&&vr(t)}_dataCheck(){const t=this.getDataset(),e=t.data||(t.data=[]),n=this._data;if(kt(e)){const i=this._cachedMeta;this._data=ET(e,i)}else if(n!==e){if(n){$d(n,this);const i=this._cachedMeta;vr(i),i._parsed=[]}e&&Object.isExtensible(e)&&m1(e,this),this._syncList=[],this._data=e}}addElements(){const t=this._cachedMeta;this._dataCheck(),this.datasetElementType&&(t.dataset=new this.datasetElementType)}buildOrUpdateElements(t){const e=this._cachedMeta,n=this.getDataset();let i=!1;this._dataCheck();const r=e._stacked;e._stacked=oc(e.vScale,e),e.stack!==n.stack&&(i=!0,vr(e),e.stack=n.stack),this._resyncElements(t),(i||r!==e._stacked)&&(mf(this,e._parsed),e._stacked=oc(e.vScale,e))}configure(){const t=this.chart.config,e=t.datasetScopeKeys(this._type),n=t.getOptionScopes(this.getDataset(),e,!0);this.options=t.createResolver(n,this.getContext()),this._parsing=this.options.parsing,this._cachedDataOpts={}}parse(t,e){const{_cachedMeta:n,_data:i}=this,{iScale:r,_stacked:o}=n,a=r.axis;let l=t===0&&e===i.length?!0:n._sorted,c=t>0&&n._parsed[t-1],h,u,d;if(this._parsing===!1)n._parsed=i,n._sorted=!0,d=i;else{$t(i[t])?d=this.parseArrayData(n,i,t,e):kt(i[t])?d=this.parseObjectData(n,i,t,e):d=this.parsePrimitiveData(n,i,t,e);const f=()=>u[a]===null||c&&u[a]<c[a];for(h=0;h<e;++h)n._parsed[h+t]=u=d[h],l&&(f()&&(l=!1),c=u);n._sorted=l}o&&mf(this,d)}parsePrimitiveData(t,e,n,i){const{iScale:r,vScale:o}=t,a=r.axis,l=o.axis,c=r.getLabels(),h=r===o,u=new Array(i);let d,f,p;for(d=0,f=i;d<f;++d)p=d+n,u[d]={[a]:h||r.parse(c[p],p),[l]:o.parse(e[p],p)};return u}parseArrayData(t,e,n,i){const{xScale:r,yScale:o}=t,a=new Array(i);let l,c,h,u;for(l=0,c=i;l<c;++l)h=l+n,u=e[h],a[l]={x:r.parse(u[0],h),y:o.parse(u[1],h)};return a}parseObjectData(t,e,n,i){const{xScale:r,yScale:o}=t,{xAxisKey:a="x",yAxisKey:l="y"}=this._parsing,c=new Array(i);let h,u,d,f;for(h=0,u=i;h<u;++h)d=h+n,f=e[d],c[h]={x:r.parse(hi(f,a),d),y:o.parse(hi(f,l),d)};return c}getParsed(t){return this._cachedMeta._parsed[t]}getDataElement(t){return this._cachedMeta.data[t]}applyStack(t,e,n){const i=this.chart,r=this._cachedMeta,o=e[t.axis],a={keys:Px(i,!0),values:e._stacks[t.axis]._visualValues};return ff(a,o,r.index,{mode:n})}updateRangeFromParsed(t,e,n,i){const r=n[e.axis];let o=r===null?NaN:r;const a=i&&n._stacks[e.axis];i&&a&&(i.values=a,o=ff(i,r,this._cachedMeta.index)),t.min=Math.min(t.min,o),t.max=Math.max(t.max,o)}getMinMax(t,e){const n=this._cachedMeta,i=n._parsed,r=n._sorted&&t===n.iScale,o=i.length,a=this._getOtherScale(t),l=DT(e,n,this.chart),c={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},{min:h,max:u}=LT(a);let d,f;function p(){f=i[d];const m=f[a.axis];return!xe(f[t.axis])||h>m||u<m}for(d=0;d<o&&!(!p()&&(this.updateRangeFromParsed(c,t,f,l),r));++d);if(r){for(d=o-1;d>=0;--d)if(!p()){this.updateRangeFromParsed(c,t,f,l);break}}return c}getAllParsedValues(t){const e=this._cachedMeta._parsed,n=[];let i,r,o;for(i=0,r=e.length;i<r;++i)o=e[i][t.axis],xe(o)&&n.push(o);return n}getMaxOverflow(){return!1}getLabelAndValue(t){const e=this._cachedMeta,n=e.iScale,i=e.vScale,r=this.getParsed(t);return{label:n?""+n.getLabelForValue(r[n.axis]):"",value:i?""+i.getLabelForValue(r[i.axis]):""}}_update(t){const e=this._cachedMeta;this.update(t||"default"),e._clip=TT(Pt(this.options.clip,ST(e.xScale,e.yScale,this.getMaxOverflow())))}update(t){}draw(){const t=this._ctx,e=this.chart,n=this._cachedMeta,i=n.data||[],r=e.chartArea,o=[],a=this._drawStart||0,l=this._drawCount||i.length-a,c=this.options.drawActiveElementsOnTop;let h;for(n.dataset&&n.dataset.draw(t,r,a,l),h=a;h<a+l;++h){const u=i[h];u.hidden||(u.active&&c?o.push(u):u.draw(t,r))}for(h=0;h<o.length;++h)o[h].draw(t,r)}getStyle(t,e){const n=e?"active":"default";return t===void 0&&this._cachedMeta.dataset?this.resolveDatasetElementOptions(n):this.resolveDataElementOptions(t||0,n)}getContext(t,e,n){const i=this.getDataset();let r;if(t>=0&&t<this._cachedMeta.data.length){const o=this._cachedMeta.data[t];r=o.$context||(o.$context=PT(this.getContext(),t,o)),r.parsed=this.getParsed(t),r.raw=i.data[t],r.index=r.dataIndex=t}else r=this.$context||(this.$context=RT(this.chart.getContext(),this.index)),r.dataset=i,r.index=r.datasetIndex=this.index;return r.active=!!e,r.mode=n,r}resolveDatasetElementOptions(t){return this._resolveElementOptions(this.datasetElementType.id,t)}resolveDataElementOptions(t,e){return this._resolveElementOptions(this.dataElementType.id,e,t)}_resolveElementOptions(t,e="default",n){const i=e==="active",r=this._cachedDataOpts,o=t+"-"+e,a=r[o],l=this.enableOptionSharing&&no(n);if(a)return gf(a,l);const c=this.chart.config,h=c.datasetElementScopeKeys(this._type,t),u=i?[`${t}Hover`,"hover",t,""]:[t,""],d=c.getOptionScopes(this.getDataset(),h),f=Object.keys(te.elements[t]),p=()=>this.getContext(n,i,e),m=c.resolveNamedOptions(d,f,p,u);return m.$shared&&(m.$shared=l,r[o]=Object.freeze(gf(m,l))),m}_resolveAnimations(t,e,n){const i=this.chart,r=this._cachedDataOpts,o=`animation-${e}`,a=r[o];if(a)return a;let l;if(i.options.animation!==!1){const h=this.chart.config,u=h.datasetAnimationScopeKeys(this._type,e),d=h.getOptionScopes(this.getDataset(),u);l=h.createResolver(d,this.getContext(t,n,e))}const c=new Rx(i,l&&l.animations);return l&&l._cacheable&&(r[o]=Object.freeze(c)),c}getSharedOptions(t){if(t.$shared)return this._sharedOptions||(this._sharedOptions=Object.assign({},t))}includeOptions(t,e){return!e||lc(t)||this.chart._animationsDisabled}_getSharedOptions(t,e){const n=this.resolveDataElementOptions(t,e),i=this._sharedOptions,r=this.getSharedOptions(n),o=this.includeOptions(e,r)||r!==i;return this.updateSharedOptions(r,e,n),{sharedOptions:r,includeOptions:o}}updateElement(t,e,n,i){lc(i)?Object.assign(t,n):this._resolveAnimations(e,i).update(t,n)}updateSharedOptions(t,e,n){t&&!lc(e)&&this._resolveAnimations(void 0,e).update(t,n)}_setStyle(t,e,n,i){t.active=i;const r=this.getStyle(e,i);this._resolveAnimations(e,n,i).update(t,{options:!i&&this.getSharedOptions(r)||r})}removeHoverStyle(t,e,n){this._setStyle(t,n,"active",!1)}setHoverStyle(t,e,n){this._setStyle(t,n,"active",!0)}_removeDatasetHoverStyle(){const t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,"active",!1)}_setDatasetHoverStyle(){const t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,"active",!0)}_resyncElements(t){const e=this._data,n=this._cachedMeta.data;for(const[a,l,c]of this._syncList)this[a](l,c);this._syncList=[];const i=n.length,r=e.length,o=Math.min(r,i);o&&this.parse(0,o),r>i?this._insertElements(i,r-i,t):r<i&&this._removeElements(r,i-r)}_insertElements(t,e,n=!0){const i=this._cachedMeta,r=i.data,o=t+e;let a;const l=c=>{for(c.length+=e,a=c.length-1;a>=o;a--)c[a]=c[a-e]};for(l(r),a=t;a<o;++a)r[a]=new this.dataElementType;this._parsing&&l(i._parsed),this.parse(t,e),n&&this.updateElements(r,t,e,"reset")}updateElements(t,e,n,i){}_removeElements(t,e){const n=this._cachedMeta;if(this._parsing){const i=n._parsed.splice(t,e);n._stacked&&vr(n,i)}n.data.splice(t,e)}_sync(t){if(this._parsing)this._syncList.push(t);else{const[e,n,i]=t;this[e](n,i)}this.chart._dataChanges.push([this.index,...t])}_onDataPush(){const t=arguments.length;this._sync(["_insertElements",this.getDataset().data.length-t,t])}_onDataPop(){this._sync(["_removeElements",this._cachedMeta.data.length-1,1])}_onDataShift(){this._sync(["_removeElements",0,1])}_onDataSplice(t,e){e&&this._sync(["_removeElements",t,e]);const n=arguments.length-2;n&&this._sync(["_insertElements",t,n])}_onDataUnshift(){this._sync(["_insertElements",0,arguments.length])}}function IT(s,t){if(!s._cache.$bar){const e=s.getMatchingVisibleMetas(t);let n=[];for(let i=0,r=e.length;i<r;i++)n=n.concat(e[i].controller.getAllParsedValues(s));s._cache.$bar=ux(n.sort((i,r)=>i-r))}return s._cache.$bar}function FT(s){const t=s.iScale,e=IT(t,s.type);let n=t._length,i,r,o,a;const l=()=>{o===32767||o===-32768||(no(a)&&(n=Math.min(n,Math.abs(o-a)||n)),a=o)};for(i=0,r=e.length;i<r;++i)o=t.getPixelForValue(e[i]),l();for(a=void 0,i=0,r=t.ticks.length;i<r;++i)o=t.getPixelForTick(i),l();return n}function kT(s,t,e,n){const i=e.barThickness;let r,o;return zt(i)?(r=t.min*e.categoryPercentage,o=e.barPercentage):(r=i*n,o=1),{chunk:r/n,ratio:o,start:t.pixels[s]-r/2}}function BT(s,t,e,n){const i=t.pixels,r=i[s];let o=s>0?i[s-1]:null,a=s<i.length-1?i[s+1]:null;const l=e.categoryPercentage;o===null&&(o=r-(a===null?t.end-t.start:a-r)),a===null&&(a=r+r-o);const c=r-(r-Math.min(o,a))/2*l;return{chunk:Math.abs(a-o)/2*l/n,ratio:e.barPercentage,start:c}}function OT(s,t,e,n){const i=e.parse(s[0],n),r=e.parse(s[1],n),o=Math.min(i,r),a=Math.max(i,r);let l=o,c=a;Math.abs(o)>Math.abs(a)&&(l=a,c=o),t[e.axis]=c,t._custom={barStart:l,barEnd:c,start:i,end:r,min:o,max:a}}function Dx(s,t,e,n){return $t(s)?OT(s,t,e,n):t[e.axis]=e.parse(s,n),t}function xf(s,t,e,n){const i=s.iScale,r=s.vScale,o=i.getLabels(),a=i===r,l=[];let c,h,u,d;for(c=e,h=e+n;c<h;++c)d=t[c],u={},u[i.axis]=a||i.parse(o[c],c),l.push(Dx(d,u,r,c));return l}function cc(s){return s&&s.barStart!==void 0&&s.barEnd!==void 0}function zT(s,t,e){return s!==0?gn(s):(t.isHorizontal()?1:-1)*(t.min>=e?1:-1)}function NT(s){let t,e,n,i,r;return s.horizontal?(t=s.base>s.x,e="left",n="right"):(t=s.base<s.y,e="bottom",n="top"),t?(i="end",r="start"):(i="start",r="end"),{start:e,end:n,reverse:t,top:i,bottom:r}}function HT(s,t,e,n){let i=t.borderSkipped;const r={};if(!i){s.borderSkipped=r;return}if(i===!0){s.borderSkipped={top:!0,right:!0,bottom:!0,left:!0};return}const{start:o,end:a,reverse:l,top:c,bottom:h}=NT(s);i==="middle"&&e&&(s.enableBorderRadius=!0,(e._top||0)===n?i=c:(e._bottom||0)===n?i=h:(r[yf(h,o,a,l)]=!0,i=c)),r[yf(i,o,a,l)]=!0,s.borderSkipped=r}function yf(s,t,e,n){return n?(s=UT(s,t,e),s=_f(s,e,t)):s=_f(s,t,e),s}function UT(s,t,e){return s===t?e:s===e?t:s}function _f(s,t,e){return s==="start"?t:s==="end"?e:s}function VT(s,{inflateAmount:t},e){s.inflateAmount=t==="auto"?e===1?.33:0:t}class WT extends as{static id="bar";static defaults={datasetElementType:!1,dataElementType:"bar",categoryPercentage:.8,barPercentage:.9,grouped:!0,animations:{numbers:{type:"number",properties:["x","y","base","width","height"]}}};static overrides={scales:{_index_:{type:"category",offset:!0,grid:{offset:!0}},_value_:{type:"linear",beginAtZero:!0}}};parsePrimitiveData(t,e,n,i){return xf(t,e,n,i)}parseArrayData(t,e,n,i){return xf(t,e,n,i)}parseObjectData(t,e,n,i){const{iScale:r,vScale:o}=t,{xAxisKey:a="x",yAxisKey:l="y"}=this._parsing,c=r.axis==="x"?a:l,h=o.axis==="x"?a:l,u=[];let d,f,p,m;for(d=n,f=n+i;d<f;++d)m=e[d],p={},p[r.axis]=r.parse(hi(m,c),d),u.push(Dx(hi(m,h),p,o,d));return u}updateRangeFromParsed(t,e,n,i){super.updateRangeFromParsed(t,e,n,i);const r=n._custom;r&&e===this._cachedMeta.vScale&&(t.min=Math.min(t.min,r.min),t.max=Math.max(t.max,r.max))}getMaxOverflow(){return 0}getLabelAndValue(t){const e=this._cachedMeta,{iScale:n,vScale:i}=e,r=this.getParsed(t),o=r._custom,a=cc(o)?"["+o.start+", "+o.end+"]":""+i.getLabelForValue(r[i.axis]);return{label:""+n.getLabelForValue(r[n.axis]),value:a}}initialize(){this.enableOptionSharing=!0,super.initialize();const t=this._cachedMeta;t.stack=this.getDataset().stack}update(t){const e=this._cachedMeta;this.updateElements(e.data,0,e.data.length,t)}updateElements(t,e,n,i){const r=i==="reset",{index:o,_cachedMeta:{vScale:a}}=this,l=a.getBasePixel(),c=a.isHorizontal(),h=this._getRuler(),{sharedOptions:u,includeOptions:d}=this._getSharedOptions(e,i);for(let f=e;f<e+n;f++){const p=this.getParsed(f),m=r||zt(p[a.axis])?{base:l,head:l}:this._calculateBarValuePixels(f),y=this._calculateBarIndexPixels(f,h),g=(p._stacks||{})[a.axis],x={horizontal:c,base:m.base,enableBorderRadius:!g||cc(p._custom)||o===g._top||o===g._bottom,x:c?m.head:y.center,y:c?y.center:m.head,height:c?y.size:Math.abs(m.size),width:c?Math.abs(m.size):y.size};d&&(x.options=u||this.resolveDataElementOptions(f,t[f].active?"active":i));const v=x.options||t[f].options;HT(x,v,g,o),VT(x,v,h.ratio),this.updateElement(t[f],f,x,i)}}_getStacks(t,e){const{iScale:n}=this._cachedMeta,i=n.getMatchingVisibleMetas(this._type).filter(h=>h.controller.options.grouped),r=n.options.stacked,o=[],a=this._cachedMeta.controller.getParsed(e),l=a&&a[n.axis],c=h=>{const u=h._parsed.find(f=>f[n.axis]===l),d=u&&u[h.vScale.axis];if(zt(d)||isNaN(d))return!0};for(const h of i)if(!(e!==void 0&&c(h))&&((r===!1||o.indexOf(h.stack)===-1||r===void 0&&h.stack===void 0)&&o.push(h.stack),h.index===t))break;return o.length||o.push(void 0),o}_getStackCount(t){return this._getStacks(void 0,t).length}_getAxisCount(){return this._getAxis().length}getFirstScaleIdForIndexAxis(){const t=this.chart.scales,e=this.chart.options.indexAxis;return Object.keys(t).filter(n=>t[n].axis===e).shift()}_getAxis(){const t={},e=this.getFirstScaleIdForIndexAxis();for(const n of this.chart.data.datasets)t[Pt(this.chart.options.indexAxis==="x"?n.xAxisID:n.yAxisID,e)]=!0;return Object.keys(t)}_getStackIndex(t,e,n){const i=this._getStacks(t,n),r=e!==void 0?i.indexOf(e):-1;return r===-1?i.length-1:r}_getRuler(){const t=this.options,e=this._cachedMeta,n=e.iScale,i=[];let r,o;for(r=0,o=e.data.length;r<o;++r)i.push(n.getPixelForValue(this.getParsed(r)[n.axis],r));const a=t.barThickness;return{min:a||FT(e),pixels:i,start:n._startPixel,end:n._endPixel,stackCount:this._getStackCount(),scale:n,grouped:t.grouped,ratio:a?1:t.categoryPercentage*t.barPercentage}}_calculateBarValuePixels(t){const{_cachedMeta:{vScale:e,_stacked:n,index:i},options:{base:r,minBarLength:o}}=this,a=r||0,l=this.getParsed(t),c=l._custom,h=cc(c);let u=l[e.axis],d=0,f=n?this.applyStack(e,l,n):u,p,m;f!==u&&(d=f-u,f=u),h&&(u=c.barStart,f=c.barEnd-c.barStart,u!==0&&gn(u)!==gn(c.barEnd)&&(d=0),d+=u);const y=!zt(r)&&!h?r:d;let g=e.getPixelForValue(y);if(this.chart.getDataVisibility(t)?p=e.getPixelForValue(d+f):p=g,m=p-g,Math.abs(m)<o){m=zT(m,e,a)*o,u===a&&(g-=m/2);const x=e.getPixelForDecimal(0),v=e.getPixelForDecimal(1),_=Math.min(x,v),M=Math.max(x,v);g=Math.max(Math.min(g,M),_),p=g+m,n&&!h&&(l._stacks[e.axis]._visualValues[i]=e.getValueForPixel(p)-e.getValueForPixel(g))}if(g===e.getPixelForValue(a)){const x=gn(m)*e.getLineWidthForValue(a)/2;g+=x,m-=x}return{size:m,base:g,head:p,center:p+m/2}}_calculateBarIndexPixels(t,e){const n=e.scale,i=this.options,r=i.skipNull,o=Pt(i.maxBarThickness,1/0);let a,l;const c=this._getAxisCount();if(e.grouped){const h=r?this._getStackCount(t):e.stackCount,u=i.barThickness==="flex"?BT(t,e,i,h*c):kT(t,e,i,h*c),d=this.chart.options.indexAxis==="x"?this.getDataset().xAxisID:this.getDataset().yAxisID,f=this._getAxis().indexOf(Pt(d,this.getFirstScaleIdForIndexAxis())),p=this._getStackIndex(this.index,this._cachedMeta.stack,r?t:void 0)+f;a=u.start+u.chunk*p+u.chunk/2,l=Math.min(o,u.chunk*u.ratio)}else a=n.getPixelForValue(this.getParsed(t)[n.axis],t),l=Math.min(o,e.min*e.ratio);return{base:a-l/2,head:a+l/2,center:a,size:l}}draw(){const t=this._cachedMeta,e=t.vScale,n=t.data,i=n.length;let r=0;for(;r<i;++r)this.getParsed(r)[e.axis]!==null&&!n[r].hidden&&n[r].draw(this._ctx)}}function GT(s,t,e){let n=1,i=1,r=0,o=0;if(t<Zt){const a=s,l=a+t,c=Math.cos(a),h=Math.sin(a),u=Math.cos(l),d=Math.sin(l),f=(v,_,M)=>io(v,a,l,!0)?1:Math.max(_,_*e,M,M*e),p=(v,_,M)=>io(v,a,l,!0)?-1:Math.min(_,_*e,M,M*e),m=f(0,c,u),y=f(oe,h,d),g=p(Vt,c,u),x=p(Vt+oe,h,d);n=(m-g)/2,i=(y-x)/2,r=-(m+g)/2,o=-(y+x)/2}return{ratioX:n,ratioY:i,offsetX:r,offsetY:o}}class Ix extends as{static id="doughnut";static defaults={datasetElementType:!1,dataElementType:"arc",animation:{animateRotate:!0,animateScale:!1},animations:{numbers:{type:"number",properties:["circumference","endAngle","innerRadius","outerRadius","startAngle","x","y","offset","borderWidth","spacing"]}},cutout:"50%",rotation:0,circumference:360,radius:"100%",spacing:0,indexAxis:"r"};static descriptors={_scriptable:t=>t!=="spacing",_indexable:t=>t!=="spacing"&&!t.startsWith("borderDash")&&!t.startsWith("hoverBorderDash")};static overrides={aspectRatio:1,plugins:{legend:{labels:{generateLabels(t){const e=t.data,{labels:{pointStyle:n,textAlign:i,color:r,useBorderRadius:o,borderRadius:a}}=t.legend.options;return e.labels.length&&e.datasets.length?e.labels.map((l,c)=>{const u=t.getDatasetMeta(0).controller.getStyle(c);return{text:l,fillStyle:u.backgroundColor,fontColor:r,hidden:!t.getDataVisibility(c),lineDash:u.borderDash,lineDashOffset:u.borderDashOffset,lineJoin:u.borderJoinStyle,lineWidth:u.borderWidth,strokeStyle:u.borderColor,textAlign:i,pointStyle:n,borderRadius:o&&(a||u.borderRadius),index:c}}):[]}},onClick(t,e,n){n.chart.toggleDataVisibility(e.index),n.chart.update()}}}};constructor(t,e){super(t,e),this.enableOptionSharing=!0,this.innerRadius=void 0,this.outerRadius=void 0,this.offsetX=void 0,this.offsetY=void 0}linkScales(){}parse(t,e){const n=this.getDataset().data,i=this._cachedMeta;if(this._parsing===!1)i._parsed=n;else{let r=l=>+n[l];if(kt(n[t])){const{key:l="value"}=this._parsing;r=c=>+hi(n[c],l)}let o,a;for(o=t,a=t+e;o<a;++o)i._parsed[o]=r(o)}}_getRotation(){return en(this.options.rotation-90)}_getCircumference(){return en(this.options.circumference)}_getRotationExtents(){let t=Zt,e=-Zt;for(let n=0;n<this.chart.data.datasets.length;++n)if(this.chart.isDatasetVisible(n)&&this.chart.getDatasetMeta(n).type===this._type){const i=this.chart.getDatasetMeta(n).controller,r=i._getRotation(),o=i._getCircumference();t=Math.min(t,r),e=Math.max(e,r+o)}return{rotation:t,circumference:e-t}}update(t){const e=this.chart,{chartArea:n}=e,i=this._cachedMeta,r=i.data,o=this.getMaxBorderWidth()+this.getMaxOffset(r)+this.options.spacing,a=Math.max((Math.min(n.width,n.height)-o)/2,0),l=Math.min(QS(this.options.cutout,a),1),c=this._getRingWeight(this.index),{circumference:h,rotation:u}=this._getRotationExtents(),{ratioX:d,ratioY:f,offsetX:p,offsetY:m}=GT(u,h,l),y=(n.width-o)/d,g=(n.height-o)/f,x=Math.max(Math.min(y,g)/2,0),v=ox(this.options.radius,x),_=Math.max(v*l,0),M=(v-_)/this._getVisibleDatasetWeightTotal();this.offsetX=p*v,this.offsetY=m*v,i.total=this.calculateTotal(),this.outerRadius=v-M*this._getRingWeightOffset(this.index),this.innerRadius=Math.max(this.outerRadius-M*c,0),this.updateElements(r,0,r.length,t)}_circumference(t,e){const n=this.options,i=this._cachedMeta,r=this._getCircumference();return e&&n.animation.animateRotate||!this.chart.getDataVisibility(t)||i._parsed[t]===null||i.data[t].hidden?0:this.calculateCircumference(i._parsed[t]*r/Zt)}updateElements(t,e,n,i){const r=i==="reset",o=this.chart,a=o.chartArea,c=o.options.animation,h=(a.left+a.right)/2,u=(a.top+a.bottom)/2,d=r&&c.animateScale,f=d?0:this.innerRadius,p=d?0:this.outerRadius,{sharedOptions:m,includeOptions:y}=this._getSharedOptions(e,i);let g=this._getRotation(),x;for(x=0;x<e;++x)g+=this._circumference(x,r);for(x=e;x<e+n;++x){const v=this._circumference(x,r),_=t[x],M={x:h+this.offsetX,y:u+this.offsetY,startAngle:g,endAngle:g+v,circumference:v,outerRadius:p,innerRadius:f};y&&(M.options=m||this.resolveDataElementOptions(x,_.active?"active":i)),g+=v,this.updateElement(_,x,M,i)}}calculateTotal(){const t=this._cachedMeta,e=t.data;let n=0,i;for(i=0;i<e.length;i++){const r=t._parsed[i];r!==null&&!isNaN(r)&&this.chart.getDataVisibility(i)&&!e[i].hidden&&(n+=Math.abs(r))}return n}calculateCircumference(t){const e=this._cachedMeta.total;return e>0&&!isNaN(t)?Zt*(Math.abs(t)/e):0}getLabelAndValue(t){const e=this._cachedMeta,n=this.chart,i=n.data.labels||[],r=cl(e._parsed[t],n.options.locale);return{label:i[t]||"",value:r}}getMaxBorderWidth(t){let e=0;const n=this.chart;let i,r,o,a,l;if(!t){for(i=0,r=n.data.datasets.length;i<r;++i)if(n.isDatasetVisible(i)){o=n.getDatasetMeta(i),t=o.data,a=o.controller;break}}if(!t)return 0;for(i=0,r=t.length;i<r;++i)l=a.resolveDataElementOptions(i),l.borderAlign!=="inner"&&(e=Math.max(e,l.borderWidth||0,l.hoverBorderWidth||0));return e}getMaxOffset(t){let e=0;for(let n=0,i=t.length;n<i;++n){const r=this.resolveDataElementOptions(n);e=Math.max(e,r.offset||0,r.hoverOffset||0)}return e}_getRingWeightOffset(t){let e=0;for(let n=0;n<t;++n)this.chart.isDatasetVisible(n)&&(e+=this._getRingWeight(n));return e}_getRingWeight(t){return Math.max(Pt(this.chart.data.datasets[t].weight,1),0)}_getVisibleDatasetWeightTotal(){return this._getRingWeightOffset(this.chart.data.datasets.length)||1}}class XT extends as{static id="line";static defaults={datasetElementType:"line",dataElementType:"point",showLine:!0,spanGaps:!1};static overrides={scales:{_index_:{type:"category"},_value_:{type:"linear"}}};initialize(){this.enableOptionSharing=!0,this.supportsDecimation=!0,super.initialize()}update(t){const e=this._cachedMeta,{dataset:n,data:i=[],_dataset:r}=e,o=this.chart._animationsDisabled;let{start:a,count:l}=px(e,i,o);this._drawStart=a,this._drawCount=l,mx(e)&&(a=0,l=i.length),n._chart=this.chart,n._datasetIndex=this.index,n._decimated=!!r._decimated,n.points=i;const c=this.resolveDatasetElementOptions(t);this.options.showLine||(c.borderWidth=0),c.segment=this.options.segment,this.updateElement(n,void 0,{animated:!o,options:c},t),this.updateElements(i,a,l,t)}updateElements(t,e,n,i){const r=i==="reset",{iScale:o,vScale:a,_stacked:l,_dataset:c}=this._cachedMeta,{sharedOptions:h,includeOptions:u}=this._getSharedOptions(e,i),d=o.axis,f=a.axis,{spanGaps:p,segment:m}=this.options,y=Ks(p)?p:Number.POSITIVE_INFINITY,g=this.chart._animationsDisabled||r||i==="none",x=e+n,v=t.length;let _=e>0&&this.getParsed(e-1);for(let M=0;M<v;++M){const w=t[M],b=g?w:{};if(M<e||M>=x){b.skip=!0;continue}const E=this.getParsed(M),P=zt(E[f]),R=b[d]=o.getPixelForValue(E[d],M),C=b[f]=r||P?a.getBasePixel():a.getPixelForValue(l?this.applyStack(a,E,l):E[f],M);b.skip=isNaN(R)||isNaN(C)||P,b.stop=M>0&&Math.abs(E[d]-_[d])>y,m&&(b.parsed=E,b.raw=c.data[M]),u&&(b.options=h||this.resolveDataElementOptions(M,w.active?"active":i)),g||this.updateElement(w,M,b,i),_=E}}getMaxOverflow(){const t=this._cachedMeta,e=t.dataset,n=e.options&&e.options.borderWidth||0,i=t.data||[];if(!i.length)return n;const r=i[0].size(this.resolveDataElementOptions(0)),o=i[i.length-1].size(this.resolveDataElementOptions(i.length-1));return Math.max(n,r,o)/2}draw(){const t=this._cachedMeta;t.dataset.updateControlPoints(this.chart.chartArea,t.iScale.axis),super.draw()}}class qT extends as{static id="polarArea";static defaults={dataElementType:"arc",animation:{animateRotate:!0,animateScale:!0},animations:{numbers:{type:"number",properties:["x","y","startAngle","endAngle","innerRadius","outerRadius"]}},indexAxis:"r",startAngle:0};static overrides={aspectRatio:1,plugins:{legend:{labels:{generateLabels(t){const e=t.data;if(e.labels.length&&e.datasets.length){const{labels:{pointStyle:n,color:i}}=t.legend.options;return e.labels.map((r,o)=>{const l=t.getDatasetMeta(0).controller.getStyle(o);return{text:r,fillStyle:l.backgroundColor,strokeStyle:l.borderColor,fontColor:i,lineWidth:l.borderWidth,pointStyle:n,hidden:!t.getDataVisibility(o),index:o}})}return[]}},onClick(t,e,n){n.chart.toggleDataVisibility(e.index),n.chart.update()}}},scales:{r:{type:"radialLinear",angleLines:{display:!1},beginAtZero:!0,grid:{circular:!0},pointLabels:{display:!1},startAngle:0}}};constructor(t,e){super(t,e),this.innerRadius=void 0,this.outerRadius=void 0}getLabelAndValue(t){const e=this._cachedMeta,n=this.chart,i=n.data.labels||[],r=cl(e._parsed[t].r,n.options.locale);return{label:i[t]||"",value:r}}parseObjectData(t,e,n,i){return Mx.bind(this)(t,e,n,i)}update(t){const e=this._cachedMeta.data;this._updateRadius(),this.updateElements(e,0,e.length,t)}getMinMax(){const t=this._cachedMeta,e={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};return t.data.forEach((n,i)=>{const r=this.getParsed(i).r;!isNaN(r)&&this.chart.getDataVisibility(i)&&(r<e.min&&(e.min=r),r>e.max&&(e.max=r))}),e}_updateRadius(){const t=this.chart,e=t.chartArea,n=t.options,i=Math.min(e.right-e.left,e.bottom-e.top),r=Math.max(i/2,0),o=Math.max(n.cutoutPercentage?r/100*n.cutoutPercentage:1,0),a=(r-o)/t.getVisibleDatasetCount();this.outerRadius=r-a*this.index,this.innerRadius=this.outerRadius-a}updateElements(t,e,n,i){const r=i==="reset",o=this.chart,l=o.options.animation,c=this._cachedMeta.rScale,h=c.xCenter,u=c.yCenter,d=c.getIndexAngle(0)-.5*Vt;let f=d,p;const m=360/this.countVisibleElements();for(p=0;p<e;++p)f+=this._computeAngle(p,i,m);for(p=e;p<e+n;p++){const y=t[p];let g=f,x=f+this._computeAngle(p,i,m),v=o.getDataVisibility(p)?c.getDistanceFromCenterForValue(this.getParsed(p).r):0;f=x,r&&(l.animateScale&&(v=0),l.animateRotate&&(g=x=d));const _={x:h,y:u,innerRadius:0,outerRadius:v,startAngle:g,endAngle:x,options:this.resolveDataElementOptions(p,y.active?"active":i)};this.updateElement(y,p,_,i)}}countVisibleElements(){const t=this._cachedMeta;let e=0;return t.data.forEach((n,i)=>{!isNaN(this.getParsed(i).r)&&this.chart.getDataVisibility(i)&&e++}),e}_computeAngle(t,e,n){return this.chart.getDataVisibility(t)?en(this.resolveDataElementOptions(t,e).angle||n):0}}class YT extends Ix{static id="pie";static defaults={cutout:0,rotation:0,circumference:360,radius:"100%"}}class jT extends as{static id="radar";static defaults={datasetElementType:"line",dataElementType:"point",indexAxis:"r",showLine:!0,elements:{line:{fill:"start"}}};static overrides={aspectRatio:1,scales:{r:{type:"radialLinear"}}};getLabelAndValue(t){const e=this._cachedMeta.vScale,n=this.getParsed(t);return{label:e.getLabels()[t],value:""+e.getLabelForValue(n[e.axis])}}parseObjectData(t,e,n,i){return Mx.bind(this)(t,e,n,i)}update(t){const e=this._cachedMeta,n=e.dataset,i=e.data||[],r=e.iScale.getLabels();if(n.points=i,t!=="resize"){const o=this.resolveDatasetElementOptions(t);this.options.showLine||(o.borderWidth=0);const a={_loop:!0,_fullLoop:r.length===i.length,options:o};this.updateElement(n,void 0,a,t)}this.updateElements(i,0,i.length,t)}updateElements(t,e,n,i){const r=this._cachedMeta.rScale,o=i==="reset";for(let a=e;a<e+n;a++){const l=t[a],c=this.resolveDataElementOptions(a,l.active?"active":i),h=r.getPointPositionForValue(a,this.getParsed(a).r),u=o?r.xCenter:h.x,d=o?r.yCenter:h.y,f={x:u,y:d,angle:h.angle,skip:isNaN(u)||isNaN(d),options:c};this.updateElement(l,a,f,i)}}}class JT extends as{static id="scatter";static defaults={datasetElementType:!1,dataElementType:"point",showLine:!1,fill:!1};static overrides={interaction:{mode:"point"},scales:{x:{type:"linear"},y:{type:"linear"}}};getLabelAndValue(t){const e=this._cachedMeta,n=this.chart.data.labels||[],{xScale:i,yScale:r}=e,o=this.getParsed(t),a=i.getLabelForValue(o.x),l=r.getLabelForValue(o.y);return{label:n[t]||"",value:"("+a+", "+l+")"}}update(t){const e=this._cachedMeta,{data:n=[]}=e,i=this.chart._animationsDisabled;let{start:r,count:o}=px(e,n,i);if(this._drawStart=r,this._drawCount=o,mx(e)&&(r=0,o=n.length),this.options.showLine){this.datasetElementType||this.addElements();const{dataset:a,_dataset:l}=e;a._chart=this.chart,a._datasetIndex=this.index,a._decimated=!!l._decimated,a.points=n;const c=this.resolveDatasetElementOptions(t);c.segment=this.options.segment,this.updateElement(a,void 0,{animated:!i,options:c},t)}else this.datasetElementType&&(delete e.dataset,this.datasetElementType=!1);this.updateElements(n,r,o,t)}addElements(){const{showLine:t}=this.options;!this.datasetElementType&&t&&(this.datasetElementType=this.chart.registry.getElement("line")),super.addElements()}updateElements(t,e,n,i){const r=i==="reset",{iScale:o,vScale:a,_stacked:l,_dataset:c}=this._cachedMeta,h=this.resolveDataElementOptions(e,i),u=this.getSharedOptions(h),d=this.includeOptions(i,u),f=o.axis,p=a.axis,{spanGaps:m,segment:y}=this.options,g=Ks(m)?m:Number.POSITIVE_INFINITY,x=this.chart._animationsDisabled||r||i==="none";let v=e>0&&this.getParsed(e-1);for(let _=e;_<e+n;++_){const M=t[_],w=this.getParsed(_),b=x?M:{},E=zt(w[p]),P=b[f]=o.getPixelForValue(w[f],_),R=b[p]=r||E?a.getBasePixel():a.getPixelForValue(l?this.applyStack(a,w,l):w[p],_);b.skip=isNaN(P)||isNaN(R)||E,b.stop=_>0&&Math.abs(w[f]-v[f])>g,y&&(b.parsed=w,b.raw=c.data[_]),d&&(b.options=u||this.resolveDataElementOptions(_,M.active?"active":i)),x||this.updateElement(M,_,b,i),v=w}this.updateSharedOptions(u,i,h)}getMaxOverflow(){const t=this._cachedMeta,e=t.data||[];if(!this.options.showLine){let a=0;for(let l=e.length-1;l>=0;--l)a=Math.max(a,e[l].size(this.resolveDataElementOptions(l))/2);return a>0&&a}const n=t.dataset,i=n.options&&n.options.borderWidth||0;if(!e.length)return i;const r=e[0].size(this.resolveDataElementOptions(0)),o=e[e.length-1].size(this.resolveDataElementOptions(e.length-1));return Math.max(i,r,o)/2}}function Ai(){throw new Error("This method is not implemented: Check that a complete date adapter is provided.")}class du{static override(t){Object.assign(du.prototype,t)}options;constructor(t){this.options=t||{}}init(){}formats(){return Ai()}parse(){return Ai()}format(){return Ai()}add(){return Ai()}diff(){return Ai()}startOf(){return Ai()}endOf(){return Ai()}}var ZT={_date:du};function $T(s,t,e,n){const{controller:i,data:r,_sorted:o}=s,a=i._cachedMeta.iScale,l=s.dataset&&s.dataset.options?s.dataset.options.spanGaps:null;if(a&&t===a.axis&&t!=="r"&&o&&r.length){const c=a._reversePixels?f1:ki;if(n){if(i._sharedOptions){const h=r[0],u=typeof h.getRange=="function"&&h.getRange(t);if(u){const d=c(r,t,e-u),f=c(r,t,e+u);return{lo:d.lo,hi:f.hi}}}}else{const h=c(r,t,e);if(l){const{vScale:u}=i._cachedMeta,{_parsed:d}=s,f=d.slice(0,h.lo+1).reverse().findIndex(m=>!zt(m[u.axis]));h.lo-=Math.max(0,f);const p=d.slice(h.hi).findIndex(m=>!zt(m[u.axis]));h.hi+=Math.max(0,p)}return h}}return{lo:0,hi:r.length-1}}function fl(s,t,e,n,i){const r=s.getSortedVisibleDatasetMetas(),o=e[t];for(let a=0,l=r.length;a<l;++a){const{index:c,data:h}=r[a],{lo:u,hi:d}=$T(r[a],t,o,i);for(let f=u;f<=d;++f){const p=h[f];p.skip||n(p,c,f)}}}function KT(s){const t=s.indexOf("x")!==-1,e=s.indexOf("y")!==-1;return function(n,i){const r=t?Math.abs(n.x-i.x):0,o=e?Math.abs(n.y-i.y):0;return Math.sqrt(Math.pow(r,2)+Math.pow(o,2))}}function hc(s,t,e,n,i){const r=[];return!i&&!s.isPointInArea(t)||fl(s,e,t,function(a,l,c){!i&&!Dn(a,s.chartArea,0)||a.inRange(t.x,t.y,n)&&r.push({element:a,datasetIndex:l,index:c})},!0),r}function QT(s,t,e,n){let i=[];function r(o,a,l){const{startAngle:c,endAngle:h}=o.getProps(["startAngle","endAngle"],n),{angle:u}=cx(o,{x:t.x,y:t.y});io(u,c,h)&&i.push({element:o,datasetIndex:a,index:l})}return fl(s,e,t,r),i}function tE(s,t,e,n,i,r){let o=[];const a=KT(e);let l=Number.POSITIVE_INFINITY;function c(h,u,d){const f=h.inRange(t.x,t.y,i);if(n&&!f)return;const p=h.getCenterPoint(i);if(!(!!r||s.isPointInArea(p))&&!f)return;const y=a(t,p);y<l?(o=[{element:h,datasetIndex:u,index:d}],l=y):y===l&&o.push({element:h,datasetIndex:u,index:d})}return fl(s,e,t,c),o}function uc(s,t,e,n,i,r){return!r&&!s.isPointInArea(t)?[]:e==="r"&&!n?QT(s,t,e,i):tE(s,t,e,n,i,r)}function vf(s,t,e,n,i){const r=[],o=e==="x"?"inXRange":"inYRange";let a=!1;return fl(s,e,t,(l,c,h)=>{l[o]&&l[o](t[e],i)&&(r.push({element:l,datasetIndex:c,index:h}),a=a||l.inRange(t.x,t.y,i))}),n&&!a?[]:r}var eE={modes:{index(s,t,e,n){const i=Ci(t,s),r=e.axis||"x",o=e.includeInvisible||!1,a=e.intersect?hc(s,i,r,n,o):uc(s,i,r,!1,n,o),l=[];return a.length?(s.getSortedVisibleDatasetMetas().forEach(c=>{const h=a[0].index,u=c.data[h];u&&!u.skip&&l.push({element:u,datasetIndex:c.index,index:h})}),l):[]},dataset(s,t,e,n){const i=Ci(t,s),r=e.axis||"xy",o=e.includeInvisible||!1;let a=e.intersect?hc(s,i,r,n,o):uc(s,i,r,!1,n,o);if(a.length>0){const l=a[0].datasetIndex,c=s.getDatasetMeta(l).data;a=[];for(let h=0;h<c.length;++h)a.push({element:c[h],datasetIndex:l,index:h})}return a},point(s,t,e,n){const i=Ci(t,s),r=e.axis||"xy",o=e.includeInvisible||!1;return hc(s,i,r,n,o)},nearest(s,t,e,n){const i=Ci(t,s),r=e.axis||"xy",o=e.includeInvisible||!1;return uc(s,i,r,e.intersect,n,o)},x(s,t,e,n){const i=Ci(t,s);return vf(s,i,"x",e.intersect,n)},y(s,t,e,n){const i=Ci(t,s);return vf(s,i,"y",e.intersect,n)}}};const Fx=["left","top","right","bottom"];function br(s,t){return s.filter(e=>e.pos===t)}function bf(s,t){return s.filter(e=>Fx.indexOf(e.pos)===-1&&e.box.axis===t)}function Mr(s,t){return s.sort((e,n)=>{const i=t?n:e,r=t?e:n;return i.weight===r.weight?i.index-r.index:i.weight-r.weight})}function nE(s){const t=[];let e,n,i,r,o,a;for(e=0,n=(s||[]).length;e<n;++e)i=s[e],{position:r,options:{stack:o,stackWeight:a=1}}=i,t.push({index:e,box:i,pos:r,horizontal:i.isHorizontal(),weight:i.weight,stack:o&&r+o,stackWeight:a});return t}function iE(s){const t={};for(const e of s){const{stack:n,pos:i,stackWeight:r}=e;if(!n||!Fx.includes(i))continue;const o=t[n]||(t[n]={count:0,placed:0,weight:0,size:0});o.count++,o.weight+=r}return t}function sE(s,t){const e=iE(s),{vBoxMaxWidth:n,hBoxMaxHeight:i}=t;let r,o,a;for(r=0,o=s.length;r<o;++r){a=s[r];const{fullSize:l}=a.box,c=e[a.stack],h=c&&a.stackWeight/c.weight;a.horizontal?(a.width=h?h*n:l&&t.availableWidth,a.height=i):(a.width=n,a.height=h?h*i:l&&t.availableHeight)}return e}function rE(s){const t=nE(s),e=Mr(t.filter(c=>c.box.fullSize),!0),n=Mr(br(t,"left"),!0),i=Mr(br(t,"right")),r=Mr(br(t,"top"),!0),o=Mr(br(t,"bottom")),a=bf(t,"x"),l=bf(t,"y");return{fullSize:e,leftAndTop:n.concat(r),rightAndBottom:i.concat(l).concat(o).concat(a),chartArea:br(t,"chartArea"),vertical:n.concat(i).concat(l),horizontal:r.concat(o).concat(a)}}function Mf(s,t,e,n){return Math.max(s[e],t[e])+Math.max(s[n],t[n])}function kx(s,t){s.top=Math.max(s.top,t.top),s.left=Math.max(s.left,t.left),s.bottom=Math.max(s.bottom,t.bottom),s.right=Math.max(s.right,t.right)}function oE(s,t,e,n){const{pos:i,box:r}=e,o=s.maxPadding;if(!kt(i)){e.size&&(s[i]-=e.size);const u=n[e.stack]||{size:0,count:1};u.size=Math.max(u.size,e.horizontal?r.height:r.width),e.size=u.size/u.count,s[i]+=e.size}r.getPadding&&kx(o,r.getPadding());const a=Math.max(0,t.outerWidth-Mf(o,s,"left","right")),l=Math.max(0,t.outerHeight-Mf(o,s,"top","bottom")),c=a!==s.w,h=l!==s.h;return s.w=a,s.h=l,e.horizontal?{same:c,other:h}:{same:h,other:c}}function aE(s){const t=s.maxPadding;function e(n){const i=Math.max(t[n]-s[n],0);return s[n]+=i,i}s.y+=e("top"),s.x+=e("left"),e("right"),e("bottom")}function lE(s,t){const e=t.maxPadding;function n(i){const r={left:0,top:0,right:0,bottom:0};return i.forEach(o=>{r[o]=Math.max(t[o],e[o])}),r}return n(s?["left","right"]:["top","bottom"])}function Ar(s,t,e,n){const i=[];let r,o,a,l,c,h;for(r=0,o=s.length,c=0;r<o;++r){a=s[r],l=a.box,l.update(a.width||t.w,a.height||t.h,lE(a.horizontal,t));const{same:u,other:d}=oE(t,e,a,n);c|=u&&i.length,h=h||d,l.fullSize||i.push(a)}return c&&Ar(i,t,e,n)||h}function xa(s,t,e,n,i){s.top=e,s.left=t,s.right=t+n,s.bottom=e+i,s.width=n,s.height=i}function wf(s,t,e,n){const i=e.padding;let{x:r,y:o}=t;for(const a of s){const l=a.box,c=n[a.stack]||{placed:0,weight:1},h=a.stackWeight/c.weight||1;if(a.horizontal){const u=t.w*h,d=c.size||l.height;no(c.start)&&(o=c.start),l.fullSize?xa(l,i.left,o,e.outerWidth-i.right-i.left,d):xa(l,t.left+c.placed,o,u,d),c.start=o,c.placed+=u,o=l.bottom}else{const u=t.h*h,d=c.size||l.width;no(c.start)&&(r=c.start),l.fullSize?xa(l,r,i.top,d,e.outerHeight-i.bottom-i.top):xa(l,r,t.top+c.placed,d,u),c.start=r,c.placed+=u,r=l.right}}t.x=r,t.y=o}var je={addBox(s,t){s.boxes||(s.boxes=[]),t.fullSize=t.fullSize||!1,t.position=t.position||"top",t.weight=t.weight||0,t._layers=t._layers||function(){return[{z:0,draw(e){t.draw(e)}}]},s.boxes.push(t)},removeBox(s,t){const e=s.boxes?s.boxes.indexOf(t):-1;e!==-1&&s.boxes.splice(e,1)},configure(s,t,e){t.fullSize=e.fullSize,t.position=e.position,t.weight=e.weight},update(s,t,e,n){if(!s)return;const i=De(s.options.layout.padding),r=Math.max(t-i.width,0),o=Math.max(e-i.height,0),a=rE(s.boxes),l=a.vertical,c=a.horizontal;Gt(s.boxes,m=>{typeof m.beforeLayout=="function"&&m.beforeLayout()});const h=l.reduce((m,y)=>y.box.options&&y.box.options.display===!1?m:m+1,0)||1,u=Object.freeze({outerWidth:t,outerHeight:e,padding:i,availableWidth:r,availableHeight:o,vBoxMaxWidth:r/2/h,hBoxMaxHeight:o/2}),d=Object.assign({},i);kx(d,De(n));const f=Object.assign({maxPadding:d,w:r,h:o,x:i.left,y:i.top},i),p=sE(l.concat(c),u);Ar(a.fullSize,f,u,p),Ar(l,f,u,p),Ar(c,f,u,p)&&Ar(l,f,u,p),aE(f),wf(a.leftAndTop,f,u,p),f.x+=f.w,f.y+=f.h,wf(a.rightAndBottom,f,u,p),s.chartArea={left:f.left,top:f.top,right:f.left+f.w,bottom:f.top+f.h,height:f.h,width:f.w},Gt(a.chartArea,m=>{const y=m.box;Object.assign(y,s.chartArea),y.update(f.w,f.h,{left:0,top:0,right:0,bottom:0})})}};class Bx{acquireContext(t,e){}releaseContext(t){return!1}addEventListener(t,e,n){}removeEventListener(t,e,n){}getDevicePixelRatio(){return 1}getMaximumSize(t,e,n,i){return e=Math.max(0,e||t.width),n=n||t.height,{width:e,height:Math.max(0,i?Math.floor(e/i):n)}}isAttached(t){return!0}updateConfig(t){}}class cE extends Bx{acquireContext(t){return t&&t.getContext&&t.getContext("2d")||null}updateConfig(t){t.options.animation=!1}}const Ta="$chartjs",hE={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"},Sf=s=>s===null||s==="";function uE(s,t){const e=s.style,n=s.getAttribute("height"),i=s.getAttribute("width");if(s[Ta]={initial:{height:n,width:i,style:{display:e.display,height:e.height,width:e.width}}},e.display=e.display||"block",e.boxSizing=e.boxSizing||"border-box",Sf(i)){const r=af(s,"width");r!==void 0&&(s.width=r)}if(Sf(n))if(s.style.height==="")s.height=s.width/(t||2);else{const r=af(s,"height");r!==void 0&&(s.height=r)}return s}const Ox=aT?{passive:!0}:!1;function dE(s,t,e){s&&s.addEventListener(t,e,Ox)}function fE(s,t,e){s&&s.canvas&&s.canvas.removeEventListener(t,e,Ox)}function pE(s,t){const e=hE[s.type]||s.type,{x:n,y:i}=Ci(s,t);return{type:e,chart:t,native:s,x:n!==void 0?n:null,y:i!==void 0?i:null}}function za(s,t){for(const e of s)if(e===t||e.contains(t))return!0}function mE(s,t,e){const n=s.canvas,i=new MutationObserver(r=>{let o=!1;for(const a of r)o=o||za(a.addedNodes,n),o=o&&!za(a.removedNodes,n);o&&e()});return i.observe(document,{childList:!0,subtree:!0}),i}function gE(s,t,e){const n=s.canvas,i=new MutationObserver(r=>{let o=!1;for(const a of r)o=o||za(a.removedNodes,n),o=o&&!za(a.addedNodes,n);o&&e()});return i.observe(document,{childList:!0,subtree:!0}),i}const ro=new Map;let Tf=0;function zx(){const s=window.devicePixelRatio;s!==Tf&&(Tf=s,ro.forEach((t,e)=>{e.currentDevicePixelRatio!==s&&t()}))}function xE(s,t){ro.size||window.addEventListener("resize",zx),ro.set(s,t)}function yE(s){ro.delete(s),ro.size||window.removeEventListener("resize",zx)}function _E(s,t,e){const n=s.canvas,i=n&&uu(n);if(!i)return;const r=fx((a,l)=>{const c=i.clientWidth;e(a,l),c<i.clientWidth&&e()},window),o=new ResizeObserver(a=>{const l=a[0],c=l.contentRect.width,h=l.contentRect.height;c===0&&h===0||r(c,h)});return o.observe(i),xE(s,r),o}function dc(s,t,e){e&&e.disconnect(),t==="resize"&&yE(s)}function vE(s,t,e){const n=s.canvas,i=fx(r=>{s.ctx!==null&&e(pE(r,s))},s);return dE(n,t,i),i}class bE extends Bx{acquireContext(t,e){const n=t&&t.getContext&&t.getContext("2d");return n&&n.canvas===t?(uE(t,e),n):null}releaseContext(t){const e=t.canvas;if(!e[Ta])return!1;const n=e[Ta].initial;["height","width"].forEach(r=>{const o=n[r];zt(o)?e.removeAttribute(r):e.setAttribute(r,o)});const i=n.style||{};return Object.keys(i).forEach(r=>{e.style[r]=i[r]}),e.width=e.width,delete e[Ta],!0}addEventListener(t,e,n){this.removeEventListener(t,e);const i=t.$proxies||(t.$proxies={}),o={attach:mE,detach:gE,resize:_E}[e]||vE;i[e]=o(t,e,n)}removeEventListener(t,e){const n=t.$proxies||(t.$proxies={}),i=n[e];if(!i)return;({attach:dc,detach:dc,resize:dc}[e]||fE)(t,e,i),n[e]=void 0}getDevicePixelRatio(){return window.devicePixelRatio}getMaximumSize(t,e,n,i){return oT(t,e,n,i)}isAttached(t){const e=t&&uu(t);return!!(e&&e.isConnected)}}function ME(s){return!hu()||typeof OffscreenCanvas<"u"&&s instanceof OffscreenCanvas?cE:bE}class Hn{static defaults={};static defaultRoutes=void 0;x;y;active=!1;options;$animations;tooltipPosition(t){const{x:e,y:n}=this.getProps(["x","y"],t);return{x:e,y:n}}hasValue(){return Ks(this.x)&&Ks(this.y)}getProps(t,e){const n=this.$animations;if(!e||!n)return this;const i={};return t.forEach(r=>{i[r]=n[r]&&n[r].active()?n[r]._to:this[r]}),i}}function wE(s,t){const e=s.options.ticks,n=SE(s),i=Math.min(e.maxTicksLimit||n,n),r=e.major.enabled?EE(t):[],o=r.length,a=r[0],l=r[o-1],c=[];if(o>i)return AE(t,c,r,o/i),c;const h=TE(r,t,i);if(o>0){let u,d;const f=o>1?Math.round((l-a)/(o-1)):null;for(ya(t,c,h,zt(f)?0:a-f,a),u=0,d=o-1;u<d;u++)ya(t,c,h,r[u],r[u+1]);return ya(t,c,h,l,zt(f)?t.length:l+f),c}return ya(t,c,h),c}function SE(s){const t=s.options.offset,e=s._tickSize(),n=s._length/e+(t?0:1),i=s._maxLength/e;return Math.floor(Math.min(n,i))}function TE(s,t,e){const n=LE(s),i=t.length/e;if(!n)return Math.max(i,1);const r=a1(n);for(let o=0,a=r.length-1;o<a;o++){const l=r[o];if(l>i)return l}return Math.max(i,1)}function EE(s){const t=[];let e,n;for(e=0,n=s.length;e<n;e++)s[e].major&&t.push(e);return t}function AE(s,t,e,n){let i=0,r=e[0],o;for(n=Math.ceil(n),o=0;o<s.length;o++)o===r&&(t.push(s[o]),i++,r=e[i*n])}function ya(s,t,e,n,i){const r=Pt(n,0),o=Math.min(Pt(i,s.length),s.length);let a=0,l,c,h;for(e=Math.ceil(e),i&&(l=i-n,e=l/Math.floor(l/e)),h=r;h<0;)a++,h=Math.round(r+a*e);for(c=Math.max(r,0);c<o;c++)c===h&&(t.push(s[c]),a++,h=Math.round(r+a*e))}function LE(s){const t=s.length;let e,n;if(t<2)return!1;for(n=s[0],e=1;e<t;++e)if(s[e]-s[e-1]!==n)return!1;return n}const CE=s=>s==="left"?"right":s==="right"?"left":s,Ef=(s,t,e)=>t==="top"||t==="left"?s[t]+e:s[t]-e,Af=(s,t)=>Math.min(t||s,s);function Lf(s,t){const e=[],n=s.length/t,i=s.length;let r=0;for(;r<i;r+=n)e.push(s[Math.floor(r)]);return e}function RE(s,t,e){const n=s.ticks.length,i=Math.min(t,n-1),r=s._startPixel,o=s._endPixel,a=1e-6;let l=s.getPixelForTick(i),c;if(!(e&&(n===1?c=Math.max(l-r,o-l):t===0?c=(s.getPixelForTick(1)-l)/2:c=(l-s.getPixelForTick(i-1))/2,l+=i<t?c:-c,l<r-a||l>o+a)))return l}function PE(s,t){Gt(s,e=>{const n=e.gc,i=n.length/2;let r;if(i>t){for(r=0;r<i;++r)delete e.data[n[r]];n.splice(0,i)}})}function wr(s){return s.drawTicks?s.tickLength:0}function Cf(s,t){if(!s.display)return 0;const e=de(s.font,t),n=De(s.padding);return($t(s.text)?s.text.length:1)*e.lineHeight+n.height}function DE(s,t){return mi(s,{scale:t,type:"scale"})}function IE(s,t,e){return mi(s,{tick:e,index:t,type:"tick"})}function FE(s,t,e){let n=iu(s);return(e&&t!=="right"||!e&&t==="right")&&(n=CE(n)),n}function kE(s,t,e,n){const{top:i,left:r,bottom:o,right:a,chart:l}=s,{chartArea:c,scales:h}=l;let u=0,d,f,p;const m=o-i,y=a-r;if(s.isHorizontal()){if(f=Le(n,r,a),kt(e)){const g=Object.keys(e)[0],x=e[g];p=h[g].getPixelForValue(x)+m-t}else e==="center"?p=(c.bottom+c.top)/2+m-t:p=Ef(s,e,t);d=a-r}else{if(kt(e)){const g=Object.keys(e)[0],x=e[g];f=h[g].getPixelForValue(x)-y+t}else e==="center"?f=(c.left+c.right)/2-y+t:f=Ef(s,e,t);p=Le(n,o,i),u=e==="left"?-oe:oe}return{titleX:f,titleY:p,maxWidth:d,rotation:u}}class cr extends Hn{constructor(t){super(),this.id=t.id,this.type=t.type,this.options=void 0,this.ctx=t.ctx,this.chart=t.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}init(t){this.options=t.setContext(this.getContext()),this.axis=t.axis,this._userMin=this.parse(t.min),this._userMax=this.parse(t.max),this._suggestedMin=this.parse(t.suggestedMin),this._suggestedMax=this.parse(t.suggestedMax)}parse(t,e){return t}getUserBounds(){let{_userMin:t,_userMax:e,_suggestedMin:n,_suggestedMax:i}=this;return t=cn(t,Number.POSITIVE_INFINITY),e=cn(e,Number.NEGATIVE_INFINITY),n=cn(n,Number.POSITIVE_INFINITY),i=cn(i,Number.NEGATIVE_INFINITY),{min:cn(t,n),max:cn(e,i),minDefined:xe(t),maxDefined:xe(e)}}getMinMax(t){let{min:e,max:n,minDefined:i,maxDefined:r}=this.getUserBounds(),o;if(i&&r)return{min:e,max:n};const a=this.getMatchingVisibleMetas();for(let l=0,c=a.length;l<c;++l)o=a[l].controller.getMinMax(this,t),i||(e=Math.min(e,o.min)),r||(n=Math.max(n,o.max));return e=r&&e>n?n:e,n=i&&e>n?e:n,{min:cn(e,cn(n,e)),max:cn(n,cn(e,n))}}getPadding(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}}getTicks(){return this.ticks}getLabels(){const t=this.chart.data;return this.options.labels||(this.isHorizontal()?t.xLabels:t.yLabels)||t.labels||[]}getLabelItems(t=this.chart.chartArea){return this._labelItems||(this._labelItems=this._computeLabelItems(t))}beforeLayout(){this._cache={},this._dataLimitsCached=!1}beforeUpdate(){jt(this.options.beforeUpdate,[this])}update(t,e,n){const{beginAtZero:i,grace:r,ticks:o}=this.options,a=o.sampleSize;this.beforeUpdate(),this.maxWidth=t,this.maxHeight=e,this._margins=n=Object.assign({left:0,right:0,top:0,bottom:0},n),this.ticks=null,this._labelSizes=null,this._gridLineItems=null,this._labelItems=null,this.beforeSetDimensions(),this.setDimensions(),this.afterSetDimensions(),this._maxLength=this.isHorizontal()?this.width+n.left+n.right:this.height+n.top+n.bottom,this._dataLimitsCached||(this.beforeDataLimits(),this.determineDataLimits(),this.afterDataLimits(),this._range=z1(this,r,i),this._dataLimitsCached=!0),this.beforeBuildTicks(),this.ticks=this.buildTicks()||[],this.afterBuildTicks();const l=a<this.ticks.length;this._convertTicksToLabels(l?Lf(this.ticks,a):this.ticks),this.configure(),this.beforeCalculateLabelRotation(),this.calculateLabelRotation(),this.afterCalculateLabelRotation(),o.display&&(o.autoSkip||o.source==="auto")&&(this.ticks=wE(this,this.ticks),this._labelSizes=null,this.afterAutoSkip()),l&&this._convertTicksToLabels(this.ticks),this.beforeFit(),this.fit(),this.afterFit(),this.afterUpdate()}configure(){let t=this.options.reverse,e,n;this.isHorizontal()?(e=this.left,n=this.right):(e=this.top,n=this.bottom,t=!t),this._startPixel=e,this._endPixel=n,this._reversePixels=t,this._length=n-e,this._alignToPixels=this.options.alignToPixels}afterUpdate(){jt(this.options.afterUpdate,[this])}beforeSetDimensions(){jt(this.options.beforeSetDimensions,[this])}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=0,this.right=this.width):(this.height=this.maxHeight,this.top=0,this.bottom=this.height),this.paddingLeft=0,this.paddingTop=0,this.paddingRight=0,this.paddingBottom=0}afterSetDimensions(){jt(this.options.afterSetDimensions,[this])}_callHooks(t){this.chart.notifyPlugins(t,this.getContext()),jt(this.options[t],[this])}beforeDataLimits(){this._callHooks("beforeDataLimits")}determineDataLimits(){}afterDataLimits(){this._callHooks("afterDataLimits")}beforeBuildTicks(){this._callHooks("beforeBuildTicks")}buildTicks(){return[]}afterBuildTicks(){this._callHooks("afterBuildTicks")}beforeTickToLabelConversion(){jt(this.options.beforeTickToLabelConversion,[this])}generateTickLabels(t){const e=this.options.ticks;let n,i,r;for(n=0,i=t.length;n<i;n++)r=t[n],r.label=jt(e.callback,[r.value,n,t],this)}afterTickToLabelConversion(){jt(this.options.afterTickToLabelConversion,[this])}beforeCalculateLabelRotation(){jt(this.options.beforeCalculateLabelRotation,[this])}calculateLabelRotation(){const t=this.options,e=t.ticks,n=Af(this.ticks.length,t.ticks.maxTicksLimit),i=e.minRotation||0,r=e.maxRotation;let o=i,a,l,c;if(!this._isVisible()||!e.display||i>=r||n<=1||!this.isHorizontal()){this.labelRotation=i;return}const h=this._getLabelSizes(),u=h.widest.width,d=h.highest.height,f=Re(this.chart.width-u,0,this.maxWidth);a=t.offset?this.maxWidth/n:f/(n-1),u+6>a&&(a=f/(n-(t.offset?.5:1)),l=this.maxHeight-wr(t.grid)-e.padding-Cf(t.title,this.chart.options.font),c=Math.sqrt(u*u+d*d),o=eu(Math.min(Math.asin(Re((h.highest.height+6)/a,-1,1)),Math.asin(Re(l/c,-1,1))-Math.asin(Re(d/c,-1,1)))),o=Math.max(i,Math.min(r,o))),this.labelRotation=o}afterCalculateLabelRotation(){jt(this.options.afterCalculateLabelRotation,[this])}afterAutoSkip(){}beforeFit(){jt(this.options.beforeFit,[this])}fit(){const t={width:0,height:0},{chart:e,options:{ticks:n,title:i,grid:r}}=this,o=this._isVisible(),a=this.isHorizontal();if(o){const l=Cf(i,e.options.font);if(a?(t.width=this.maxWidth,t.height=wr(r)+l):(t.height=this.maxHeight,t.width=wr(r)+l),n.display&&this.ticks.length){const{first:c,last:h,widest:u,highest:d}=this._getLabelSizes(),f=n.padding*2,p=en(this.labelRotation),m=Math.cos(p),y=Math.sin(p);if(a){const g=n.mirror?0:y*u.width+m*d.height;t.height=Math.min(this.maxHeight,t.height+g+f)}else{const g=n.mirror?0:m*u.width+y*d.height;t.width=Math.min(this.maxWidth,t.width+g+f)}this._calculatePadding(c,h,y,m)}}this._handleMargins(),a?(this.width=this._length=e.width-this._margins.left-this._margins.right,this.height=t.height):(this.width=t.width,this.height=this._length=e.height-this._margins.top-this._margins.bottom)}_calculatePadding(t,e,n,i){const{ticks:{align:r,padding:o},position:a}=this.options,l=this.labelRotation!==0,c=a!=="top"&&this.axis==="x";if(this.isHorizontal()){const h=this.getPixelForTick(0)-this.left,u=this.right-this.getPixelForTick(this.ticks.length-1);let d=0,f=0;l?c?(d=i*t.width,f=n*e.height):(d=n*t.height,f=i*e.width):r==="start"?f=e.width:r==="end"?d=t.width:r!=="inner"&&(d=t.width/2,f=e.width/2),this.paddingLeft=Math.max((d-h+o)*this.width/(this.width-h),0),this.paddingRight=Math.max((f-u+o)*this.width/(this.width-u),0)}else{let h=e.height/2,u=t.height/2;r==="start"?(h=0,u=t.height):r==="end"&&(h=e.height,u=0),this.paddingTop=h+o,this.paddingBottom=u+o}}_handleMargins(){this._margins&&(this._margins.left=Math.max(this.paddingLeft,this._margins.left),this._margins.top=Math.max(this.paddingTop,this._margins.top),this._margins.right=Math.max(this.paddingRight,this._margins.right),this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom))}afterFit(){jt(this.options.afterFit,[this])}isHorizontal(){const{axis:t,position:e}=this.options;return e==="top"||e==="bottom"||t==="x"}isFullSize(){return this.options.fullSize}_convertTicksToLabels(t){this.beforeTickToLabelConversion(),this.generateTickLabels(t);let e,n;for(e=0,n=t.length;e<n;e++)zt(t[e].label)&&(t.splice(e,1),n--,e--);this.afterTickToLabelConversion()}_getLabelSizes(){let t=this._labelSizes;if(!t){const e=this.options.ticks.sampleSize;let n=this.ticks;e<n.length&&(n=Lf(n,e)),this._labelSizes=t=this._computeLabelSizes(n,n.length,this.options.ticks.maxTicksLimit)}return t}_computeLabelSizes(t,e,n){const{ctx:i,_longestTextCache:r}=this,o=[],a=[],l=Math.floor(e/Af(e,n));let c=0,h=0,u,d,f,p,m,y,g,x,v,_,M;for(u=0;u<e;u+=l){if(p=t[u].label,m=this._resolveTickFontOptions(u),i.font=y=m.string,g=r[y]=r[y]||{data:{},gc:[]},x=m.lineHeight,v=_=0,!zt(p)&&!$t(p))v=Ba(i,g.data,g.gc,v,p),_=x;else if($t(p))for(d=0,f=p.length;d<f;++d)M=p[d],!zt(M)&&!$t(M)&&(v=Ba(i,g.data,g.gc,v,M),_+=x);o.push(v),a.push(_),c=Math.max(v,c),h=Math.max(_,h)}PE(r,e);const w=o.indexOf(c),b=a.indexOf(h),E=P=>({width:o[P]||0,height:a[P]||0});return{first:E(0),last:E(e-1),widest:E(w),highest:E(b),widths:o,heights:a}}getLabelForValue(t){return t}getPixelForValue(t,e){return NaN}getValueForPixel(t){}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getPixelForDecimal(t){this._reversePixels&&(t=1-t);const e=this._startPixel+t*this._length;return d1(this._alignToPixels?Ei(this.chart,e,0):e)}getDecimalForPixel(t){const e=(t-this._startPixel)/this._length;return this._reversePixels?1-e:e}getBasePixel(){return this.getPixelForValue(this.getBaseValue())}getBaseValue(){const{min:t,max:e}=this;return t<0&&e<0?e:t>0&&e>0?t:0}getContext(t){const e=this.ticks||[];if(t>=0&&t<e.length){const n=e[t];return n.$context||(n.$context=IE(this.getContext(),t,n))}return this.$context||(this.$context=DE(this.chart.getContext(),this))}_tickSize(){const t=this.options.ticks,e=en(this.labelRotation),n=Math.abs(Math.cos(e)),i=Math.abs(Math.sin(e)),r=this._getLabelSizes(),o=t.autoSkipPadding||0,a=r?r.widest.width+o:0,l=r?r.highest.height+o:0;return this.isHorizontal()?l*n>a*i?a/n:l/i:l*i<a*n?l/n:a/i}_isVisible(){const t=this.options.display;return t!=="auto"?!!t:this.getMatchingVisibleMetas().length>0}_computeGridLineItems(t){const e=this.axis,n=this.chart,i=this.options,{grid:r,position:o,border:a}=i,l=r.offset,c=this.isHorizontal(),u=this.ticks.length+(l?1:0),d=wr(r),f=[],p=a.setContext(this.getContext()),m=p.display?p.width:0,y=m/2,g=function(F){return Ei(n,F,m)};let x,v,_,M,w,b,E,P,R,C,U,k;if(o==="top")x=g(this.bottom),b=this.bottom-d,P=x-y,C=g(t.top)+y,k=t.bottom;else if(o==="bottom")x=g(this.top),C=t.top,k=g(t.bottom)-y,b=x+y,P=this.top+d;else if(o==="left")x=g(this.right),w=this.right-d,E=x-y,R=g(t.left)+y,U=t.right;else if(o==="right")x=g(this.left),R=t.left,U=g(t.right)-y,w=x+y,E=this.left+d;else if(e==="x"){if(o==="center")x=g((t.top+t.bottom)/2+.5);else if(kt(o)){const F=Object.keys(o)[0],N=o[F];x=g(this.chart.scales[F].getPixelForValue(N))}C=t.top,k=t.bottom,b=x+y,P=b+d}else if(e==="y"){if(o==="center")x=g((t.left+t.right)/2);else if(kt(o)){const F=Object.keys(o)[0],N=o[F];x=g(this.chart.scales[F].getPixelForValue(N))}w=x-y,E=w-d,R=t.left,U=t.right}const B=Pt(i.ticks.maxTicksLimit,u),O=Math.max(1,Math.ceil(u/B));for(v=0;v<u;v+=O){const F=this.getContext(v),N=r.setContext(F),Z=a.setContext(F),tt=N.lineWidth,dt=N.color,nt=Z.dash||[],_t=Z.dashOffset,X=N.tickWidth,K=N.tickColor,lt=N.tickBorderDash||[],H=N.tickBorderDashOffset;_=RE(this,v,l),_!==void 0&&(M=Ei(n,_,tt),c?w=E=R=U=M:b=P=C=k=M,f.push({tx1:w,ty1:b,tx2:E,ty2:P,x1:R,y1:C,x2:U,y2:k,width:tt,color:dt,borderDash:nt,borderDashOffset:_t,tickWidth:X,tickColor:K,tickBorderDash:lt,tickBorderDashOffset:H}))}return this._ticksLength=u,this._borderValue=x,f}_computeLabelItems(t){const e=this.axis,n=this.options,{position:i,ticks:r}=n,o=this.isHorizontal(),a=this.ticks,{align:l,crossAlign:c,padding:h,mirror:u}=r,d=wr(n.grid),f=d+h,p=u?-h:f,m=-en(this.labelRotation),y=[];let g,x,v,_,M,w,b,E,P,R,C,U,k="middle";if(i==="top")w=this.bottom-p,b=this._getXAxisLabelAlignment();else if(i==="bottom")w=this.top+p,b=this._getXAxisLabelAlignment();else if(i==="left"){const O=this._getYAxisLabelAlignment(d);b=O.textAlign,M=O.x}else if(i==="right"){const O=this._getYAxisLabelAlignment(d);b=O.textAlign,M=O.x}else if(e==="x"){if(i==="center")w=(t.top+t.bottom)/2+f;else if(kt(i)){const O=Object.keys(i)[0],F=i[O];w=this.chart.scales[O].getPixelForValue(F)+f}b=this._getXAxisLabelAlignment()}else if(e==="y"){if(i==="center")M=(t.left+t.right)/2-f;else if(kt(i)){const O=Object.keys(i)[0],F=i[O];M=this.chart.scales[O].getPixelForValue(F)}b=this._getYAxisLabelAlignment(d).textAlign}e==="y"&&(l==="start"?k="top":l==="end"&&(k="bottom"));const B=this._getLabelSizes();for(g=0,x=a.length;g<x;++g){v=a[g],_=v.label;const O=r.setContext(this.getContext(g));E=this.getPixelForTick(g)+r.labelOffset,P=this._resolveTickFontOptions(g),R=P.lineHeight,C=$t(_)?_.length:1;const F=C/2,N=O.color,Z=O.textStrokeColor,tt=O.textStrokeWidth;let dt=b;o?(M=E,b==="inner"&&(g===x-1?dt=this.options.reverse?"left":"right":g===0?dt=this.options.reverse?"right":"left":dt="center"),i==="top"?c==="near"||m!==0?U=-C*R+R/2:c==="center"?U=-B.highest.height/2-F*R+R:U=-B.highest.height+R/2:c==="near"||m!==0?U=R/2:c==="center"?U=B.highest.height/2-F*R:U=B.highest.height-C*R,u&&(U*=-1),m!==0&&!O.showLabelBackdrop&&(M+=R/2*Math.sin(m))):(w=E,U=(1-C)*R/2);let nt;if(O.showLabelBackdrop){const _t=De(O.backdropPadding),X=B.heights[g],K=B.widths[g];let lt=U-_t.top,H=0-_t.left;switch(k){case"middle":lt-=X/2;break;case"bottom":lt-=X;break}switch(b){case"center":H-=K/2;break;case"right":H-=K;break;case"inner":g===x-1?H-=K:g>0&&(H-=K/2);break}nt={left:H,top:lt,width:K+_t.width,height:X+_t.height,color:O.backdropColor}}y.push({label:_,font:P,textOffset:U,options:{rotation:m,color:N,strokeColor:Z,strokeWidth:tt,textAlign:dt,textBaseline:k,translation:[M,w],backdrop:nt}})}return y}_getXAxisLabelAlignment(){const{position:t,ticks:e}=this.options;if(-en(this.labelRotation))return t==="top"?"left":"right";let i="center";return e.align==="start"?i="left":e.align==="end"?i="right":e.align==="inner"&&(i="inner"),i}_getYAxisLabelAlignment(t){const{position:e,ticks:{crossAlign:n,mirror:i,padding:r}}=this.options,o=this._getLabelSizes(),a=t+r,l=o.widest.width;let c,h;return e==="left"?i?(h=this.right+r,n==="near"?c="left":n==="center"?(c="center",h+=l/2):(c="right",h+=l)):(h=this.right-a,n==="near"?c="right":n==="center"?(c="center",h-=l/2):(c="left",h=this.left)):e==="right"?i?(h=this.left+r,n==="near"?c="right":n==="center"?(c="center",h-=l/2):(c="left",h-=l)):(h=this.left+a,n==="near"?c="left":n==="center"?(c="center",h+=l/2):(c="right",h=this.right)):c="right",{textAlign:c,x:h}}_computeLabelArea(){if(this.options.ticks.mirror)return;const t=this.chart,e=this.options.position;if(e==="left"||e==="right")return{top:0,left:this.left,bottom:t.height,right:this.right};if(e==="top"||e==="bottom")return{top:this.top,left:0,bottom:this.bottom,right:t.width}}drawBackground(){const{ctx:t,options:{backgroundColor:e},left:n,top:i,width:r,height:o}=this;e&&(t.save(),t.fillStyle=e,t.fillRect(n,i,r,o),t.restore())}getLineWidthForValue(t){const e=this.options.grid;if(!this._isVisible()||!e.display)return 0;const i=this.ticks.findIndex(r=>r.value===t);return i>=0?e.setContext(this.getContext(i)).lineWidth:0}drawGrid(t){const e=this.options.grid,n=this.ctx,i=this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(t));let r,o;const a=(l,c,h)=>{!h.width||!h.color||(n.save(),n.lineWidth=h.width,n.strokeStyle=h.color,n.setLineDash(h.borderDash||[]),n.lineDashOffset=h.borderDashOffset,n.beginPath(),n.moveTo(l.x,l.y),n.lineTo(c.x,c.y),n.stroke(),n.restore())};if(e.display)for(r=0,o=i.length;r<o;++r){const l=i[r];e.drawOnChartArea&&a({x:l.x1,y:l.y1},{x:l.x2,y:l.y2},l),e.drawTicks&&a({x:l.tx1,y:l.ty1},{x:l.tx2,y:l.ty2},{color:l.tickColor,width:l.tickWidth,borderDash:l.tickBorderDash,borderDashOffset:l.tickBorderDashOffset})}}drawBorder(){const{chart:t,ctx:e,options:{border:n,grid:i}}=this,r=n.setContext(this.getContext()),o=n.display?r.width:0;if(!o)return;const a=i.setContext(this.getContext(0)).lineWidth,l=this._borderValue;let c,h,u,d;this.isHorizontal()?(c=Ei(t,this.left,o)-o/2,h=Ei(t,this.right,a)+a/2,u=d=l):(u=Ei(t,this.top,o)-o/2,d=Ei(t,this.bottom,a)+a/2,c=h=l),e.save(),e.lineWidth=r.width,e.strokeStyle=r.color,e.beginPath(),e.moveTo(c,u),e.lineTo(h,d),e.stroke(),e.restore()}drawLabels(t){if(!this.options.ticks.display)return;const n=this.ctx,i=this._computeLabelArea();i&&hl(n,i);const r=this.getLabelItems(t);for(const o of r){const a=o.options,l=o.font,c=o.label,h=o.textOffset;Ki(n,c,0,h,l,a)}i&&ul(n)}drawTitle(){const{ctx:t,options:{position:e,title:n,reverse:i}}=this;if(!n.display)return;const r=de(n.font),o=De(n.padding),a=n.align;let l=r.lineHeight/2;e==="bottom"||e==="center"||kt(e)?(l+=o.bottom,$t(n.text)&&(l+=r.lineHeight*(n.text.length-1))):l+=o.top;const{titleX:c,titleY:h,maxWidth:u,rotation:d}=kE(this,l,e,a);Ki(t,n.text,0,0,r,{color:n.color,maxWidth:u,rotation:d,textAlign:FE(a,e,i),textBaseline:"middle",translation:[c,h]})}draw(t){this._isVisible()&&(this.drawBackground(),this.drawGrid(t),this.drawBorder(),this.drawTitle(),this.drawLabels(t))}_layers(){const t=this.options,e=t.ticks&&t.ticks.z||0,n=Pt(t.grid&&t.grid.z,-1),i=Pt(t.border&&t.border.z,0);return!this._isVisible()||this.draw!==cr.prototype.draw?[{z:e,draw:r=>{this.draw(r)}}]:[{z:n,draw:r=>{this.drawBackground(),this.drawGrid(r),this.drawTitle()}},{z:i,draw:()=>{this.drawBorder()}},{z:e,draw:r=>{this.drawLabels(r)}}]}getMatchingVisibleMetas(t){const e=this.chart.getSortedVisibleDatasetMetas(),n=this.axis+"AxisID",i=[];let r,o;for(r=0,o=e.length;r<o;++r){const a=e[r];a[n]===this.id&&(!t||a.type===t)&&i.push(a)}return i}_resolveTickFontOptions(t){const e=this.options.ticks.setContext(this.getContext(t));return de(e.font)}_maxDigits(){const t=this._resolveTickFontOptions(0).lineHeight;return(this.isHorizontal()?this.width:this.height)/t}}class _a{constructor(t,e,n){this.type=t,this.scope=e,this.override=n,this.items=Object.create(null)}isForType(t){return Object.prototype.isPrototypeOf.call(this.type.prototype,t.prototype)}register(t){const e=Object.getPrototypeOf(t);let n;zE(e)&&(n=this.register(e));const i=this.items,r=t.id,o=this.scope+"."+r;if(!r)throw new Error("class does not have id: "+t);return r in i||(i[r]=t,BE(t,o,n),this.override&&te.override(t.id,t.overrides)),o}get(t){return this.items[t]}unregister(t){const e=this.items,n=t.id,i=this.scope;n in e&&delete e[n],i&&n in te[i]&&(delete te[i][n],this.override&&delete $i[n])}}function BE(s,t,e){const n=eo(Object.create(null),[e?te.get(e):{},te.get(t),s.defaults]);te.set(t,n),s.defaultRoutes&&OE(t,s.defaultRoutes),s.descriptors&&te.describe(t,s.descriptors)}function OE(s,t){Object.keys(t).forEach(e=>{const n=e.split("."),i=n.pop(),r=[s].concat(n).join("."),o=t[e].split("."),a=o.pop(),l=o.join(".");te.route(r,i,l,a)})}function zE(s){return"id"in s&&"defaults"in s}class NE{constructor(){this.controllers=new _a(as,"datasets",!0),this.elements=new _a(Hn,"elements"),this.plugins=new _a(Object,"plugins"),this.scales=new _a(cr,"scales"),this._typedRegistries=[this.controllers,this.scales,this.elements]}add(...t){this._each("register",t)}remove(...t){this._each("unregister",t)}addControllers(...t){this._each("register",t,this.controllers)}addElements(...t){this._each("register",t,this.elements)}addPlugins(...t){this._each("register",t,this.plugins)}addScales(...t){this._each("register",t,this.scales)}getController(t){return this._get(t,this.controllers,"controller")}getElement(t){return this._get(t,this.elements,"element")}getPlugin(t){return this._get(t,this.plugins,"plugin")}getScale(t){return this._get(t,this.scales,"scale")}removeControllers(...t){this._each("unregister",t,this.controllers)}removeElements(...t){this._each("unregister",t,this.elements)}removePlugins(...t){this._each("unregister",t,this.plugins)}removeScales(...t){this._each("unregister",t,this.scales)}_each(t,e,n){[...e].forEach(i=>{const r=n||this._getRegistryForType(i);n||r.isForType(i)||r===this.plugins&&i.id?this._exec(t,r,i):Gt(i,o=>{const a=n||this._getRegistryForType(o);this._exec(t,a,o)})})}_exec(t,e,n){const i=tu(t);jt(n["before"+i],[],n),e[t](n),jt(n["after"+i],[],n)}_getRegistryForType(t){for(let e=0;e<this._typedRegistries.length;e++){const n=this._typedRegistries[e];if(n.isForType(t))return n}return this.plugins}_get(t,e,n){const i=e.get(t);if(i===void 0)throw new Error('"'+t+'" is not a registered '+n+".");return i}}var dn=new NE;class HE{constructor(){this._init=void 0}notify(t,e,n,i){if(e==="beforeInit"&&(this._init=this._createDescriptors(t,!0),this._notify(this._init,t,"install")),this._init===void 0)return;const r=i?this._descriptors(t).filter(i):this._descriptors(t),o=this._notify(r,t,e,n);return e==="afterDestroy"&&(this._notify(r,t,"stop"),this._notify(this._init,t,"uninstall"),this._init=void 0),o}_notify(t,e,n,i){i=i||{};for(const r of t){const o=r.plugin,a=o[n],l=[e,i,r.options];if(jt(a,l,o)===!1&&i.cancelable)return!1}return!0}invalidate(){zt(this._cache)||(this._oldCache=this._cache,this._cache=void 0)}_descriptors(t){if(this._cache)return this._cache;const e=this._cache=this._createDescriptors(t);return this._notifyStateChanges(t),e}_createDescriptors(t,e){const n=t&&t.config,i=Pt(n.options&&n.options.plugins,{}),r=UE(n);return i===!1&&!e?[]:WE(t,r,i,e)}_notifyStateChanges(t){const e=this._oldCache||[],n=this._cache,i=(r,o)=>r.filter(a=>!o.some(l=>a.plugin.id===l.plugin.id));this._notify(i(e,n),t,"stop"),this._notify(i(n,e),t,"start")}}function UE(s){const t={},e=[],n=Object.keys(dn.plugins.items);for(let r=0;r<n.length;r++)e.push(dn.getPlugin(n[r]));const i=s.plugins||[];for(let r=0;r<i.length;r++){const o=i[r];e.indexOf(o)===-1&&(e.push(o),t[o.id]=!0)}return{plugins:e,localIds:t}}function VE(s,t){return!t&&s===!1?null:s===!0?{}:s}function WE(s,{plugins:t,localIds:e},n,i){const r=[],o=s.getContext();for(const a of t){const l=a.id,c=VE(n[l],i);c!==null&&r.push({plugin:a,options:GE(s.config,{plugin:a,local:e[l]},c,o)})}return r}function GE(s,{plugin:t,local:e},n,i){const r=s.pluginScopeKeys(t),o=s.getOptionScopes(n,r);return e&&t.defaults&&o.push(t.defaults),s.createResolver(o,i,[""],{scriptable:!1,indexable:!1,allKeys:!0})}function Xc(s,t){const e=te.datasets[s]||{};return((t.datasets||{})[s]||{}).indexAxis||t.indexAxis||e.indexAxis||"x"}function XE(s,t){let e=s;return s==="_index_"?e=t:s==="_value_"&&(e=t==="x"?"y":"x"),e}function qE(s,t){return s===t?"_index_":"_value_"}function Rf(s){if(s==="x"||s==="y"||s==="r")return s}function YE(s){if(s==="top"||s==="bottom")return"x";if(s==="left"||s==="right")return"y"}function qc(s,...t){if(Rf(s))return s;for(const e of t){const n=e.axis||YE(e.position)||s.length>1&&Rf(s[0].toLowerCase());if(n)return n}throw new Error(`Cannot determine type of '${s}' axis. Please provide 'axis' or 'position' option.`)}function Pf(s,t,e){if(e[t+"AxisID"]===s)return{axis:t}}function jE(s,t){if(t.data&&t.data.datasets){const e=t.data.datasets.filter(n=>n.xAxisID===s||n.yAxisID===s);if(e.length)return Pf(s,"x",e[0])||Pf(s,"y",e[0])}return{}}function JE(s,t){const e=$i[s.type]||{scales:{}},n=t.scales||{},i=Xc(s.type,t),r=Object.create(null);return Object.keys(n).forEach(o=>{const a=n[o];if(!kt(a))return console.error(`Invalid scale configuration for scale: ${o}`);if(a._proxy)return console.warn(`Ignoring resolver passed as options for scale: ${o}`);const l=qc(o,a,jE(o,s),te.scales[a.type]),c=qE(l,i),h=e.scales||{};r[o]=Ir(Object.create(null),[{axis:l},a,h[l],h[c]])}),s.data.datasets.forEach(o=>{const a=o.type||s.type,l=o.indexAxis||Xc(a,t),h=($i[a]||{}).scales||{};Object.keys(h).forEach(u=>{const d=XE(u,l),f=o[d+"AxisID"]||d;r[f]=r[f]||Object.create(null),Ir(r[f],[{axis:d},n[f],h[u]])})}),Object.keys(r).forEach(o=>{const a=r[o];Ir(a,[te.scales[a.type],te.scale])}),r}function Nx(s){const t=s.options||(s.options={});t.plugins=Pt(t.plugins,{}),t.scales=JE(s,t)}function Hx(s){return s=s||{},s.datasets=s.datasets||[],s.labels=s.labels||[],s}function ZE(s){return s=s||{},s.data=Hx(s.data),Nx(s),s}const Df=new Map,Ux=new Set;function va(s,t){let e=Df.get(s);return e||(e=t(),Df.set(s,e),Ux.add(e)),e}const Sr=(s,t,e)=>{const n=hi(t,e);n!==void 0&&s.add(n)};class $E{constructor(t){this._config=ZE(t),this._scopeCache=new Map,this._resolverCache=new Map}get platform(){return this._config.platform}get type(){return this._config.type}set type(t){this._config.type=t}get data(){return this._config.data}set data(t){this._config.data=Hx(t)}get options(){return this._config.options}set options(t){this._config.options=t}get plugins(){return this._config.plugins}update(){const t=this._config;this.clearCache(),Nx(t)}clearCache(){this._scopeCache.clear(),this._resolverCache.clear()}datasetScopeKeys(t){return va(t,()=>[[`datasets.${t}`,""]])}datasetAnimationScopeKeys(t,e){return va(`${t}.transition.${e}`,()=>[[`datasets.${t}.transitions.${e}`,`transitions.${e}`],[`datasets.${t}`,""]])}datasetElementScopeKeys(t,e){return va(`${t}-${e}`,()=>[[`datasets.${t}.elements.${e}`,`datasets.${t}`,`elements.${e}`,""]])}pluginScopeKeys(t){const e=t.id,n=this.type;return va(`${n}-plugin-${e}`,()=>[[`plugins.${e}`,...t.additionalOptionScopes||[]]])}_cachedScopes(t,e){const n=this._scopeCache;let i=n.get(t);return(!i||e)&&(i=new Map,n.set(t,i)),i}getOptionScopes(t,e,n){const{options:i,type:r}=this,o=this._cachedScopes(t,n),a=o.get(e);if(a)return a;const l=new Set;e.forEach(h=>{t&&(l.add(t),h.forEach(u=>Sr(l,t,u))),h.forEach(u=>Sr(l,i,u)),h.forEach(u=>Sr(l,$i[r]||{},u)),h.forEach(u=>Sr(l,te,u)),h.forEach(u=>Sr(l,Wc,u))});const c=Array.from(l);return c.length===0&&c.push(Object.create(null)),Ux.has(e)&&o.set(e,c),c}chartOptionScopes(){const{options:t,type:e}=this;return[t,$i[e]||{},te.datasets[e]||{},{type:e},te,Wc]}resolveNamedOptions(t,e,n,i=[""]){const r={$shared:!0},{resolver:o,subPrefixes:a}=If(this._resolverCache,t,i);let l=o;if(QE(o,e)){r.$shared=!1,n=ui(n)?n():n;const c=this.createResolver(t,n,a);l=Qs(o,n,c)}for(const c of e)r[c]=l[c];return r}createResolver(t,e,n=[""],i){const{resolver:r}=If(this._resolverCache,t,n);return kt(e)?Qs(r,e,void 0,i):r}}function If(s,t,e){let n=s.get(t);n||(n=new Map,s.set(t,n));const i=e.join();let r=n.get(i);return r||(r={resolver:au(t,e),subPrefixes:e.filter(a=>!a.toLowerCase().includes("hover"))},n.set(i,r)),r}const KE=s=>kt(s)&&Object.getOwnPropertyNames(s).some(t=>ui(s[t]));function QE(s,t){const{isScriptable:e,isIndexable:n}=yx(s);for(const i of t){const r=e(i),o=n(i),a=(o||r)&&s[i];if(r&&(ui(a)||KE(a))||o&&$t(a))return!0}return!1}var tA="4.5.1";const eA=["top","bottom","left","right","chartArea"];function Ff(s,t){return s==="top"||s==="bottom"||eA.indexOf(s)===-1&&t==="x"}function kf(s,t){return function(e,n){return e[s]===n[s]?e[t]-n[t]:e[s]-n[s]}}function Bf(s){const t=s.chart,e=t.options.animation;t.notifyPlugins("afterRender"),jt(e&&e.onComplete,[s],t)}function nA(s){const t=s.chart,e=t.options.animation;jt(e&&e.onProgress,[s],t)}function Vx(s){return hu()&&typeof s=="string"?s=document.getElementById(s):s&&s.length&&(s=s[0]),s&&s.canvas&&(s=s.canvas),s}const Ea={},Of=s=>{const t=Vx(s);return Object.values(Ea).filter(e=>e.canvas===t).pop()};function iA(s,t,e){const n=Object.keys(s);for(const i of n){const r=+i;if(r>=t){const o=s[i];delete s[i],(e>0||r>t)&&(s[r+e]=o)}}}function sA(s,t,e,n){return!e||s.type==="mouseout"?null:n?t:s}let pl=class{static defaults=te;static instances=Ea;static overrides=$i;static registry=dn;static version=tA;static getChart=Of;static register(...t){dn.add(...t),zf()}static unregister(...t){dn.remove(...t),zf()}constructor(t,e){const n=this.config=new $E(e),i=Vx(t),r=Of(i);if(r)throw new Error("Canvas is already in use. Chart with ID '"+r.id+"' must be destroyed before the canvas with ID '"+r.canvas.id+"' can be reused.");const o=n.createResolver(n.chartOptionScopes(),this.getContext());this.platform=new(n.platform||ME(i)),this.platform.updateConfig(n);const a=this.platform.acquireContext(i,o.aspectRatio),l=a&&a.canvas,c=l&&l.height,h=l&&l.width;if(this.id=KS(),this.ctx=a,this.canvas=l,this.width=h,this.height=c,this._options=o,this._aspectRatio=this.aspectRatio,this._layers=[],this._metasets=[],this._stacks=void 0,this.boxes=[],this.currentDevicePixelRatio=void 0,this.chartArea=void 0,this._active=[],this._lastEvent=void 0,this._listeners={},this._responsiveListeners=void 0,this._sortedMetasets=[],this.scales={},this._plugins=new HE,this.$proxies={},this._hiddenIndices={},this.attached=!1,this._animationsDisabled=void 0,this.$context=void 0,this._doResize=g1(u=>this.update(u),o.resizeDelay||0),this._dataChanges=[],Ea[this.id]=this,!a||!l){console.error("Failed to create chart: can't acquire context from the given item");return}En.listen(this,"complete",Bf),En.listen(this,"progress",nA),this._initialize(),this.attached&&this.update()}get aspectRatio(){const{options:{aspectRatio:t,maintainAspectRatio:e},width:n,height:i,_aspectRatio:r}=this;return zt(t)?e&&r?r:i?n/i:null:t}get data(){return this.config.data}set data(t){this.config.data=t}get options(){return this._options}set options(t){this.config.options=t}get registry(){return dn}_initialize(){return this.notifyPlugins("beforeInit"),this.options.responsive?this.resize():of(this,this.options.devicePixelRatio),this.bindEvents(),this.notifyPlugins("afterInit"),this}clear(){return nf(this.canvas,this.ctx),this}stop(){return En.stop(this),this}resize(t,e){En.running(this)?this._resizeBeforeDraw={width:t,height:e}:this._resize(t,e)}_resize(t,e){const n=this.options,i=this.canvas,r=n.maintainAspectRatio&&this.aspectRatio,o=this.platform.getMaximumSize(i,t,e,r),a=n.devicePixelRatio||this.platform.getDevicePixelRatio(),l=this.width?"resize":"attach";this.width=o.width,this.height=o.height,this._aspectRatio=this.aspectRatio,of(this,a,!0)&&(this.notifyPlugins("resize",{size:o}),jt(n.onResize,[this,o],this),this.attached&&this._doResize(l)&&this.render())}ensureScalesHaveIDs(){const e=this.options.scales||{};Gt(e,(n,i)=>{n.id=i})}buildOrUpdateScales(){const t=this.options,e=t.scales,n=this.scales,i=Object.keys(n).reduce((o,a)=>(o[a]=!1,o),{});let r=[];e&&(r=r.concat(Object.keys(e).map(o=>{const a=e[o],l=qc(o,a),c=l==="r",h=l==="x";return{options:a,dposition:c?"chartArea":h?"bottom":"left",dtype:c?"radialLinear":h?"category":"linear"}}))),Gt(r,o=>{const a=o.options,l=a.id,c=qc(l,a),h=Pt(a.type,o.dtype);(a.position===void 0||Ff(a.position,c)!==Ff(o.dposition))&&(a.position=o.dposition),i[l]=!0;let u=null;if(l in n&&n[l].type===h)u=n[l];else{const d=dn.getScale(h);u=new d({id:l,type:h,ctx:this.ctx,chart:this}),n[u.id]=u}u.init(a,t)}),Gt(i,(o,a)=>{o||delete n[a]}),Gt(n,o=>{je.configure(this,o,o.options),je.addBox(this,o)})}_updateMetasets(){const t=this._metasets,e=this.data.datasets.length,n=t.length;if(t.sort((i,r)=>i.index-r.index),n>e){for(let i=e;i<n;++i)this._destroyDatasetMeta(i);t.splice(e,n-e)}this._sortedMetasets=t.slice(0).sort(kf("order","index"))}_removeUnreferencedMetasets(){const{_metasets:t,data:{datasets:e}}=this;t.length>e.length&&delete this._stacks,t.forEach((n,i)=>{e.filter(r=>r===n._dataset).length===0&&this._destroyDatasetMeta(i)})}buildOrUpdateControllers(){const t=[],e=this.data.datasets;let n,i;for(this._removeUnreferencedMetasets(),n=0,i=e.length;n<i;n++){const r=e[n];let o=this.getDatasetMeta(n);const a=r.type||this.config.type;if(o.type&&o.type!==a&&(this._destroyDatasetMeta(n),o=this.getDatasetMeta(n)),o.type=a,o.indexAxis=r.indexAxis||Xc(a,this.options),o.order=r.order||0,o.index=n,o.label=""+r.label,o.visible=this.isDatasetVisible(n),o.controller)o.controller.updateIndex(n),o.controller.linkScales();else{const l=dn.getController(a),{datasetElementType:c,dataElementType:h}=te.datasets[a];Object.assign(l,{dataElementType:dn.getElement(h),datasetElementType:c&&dn.getElement(c)}),o.controller=new l(this,n),t.push(o.controller)}}return this._updateMetasets(),t}_resetElements(){Gt(this.data.datasets,(t,e)=>{this.getDatasetMeta(e).controller.reset()},this)}reset(){this._resetElements(),this.notifyPlugins("reset")}update(t){const e=this.config;e.update();const n=this._options=e.createResolver(e.chartOptionScopes(),this.getContext()),i=this._animationsDisabled=!n.animation;if(this._updateScales(),this._checkEventBindings(),this._updateHiddenIndices(),this._plugins.invalidate(),this.notifyPlugins("beforeUpdate",{mode:t,cancelable:!0})===!1)return;const r=this.buildOrUpdateControllers();this.notifyPlugins("beforeElementsUpdate");let o=0;for(let c=0,h=this.data.datasets.length;c<h;c++){const{controller:u}=this.getDatasetMeta(c),d=!i&&r.indexOf(u)===-1;u.buildOrUpdateElements(d),o=Math.max(+u.getMaxOverflow(),o)}o=this._minPadding=n.layout.autoPadding?o:0,this._updateLayout(o),i||Gt(r,c=>{c.reset()}),this._updateDatasets(t),this.notifyPlugins("afterUpdate",{mode:t}),this._layers.sort(kf("z","_idx"));const{_active:a,_lastEvent:l}=this;l?this._eventHandler(l,!0):a.length&&this._updateHoverStyles(a,a,!0),this.render()}_updateScales(){Gt(this.scales,t=>{je.removeBox(this,t)}),this.ensureScalesHaveIDs(),this.buildOrUpdateScales()}_checkEventBindings(){const t=this.options,e=new Set(Object.keys(this._listeners)),n=new Set(t.events);(!Yd(e,n)||!!this._responsiveListeners!==t.responsive)&&(this.unbindEvents(),this.bindEvents())}_updateHiddenIndices(){const{_hiddenIndices:t}=this,e=this._getUniformDataChanges()||[];for(const{method:n,start:i,count:r}of e){const o=n==="_removeElements"?-r:r;iA(t,i,o)}}_getUniformDataChanges(){const t=this._dataChanges;if(!t||!t.length)return;this._dataChanges=[];const e=this.data.datasets.length,n=r=>new Set(t.filter(o=>o[0]===r).map((o,a)=>a+","+o.splice(1).join(","))),i=n(0);for(let r=1;r<e;r++)if(!Yd(i,n(r)))return;return Array.from(i).map(r=>r.split(",")).map(r=>({method:r[1],start:+r[2],count:+r[3]}))}_updateLayout(t){if(this.notifyPlugins("beforeLayout",{cancelable:!0})===!1)return;je.update(this,this.width,this.height,t);const e=this.chartArea,n=e.width<=0||e.height<=0;this._layers=[],Gt(this.boxes,i=>{n&&i.position==="chartArea"||(i.configure&&i.configure(),this._layers.push(...i._layers()))},this),this._layers.forEach((i,r)=>{i._idx=r}),this.notifyPlugins("afterLayout")}_updateDatasets(t){if(this.notifyPlugins("beforeDatasetsUpdate",{mode:t,cancelable:!0})!==!1){for(let e=0,n=this.data.datasets.length;e<n;++e)this.getDatasetMeta(e).controller.configure();for(let e=0,n=this.data.datasets.length;e<n;++e)this._updateDataset(e,ui(t)?t({datasetIndex:e}):t);this.notifyPlugins("afterDatasetsUpdate",{mode:t})}}_updateDataset(t,e){const n=this.getDatasetMeta(t),i={meta:n,index:t,mode:e,cancelable:!0};this.notifyPlugins("beforeDatasetUpdate",i)!==!1&&(n.controller._update(e),i.cancelable=!1,this.notifyPlugins("afterDatasetUpdate",i))}render(){this.notifyPlugins("beforeRender",{cancelable:!0})!==!1&&(En.has(this)?this.attached&&!En.running(this)&&En.start(this):(this.draw(),Bf({chart:this})))}draw(){let t;if(this._resizeBeforeDraw){const{width:n,height:i}=this._resizeBeforeDraw;this._resizeBeforeDraw=null,this._resize(n,i)}if(this.clear(),this.width<=0||this.height<=0||this.notifyPlugins("beforeDraw",{cancelable:!0})===!1)return;const e=this._layers;for(t=0;t<e.length&&e[t].z<=0;++t)e[t].draw(this.chartArea);for(this._drawDatasets();t<e.length;++t)e[t].draw(this.chartArea);this.notifyPlugins("afterDraw")}_getSortedDatasetMetas(t){const e=this._sortedMetasets,n=[];let i,r;for(i=0,r=e.length;i<r;++i){const o=e[i];(!t||o.visible)&&n.push(o)}return n}getSortedVisibleDatasetMetas(){return this._getSortedDatasetMetas(!0)}_drawDatasets(){if(this.notifyPlugins("beforeDatasetsDraw",{cancelable:!0})===!1)return;const t=this.getSortedVisibleDatasetMetas();for(let e=t.length-1;e>=0;--e)this._drawDataset(t[e]);this.notifyPlugins("afterDatasetsDraw")}_drawDataset(t){const e=this.ctx,n={meta:t,index:t.index,cancelable:!0},i=Cx(this,t);this.notifyPlugins("beforeDatasetDraw",n)!==!1&&(i&&hl(e,i),t.controller.draw(),i&&ul(e),n.cancelable=!1,this.notifyPlugins("afterDatasetDraw",n))}isPointInArea(t){return Dn(t,this.chartArea,this._minPadding)}getElementsAtEventForMode(t,e,n,i){const r=eE.modes[e];return typeof r=="function"?r(this,t,n,i):[]}getDatasetMeta(t){const e=this.data.datasets[t],n=this._metasets;let i=n.filter(r=>r&&r._dataset===e).pop();return i||(i={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:e&&e.order||0,index:t,_dataset:e,_parsed:[],_sorted:!1},n.push(i)),i}getContext(){return this.$context||(this.$context=mi(null,{chart:this,type:"chart"}))}getVisibleDatasetCount(){return this.getSortedVisibleDatasetMetas().length}isDatasetVisible(t){const e=this.data.datasets[t];if(!e)return!1;const n=this.getDatasetMeta(t);return typeof n.hidden=="boolean"?!n.hidden:!e.hidden}setDatasetVisibility(t,e){const n=this.getDatasetMeta(t);n.hidden=!e}toggleDataVisibility(t){this._hiddenIndices[t]=!this._hiddenIndices[t]}getDataVisibility(t){return!this._hiddenIndices[t]}_updateVisibility(t,e,n){const i=n?"show":"hide",r=this.getDatasetMeta(t),o=r.controller._resolveAnimations(void 0,i);no(e)?(r.data[e].hidden=!n,this.update()):(this.setDatasetVisibility(t,n),o.update(r,{visible:n}),this.update(a=>a.datasetIndex===t?i:void 0))}hide(t,e){this._updateVisibility(t,e,!1)}show(t,e){this._updateVisibility(t,e,!0)}_destroyDatasetMeta(t){const e=this._metasets[t];e&&e.controller&&e.controller._destroy(),delete this._metasets[t]}_stop(){let t,e;for(this.stop(),En.remove(this),t=0,e=this.data.datasets.length;t<e;++t)this._destroyDatasetMeta(t)}destroy(){this.notifyPlugins("beforeDestroy");const{canvas:t,ctx:e}=this;this._stop(),this.config.clearCache(),t&&(this.unbindEvents(),nf(t,e),this.platform.releaseContext(e),this.canvas=null,this.ctx=null),delete Ea[this.id],this.notifyPlugins("afterDestroy")}toBase64Image(...t){return this.canvas.toDataURL(...t)}bindEvents(){this.bindUserEvents(),this.options.responsive?this.bindResponsiveEvents():this.attached=!0}bindUserEvents(){const t=this._listeners,e=this.platform,n=(r,o)=>{e.addEventListener(this,r,o),t[r]=o},i=(r,o,a)=>{r.offsetX=o,r.offsetY=a,this._eventHandler(r)};Gt(this.options.events,r=>n(r,i))}bindResponsiveEvents(){this._responsiveListeners||(this._responsiveListeners={});const t=this._responsiveListeners,e=this.platform,n=(l,c)=>{e.addEventListener(this,l,c),t[l]=c},i=(l,c)=>{t[l]&&(e.removeEventListener(this,l,c),delete t[l])},r=(l,c)=>{this.canvas&&this.resize(l,c)};let o;const a=()=>{i("attach",a),this.attached=!0,this.resize(),n("resize",r),n("detach",o)};o=()=>{this.attached=!1,i("resize",r),this._stop(),this._resize(0,0),n("attach",a)},e.isAttached(this.canvas)?a():o()}unbindEvents(){Gt(this._listeners,(t,e)=>{this.platform.removeEventListener(this,e,t)}),this._listeners={},Gt(this._responsiveListeners,(t,e)=>{this.platform.removeEventListener(this,e,t)}),this._responsiveListeners=void 0}updateHoverStyle(t,e,n){const i=n?"set":"remove";let r,o,a,l;for(e==="dataset"&&(r=this.getDatasetMeta(t[0].datasetIndex),r.controller["_"+i+"DatasetHoverStyle"]()),a=0,l=t.length;a<l;++a){o=t[a];const c=o&&this.getDatasetMeta(o.datasetIndex).controller;c&&c[i+"HoverStyle"](o.element,o.datasetIndex,o.index)}}getActiveElements(){return this._active||[]}setActiveElements(t){const e=this._active||[],n=t.map(({datasetIndex:r,index:o})=>{const a=this.getDatasetMeta(r);if(!a)throw new Error("No dataset found at index "+r);return{datasetIndex:r,element:a.data[o],index:o}});!Ia(n,e)&&(this._active=n,this._lastEvent=null,this._updateHoverStyles(n,e))}notifyPlugins(t,e,n){return this._plugins.notify(this,t,e,n)}isPluginEnabled(t){return this._plugins._cache.filter(e=>e.plugin.id===t).length===1}_updateHoverStyles(t,e,n){const i=this.options.hover,r=(l,c)=>l.filter(h=>!c.some(u=>h.datasetIndex===u.datasetIndex&&h.index===u.index)),o=r(e,t),a=n?t:r(t,e);o.length&&this.updateHoverStyle(o,i.mode,!1),a.length&&i.mode&&this.updateHoverStyle(a,i.mode,!0)}_eventHandler(t,e){const n={event:t,replay:e,cancelable:!0,inChartArea:this.isPointInArea(t)},i=o=>(o.options.events||this.options.events).includes(t.native.type);if(this.notifyPlugins("beforeEvent",n,i)===!1)return;const r=this._handleEvent(t,e,n.inChartArea);return n.cancelable=!1,this.notifyPlugins("afterEvent",n,i),(r||n.changed)&&this.render(),this}_handleEvent(t,e,n){const{_active:i=[],options:r}=this,o=e,a=this._getActiveElements(t,i,n,o),l=s1(t),c=sA(t,this._lastEvent,n,l);n&&(this._lastEvent=null,jt(r.onHover,[t,a,this],this),l&&jt(r.onClick,[t,a,this],this));const h=!Ia(a,i);return(h||e)&&(this._active=a,this._updateHoverStyles(a,i,e)),this._lastEvent=c,h}_getActiveElements(t,e,n,i){if(t.type==="mouseout")return[];if(!n)return e;const r=this.options.hover;return this.getElementsAtEventForMode(t,r.mode,r,i)}};function zf(){return Gt(pl.instances,s=>s._plugins.invalidate())}function rA(s,t,e){const{startAngle:n,x:i,y:r,outerRadius:o,innerRadius:a,options:l}=t,{borderWidth:c,borderJoinStyle:h}=l,u=Math.min(c/o,Ce(n-e));if(s.beginPath(),s.arc(i,r,o-c/2,n+u/2,e-u/2),a>0){const d=Math.min(c/a,Ce(n-e));s.arc(i,r,a+c/2,e-d/2,n+d/2,!0)}else{const d=Math.min(c/2,o*Ce(n-e));if(h==="round")s.arc(i,r,d,e-Vt/2,n+Vt/2,!0);else if(h==="bevel"){const f=2*d*d,p=-f*Math.cos(e+Vt/2)+i,m=-f*Math.sin(e+Vt/2)+r,y=f*Math.cos(n+Vt/2)+i,g=f*Math.sin(n+Vt/2)+r;s.lineTo(p,m),s.lineTo(y,g)}}s.closePath(),s.moveTo(0,0),s.rect(0,0,s.canvas.width,s.canvas.height),s.clip("evenodd")}function oA(s,t,e){const{startAngle:n,pixelMargin:i,x:r,y:o,outerRadius:a,innerRadius:l}=t;let c=i/a;s.beginPath(),s.arc(r,o,a,n-c,e+c),l>i?(c=i/l,s.arc(r,o,l,e+c,n-c,!0)):s.arc(r,o,i,e+oe,n-oe),s.closePath(),s.clip()}function aA(s){return ou(s,["outerStart","outerEnd","innerStart","innerEnd"])}function lA(s,t,e,n){const i=aA(s.options.borderRadius),r=(e-t)/2,o=Math.min(r,n*t/2),a=l=>{const c=(e-Math.min(r,l))*n/2;return Re(l,0,Math.min(r,c))};return{outerStart:a(i.outerStart),outerEnd:a(i.outerEnd),innerStart:Re(i.innerStart,0,o),innerEnd:Re(i.innerEnd,0,o)}}function Rs(s,t,e,n){return{x:e+s*Math.cos(t),y:n+s*Math.sin(t)}}function Na(s,t,e,n,i,r){const{x:o,y:a,startAngle:l,pixelMargin:c,innerRadius:h}=t,u=Math.max(t.outerRadius+n+e-c,0),d=h>0?h+n+e+c:0;let f=0;const p=i-l;if(n){const O=h>0?h-n:0,F=u>0?u-n:0,N=(O+F)/2,Z=N!==0?p*N/(N+n):p;f=(p-Z)/2}const m=Math.max(.001,p*u-e/Vt)/u,y=(p-m)/2,g=l+y+f,x=i-y-f,{outerStart:v,outerEnd:_,innerStart:M,innerEnd:w}=lA(t,d,u,x-g),b=u-v,E=u-_,P=g+v/b,R=x-_/E,C=d+M,U=d+w,k=g+M/C,B=x-w/U;if(s.beginPath(),r){const O=(P+R)/2;if(s.arc(o,a,u,P,O),s.arc(o,a,u,O,R),_>0){const tt=Rs(E,R,o,a);s.arc(tt.x,tt.y,_,R,x+oe)}const F=Rs(U,x,o,a);if(s.lineTo(F.x,F.y),w>0){const tt=Rs(U,B,o,a);s.arc(tt.x,tt.y,w,x+oe,B+Math.PI)}const N=(x-w/d+(g+M/d))/2;if(s.arc(o,a,d,x-w/d,N,!0),s.arc(o,a,d,N,g+M/d,!0),M>0){const tt=Rs(C,k,o,a);s.arc(tt.x,tt.y,M,k+Math.PI,g-oe)}const Z=Rs(b,g,o,a);if(s.lineTo(Z.x,Z.y),v>0){const tt=Rs(b,P,o,a);s.arc(tt.x,tt.y,v,g-oe,P)}}else{s.moveTo(o,a);const O=Math.cos(P)*u+o,F=Math.sin(P)*u+a;s.lineTo(O,F);const N=Math.cos(R)*u+o,Z=Math.sin(R)*u+a;s.lineTo(N,Z)}s.closePath()}function cA(s,t,e,n,i){const{fullCircles:r,startAngle:o,circumference:a}=t;let l=t.endAngle;if(r){Na(s,t,e,n,l,i);for(let c=0;c<r;++c)s.fill();isNaN(a)||(l=o+(a%Zt||Zt))}return Na(s,t,e,n,l,i),s.fill(),l}function hA(s,t,e,n,i){const{fullCircles:r,startAngle:o,circumference:a,options:l}=t,{borderWidth:c,borderJoinStyle:h,borderDash:u,borderDashOffset:d,borderRadius:f}=l,p=l.borderAlign==="inner";if(!c)return;s.setLineDash(u||[]),s.lineDashOffset=d,p?(s.lineWidth=c*2,s.lineJoin=h||"round"):(s.lineWidth=c,s.lineJoin=h||"bevel");let m=t.endAngle;if(r){Na(s,t,e,n,m,i);for(let y=0;y<r;++y)s.stroke();isNaN(a)||(m=o+(a%Zt||Zt))}p&&oA(s,t,m),l.selfJoin&&m-o>=Vt&&f===0&&h!=="miter"&&rA(s,t,m),r||(Na(s,t,e,n,m,i),s.stroke())}class uA extends Hn{static id="arc";static defaults={borderAlign:"center",borderColor:"#fff",borderDash:[],borderDashOffset:0,borderJoinStyle:void 0,borderRadius:0,borderWidth:2,offset:0,spacing:0,angle:void 0,circular:!0,selfJoin:!1};static defaultRoutes={backgroundColor:"backgroundColor"};static descriptors={_scriptable:!0,_indexable:t=>t!=="borderDash"};circumference;endAngle;fullCircles;innerRadius;outerRadius;pixelMargin;startAngle;constructor(t){super(),this.options=void 0,this.circumference=void 0,this.startAngle=void 0,this.endAngle=void 0,this.innerRadius=void 0,this.outerRadius=void 0,this.pixelMargin=0,this.fullCircles=0,t&&Object.assign(this,t)}inRange(t,e,n){const i=this.getProps(["x","y"],n),{angle:r,distance:o}=cx(i,{x:t,y:e}),{startAngle:a,endAngle:l,innerRadius:c,outerRadius:h,circumference:u}=this.getProps(["startAngle","endAngle","innerRadius","outerRadius","circumference"],n),d=(this.options.spacing+this.options.borderWidth)/2,f=Pt(u,l-a),p=io(r,a,l)&&a!==l,m=f>=Zt||p,y=Pn(o,c+d,h+d);return m&&y}getCenterPoint(t){const{x:e,y:n,startAngle:i,endAngle:r,innerRadius:o,outerRadius:a}=this.getProps(["x","y","startAngle","endAngle","innerRadius","outerRadius"],t),{offset:l,spacing:c}=this.options,h=(i+r)/2,u=(o+a+c+l)/2;return{x:e+Math.cos(h)*u,y:n+Math.sin(h)*u}}tooltipPosition(t){return this.getCenterPoint(t)}draw(t){const{options:e,circumference:n}=this,i=(e.offset||0)/4,r=(e.spacing||0)/2,o=e.circular;if(this.pixelMargin=e.borderAlign==="inner"?.33:0,this.fullCircles=n>Zt?Math.floor(n/Zt):0,n===0||this.innerRadius<0||this.outerRadius<0)return;t.save();const a=(this.startAngle+this.endAngle)/2;t.translate(Math.cos(a)*i,Math.sin(a)*i);const l=1-Math.sin(Math.min(Vt,n||0)),c=i*l;t.fillStyle=e.backgroundColor,t.strokeStyle=e.borderColor,cA(t,this,c,r,o),hA(t,this,c,r,o),t.restore()}}function Wx(s,t,e=t){s.lineCap=Pt(e.borderCapStyle,t.borderCapStyle),s.setLineDash(Pt(e.borderDash,t.borderDash)),s.lineDashOffset=Pt(e.borderDashOffset,t.borderDashOffset),s.lineJoin=Pt(e.borderJoinStyle,t.borderJoinStyle),s.lineWidth=Pt(e.borderWidth,t.borderWidth),s.strokeStyle=Pt(e.borderColor,t.borderColor)}function dA(s,t,e){s.lineTo(e.x,e.y)}function fA(s){return s.stepped?C1:s.tension||s.cubicInterpolationMode==="monotone"?R1:dA}function Gx(s,t,e={}){const n=s.length,{start:i=0,end:r=n-1}=e,{start:o,end:a}=t,l=Math.max(i,o),c=Math.min(r,a),h=i<o&&r<o||i>a&&r>a;return{count:n,start:l,loop:t.loop,ilen:c<l&&!h?n+c-l:c-l}}function pA(s,t,e,n){const{points:i,options:r}=t,{count:o,start:a,loop:l,ilen:c}=Gx(i,e,n),h=fA(r);let{move:u=!0,reverse:d}=n||{},f,p,m;for(f=0;f<=c;++f)p=i[(a+(d?c-f:f))%o],!p.skip&&(u?(s.moveTo(p.x,p.y),u=!1):h(s,m,p,d,r.stepped),m=p);return l&&(p=i[(a+(d?c:0))%o],h(s,m,p,d,r.stepped)),!!l}function mA(s,t,e,n){const i=t.points,{count:r,start:o,ilen:a}=Gx(i,e,n),{move:l=!0,reverse:c}=n||{};let h=0,u=0,d,f,p,m,y,g;const x=_=>(o+(c?a-_:_))%r,v=()=>{m!==y&&(s.lineTo(h,y),s.lineTo(h,m),s.lineTo(h,g))};for(l&&(f=i[x(0)],s.moveTo(f.x,f.y)),d=0;d<=a;++d){if(f=i[x(d)],f.skip)continue;const _=f.x,M=f.y,w=_|0;w===p?(M<m?m=M:M>y&&(y=M),h=(u*h+_)/++u):(v(),s.lineTo(_,M),p=w,u=0,m=y=M),g=M}v()}function Yc(s){const t=s.options,e=t.borderDash&&t.borderDash.length;return!s._decimated&&!s._loop&&!t.tension&&t.cubicInterpolationMode!=="monotone"&&!t.stepped&&!e?mA:pA}function gA(s){return s.stepped?lT:s.tension||s.cubicInterpolationMode==="monotone"?cT:Ri}function xA(s,t,e,n){let i=t._path;i||(i=t._path=new Path2D,t.path(i,e,n)&&i.closePath()),Wx(s,t.options),s.stroke(i)}function yA(s,t,e,n){const{segments:i,options:r}=t,o=Yc(t);for(const a of i)Wx(s,r,a.style),s.beginPath(),o(s,t,a,{start:e,end:e+n-1})&&s.closePath(),s.stroke()}const _A=typeof Path2D=="function";function vA(s,t,e,n){_A&&!t.options.segment?xA(s,t,e,n):yA(s,t,e,n)}class ml extends Hn{static id="line";static defaults={borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",borderWidth:3,capBezierPoints:!0,cubicInterpolationMode:"default",fill:!1,spanGaps:!1,stepped:!1,tension:0};static defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"};static descriptors={_scriptable:!0,_indexable:t=>t!=="borderDash"&&t!=="fill"};constructor(t){super(),this.animated=!0,this.options=void 0,this._chart=void 0,this._loop=void 0,this._fullLoop=void 0,this._path=void 0,this._points=void 0,this._segments=void 0,this._decimated=!1,this._pointsUpdated=!1,this._datasetIndex=void 0,t&&Object.assign(this,t)}updateControlPoints(t,e){const n=this.options;if((n.tension||n.cubicInterpolationMode==="monotone")&&!n.stepped&&!this._pointsUpdated){const i=n.spanGaps?this._loop:this._fullLoop;tT(this._points,n,t,i,e),this._pointsUpdated=!0}}set points(t){this._points=t,delete this._segments,delete this._path,this._pointsUpdated=!1}get points(){return this._points}get segments(){return this._segments||(this._segments=mT(this,this.options.segment))}first(){const t=this.segments,e=this.points;return t.length&&e[t[0].start]}last(){const t=this.segments,e=this.points,n=t.length;return n&&e[t[n-1].end]}interpolate(t,e){const n=this.options,i=t[e],r=this.points,o=Lx(this,{property:e,start:i,end:i});if(!o.length)return;const a=[],l=gA(n);let c,h;for(c=0,h=o.length;c<h;++c){const{start:u,end:d}=o[c],f=r[u],p=r[d];if(f===p){a.push(f);continue}const m=Math.abs((i-f[e])/(p[e]-f[e])),y=l(f,p,m,n.stepped);y[e]=t[e],a.push(y)}return a.length===1?a[0]:a}pathSegment(t,e,n){return Yc(this)(t,this,e,n)}path(t,e,n){const i=this.segments,r=Yc(this);let o=this._loop;e=e||0,n=n||this.points.length-e;for(const a of i)o&=r(t,this,a,{start:e,end:e+n-1});return!!o}draw(t,e,n,i){const r=this.options||{};(this.points||[]).length&&r.borderWidth&&(t.save(),vA(t,this,n,i),t.restore()),this.animated&&(this._pointsUpdated=!1,this._path=void 0)}}function Nf(s,t,e,n){const i=s.options,{[e]:r}=s.getProps([e],n);return Math.abs(t-r)<i.radius+i.hitRadius}class bA extends Hn{static id="point";parsed;skip;stop;static defaults={borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:"circle",radius:3,rotation:0};static defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"};constructor(t){super(),this.options=void 0,this.parsed=void 0,this.skip=void 0,this.stop=void 0,t&&Object.assign(this,t)}inRange(t,e,n){const i=this.options,{x:r,y:o}=this.getProps(["x","y"],n);return Math.pow(t-r,2)+Math.pow(e-o,2)<Math.pow(i.hitRadius+i.radius,2)}inXRange(t,e){return Nf(this,t,"x",e)}inYRange(t,e){return Nf(this,t,"y",e)}getCenterPoint(t){const{x:e,y:n}=this.getProps(["x","y"],t);return{x:e,y:n}}size(t){t=t||this.options||{};let e=t.radius||0;e=Math.max(e,e&&t.hoverRadius||0);const n=e&&t.borderWidth||0;return(e+n)*2}draw(t,e){const n=this.options;this.skip||n.radius<.1||!Dn(this,e,this.size(n)/2)||(t.strokeStyle=n.borderColor,t.lineWidth=n.borderWidth,t.fillStyle=n.backgroundColor,Gc(t,n,this.x,this.y))}getRange(){const t=this.options||{};return t.radius+t.hitRadius}}function Xx(s,t){const{x:e,y:n,base:i,width:r,height:o}=s.getProps(["x","y","base","width","height"],t);let a,l,c,h,u;return s.horizontal?(u=o/2,a=Math.min(e,i),l=Math.max(e,i),c=n-u,h=n+u):(u=r/2,a=e-u,l=e+u,c=Math.min(n,i),h=Math.max(n,i)),{left:a,top:c,right:l,bottom:h}}function ei(s,t,e,n){return s?0:Re(t,e,n)}function MA(s,t,e){const n=s.options.borderWidth,i=s.borderSkipped,r=xx(n);return{t:ei(i.top,r.top,0,e),r:ei(i.right,r.right,0,t),b:ei(i.bottom,r.bottom,0,e),l:ei(i.left,r.left,0,t)}}function wA(s,t,e){const{enableBorderRadius:n}=s.getProps(["enableBorderRadius"]),i=s.options.borderRadius,r=Hi(i),o=Math.min(t,e),a=s.borderSkipped,l=n||kt(i);return{topLeft:ei(!l||a.top||a.left,r.topLeft,0,o),topRight:ei(!l||a.top||a.right,r.topRight,0,o),bottomLeft:ei(!l||a.bottom||a.left,r.bottomLeft,0,o),bottomRight:ei(!l||a.bottom||a.right,r.bottomRight,0,o)}}function SA(s){const t=Xx(s),e=t.right-t.left,n=t.bottom-t.top,i=MA(s,e/2,n/2),r=wA(s,e/2,n/2);return{outer:{x:t.left,y:t.top,w:e,h:n,radius:r},inner:{x:t.left+i.l,y:t.top+i.t,w:e-i.l-i.r,h:n-i.t-i.b,radius:{topLeft:Math.max(0,r.topLeft-Math.max(i.t,i.l)),topRight:Math.max(0,r.topRight-Math.max(i.t,i.r)),bottomLeft:Math.max(0,r.bottomLeft-Math.max(i.b,i.l)),bottomRight:Math.max(0,r.bottomRight-Math.max(i.b,i.r))}}}}function fc(s,t,e,n){const i=t===null,r=e===null,a=s&&!(i&&r)&&Xx(s,n);return a&&(i||Pn(t,a.left,a.right))&&(r||Pn(e,a.top,a.bottom))}function TA(s){return s.topLeft||s.topRight||s.bottomLeft||s.bottomRight}function EA(s,t){s.rect(t.x,t.y,t.w,t.h)}function pc(s,t,e={}){const n=s.x!==e.x?-t:0,i=s.y!==e.y?-t:0,r=(s.x+s.w!==e.x+e.w?t:0)-n,o=(s.y+s.h!==e.y+e.h?t:0)-i;return{x:s.x+n,y:s.y+i,w:s.w+r,h:s.h+o,radius:s.radius}}class AA extends Hn{static id="bar";static defaults={borderSkipped:"start",borderWidth:0,borderRadius:0,inflateAmount:"auto",pointStyle:void 0};static defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"};constructor(t){super(),this.options=void 0,this.horizontal=void 0,this.base=void 0,this.width=void 0,this.height=void 0,this.inflateAmount=void 0,t&&Object.assign(this,t)}draw(t){const{inflateAmount:e,options:{borderColor:n,backgroundColor:i}}=this,{inner:r,outer:o}=SA(this),a=TA(o.radius)?so:EA;t.save(),(o.w!==r.w||o.h!==r.h)&&(t.beginPath(),a(t,pc(o,e,r)),t.clip(),a(t,pc(r,-e,o)),t.fillStyle=n,t.fill("evenodd")),t.beginPath(),a(t,pc(r,e)),t.fillStyle=i,t.fill(),t.restore()}inRange(t,e,n){return fc(this,t,e,n)}inXRange(t,e){return fc(this,t,null,e)}inYRange(t,e){return fc(this,null,t,e)}getCenterPoint(t){const{x:e,y:n,base:i,horizontal:r}=this.getProps(["x","y","base","horizontal"],t);return{x:r?(e+i)/2:e,y:r?n:(n+i)/2}}getRange(t){return t==="x"?this.width/2:this.height/2}}function LA(s,t,e){const n=s.segments,i=s.points,r=t.points,o=[];for(const a of n){let{start:l,end:c}=a;c=gl(l,c,i);const h=jc(e,i[l],i[c],a.loop);if(!t.segments){o.push({source:a,target:h,start:i[l],end:i[c]});continue}const u=Lx(t,h);for(const d of u){const f=jc(e,r[d.start],r[d.end],d.loop),p=Ax(a,i,f);for(const m of p)o.push({source:m,target:d,start:{[e]:Hf(h,f,"start",Math.max)},end:{[e]:Hf(h,f,"end",Math.min)}})}}return o}function jc(s,t,e,n){if(n)return;let i=t[s],r=e[s];return s==="angle"&&(i=Ce(i),r=Ce(r)),{property:s,start:i,end:r}}function CA(s,t){const{x:e=null,y:n=null}=s||{},i=t.points,r=[];return t.segments.forEach(({start:o,end:a})=>{a=gl(o,a,i);const l=i[o],c=i[a];n!==null?(r.push({x:l.x,y:n}),r.push({x:c.x,y:n})):e!==null&&(r.push({x:e,y:l.y}),r.push({x:e,y:c.y}))}),r}function gl(s,t,e){for(;t>s;t--){const n=e[t];if(!isNaN(n.x)&&!isNaN(n.y))break}return t}function Hf(s,t,e,n){return s&&t?n(s[e],t[e]):s?s[e]:t?t[e]:0}function qx(s,t){let e=[],n=!1;return $t(s)?(n=!0,e=s):e=CA(s,t),e.length?new ml({points:e,options:{tension:0},_loop:n,_fullLoop:n}):null}function Uf(s){return s&&s.fill!==!1}function RA(s,t,e){let i=s[t].fill;const r=[t];let o;if(!e)return i;for(;i!==!1&&r.indexOf(i)===-1;){if(!xe(i))return i;if(o=s[i],!o)return!1;if(o.visible)return i;r.push(i),i=o.fill}return!1}function PA(s,t,e){const n=kA(s);if(kt(n))return isNaN(n.value)?!1:n;let i=parseFloat(n);return xe(i)&&Math.floor(i)===i?DA(n[0],t,i,e):["origin","start","end","stack","shape"].indexOf(n)>=0&&n}function DA(s,t,e,n){return(s==="-"||s==="+")&&(e=t+e),e===t||e<0||e>=n?!1:e}function IA(s,t){let e=null;return s==="start"?e=t.bottom:s==="end"?e=t.top:kt(s)?e=t.getPixelForValue(s.value):t.getBasePixel&&(e=t.getBasePixel()),e}function FA(s,t,e){let n;return s==="start"?n=e:s==="end"?n=t.options.reverse?t.min:t.max:kt(s)?n=s.value:n=t.getBaseValue(),n}function kA(s){const t=s.options,e=t.fill;let n=Pt(e&&e.target,e);return n===void 0&&(n=!!t.backgroundColor),n===!1||n===null?!1:n===!0?"origin":n}function BA(s){const{scale:t,index:e,line:n}=s,i=[],r=n.segments,o=n.points,a=OA(t,e);a.push(qx({x:null,y:t.bottom},n));for(let l=0;l<r.length;l++){const c=r[l];for(let h=c.start;h<=c.end;h++)zA(i,o[h],a)}return new ml({points:i,options:{}})}function OA(s,t){const e=[],n=s.getMatchingVisibleMetas("line");for(let i=0;i<n.length;i++){const r=n[i];if(r.index===t)break;r.hidden||e.unshift(r.dataset)}return e}function zA(s,t,e){const n=[];for(let i=0;i<e.length;i++){const r=e[i],{first:o,last:a,point:l}=NA(r,t,"x");if(!(!l||o&&a)){if(o)n.unshift(l);else if(s.push(l),!a)break}}s.push(...n)}function NA(s,t,e){const n=s.interpolate(t,e);if(!n)return{};const i=n[e],r=s.segments,o=s.points;let a=!1,l=!1;for(let c=0;c<r.length;c++){const h=r[c],u=o[h.start][e],d=o[h.end][e];if(Pn(i,u,d)){a=i===u,l=i===d;break}}return{first:a,last:l,point:n}}class Yx{constructor(t){this.x=t.x,this.y=t.y,this.radius=t.radius}pathSegment(t,e,n){const{x:i,y:r,radius:o}=this;return e=e||{start:0,end:Zt},t.arc(i,r,o,e.end,e.start,!0),!n.bounds}interpolate(t){const{x:e,y:n,radius:i}=this,r=t.angle;return{x:e+Math.cos(r)*i,y:n+Math.sin(r)*i,angle:r}}}function HA(s){const{chart:t,fill:e,line:n}=s;if(xe(e))return UA(t,e);if(e==="stack")return BA(s);if(e==="shape")return!0;const i=VA(s);return i instanceof Yx?i:qx(i,n)}function UA(s,t){const e=s.getDatasetMeta(t);return e&&s.isDatasetVisible(t)?e.dataset:null}function VA(s){return(s.scale||{}).getPointPositionForValue?GA(s):WA(s)}function WA(s){const{scale:t={},fill:e}=s,n=IA(e,t);if(xe(n)){const i=t.isHorizontal();return{x:i?n:null,y:i?null:n}}return null}function GA(s){const{scale:t,fill:e}=s,n=t.options,i=t.getLabels().length,r=n.reverse?t.max:t.min,o=FA(e,t,r),a=[];if(n.grid.circular){const l=t.getPointPositionForValue(0,r);return new Yx({x:l.x,y:l.y,radius:t.getDistanceFromCenterForValue(o)})}for(let l=0;l<i;++l)a.push(t.getPointPositionForValue(l,o));return a}function mc(s,t,e){const n=HA(t),{chart:i,index:r,line:o,scale:a,axis:l}=t,c=o.options,h=c.fill,u=c.backgroundColor,{above:d=u,below:f=u}=h||{},p=i.getDatasetMeta(r),m=Cx(i,p);n&&o.points.length&&(hl(s,e),XA(s,{line:o,target:n,above:d,below:f,area:e,scale:a,axis:l,clip:m}),ul(s))}function XA(s,t){const{line:e,target:n,above:i,below:r,area:o,scale:a,clip:l}=t,c=e._loop?"angle":t.axis;s.save();let h=r;r!==i&&(c==="x"?(Vf(s,n,o.top),gc(s,{line:e,target:n,color:i,scale:a,property:c,clip:l}),s.restore(),s.save(),Vf(s,n,o.bottom)):c==="y"&&(Wf(s,n,o.left),gc(s,{line:e,target:n,color:r,scale:a,property:c,clip:l}),s.restore(),s.save(),Wf(s,n,o.right),h=i)),gc(s,{line:e,target:n,color:h,scale:a,property:c,clip:l}),s.restore()}function Vf(s,t,e){const{segments:n,points:i}=t;let r=!0,o=!1;s.beginPath();for(const a of n){const{start:l,end:c}=a,h=i[l],u=i[gl(l,c,i)];r?(s.moveTo(h.x,h.y),r=!1):(s.lineTo(h.x,e),s.lineTo(h.x,h.y)),o=!!t.pathSegment(s,a,{move:o}),o?s.closePath():s.lineTo(u.x,e)}s.lineTo(t.first().x,e),s.closePath(),s.clip()}function Wf(s,t,e){const{segments:n,points:i}=t;let r=!0,o=!1;s.beginPath();for(const a of n){const{start:l,end:c}=a,h=i[l],u=i[gl(l,c,i)];r?(s.moveTo(h.x,h.y),r=!1):(s.lineTo(e,h.y),s.lineTo(h.x,h.y)),o=!!t.pathSegment(s,a,{move:o}),o?s.closePath():s.lineTo(e,u.y)}s.lineTo(e,t.first().y),s.closePath(),s.clip()}function gc(s,t){const{line:e,target:n,property:i,color:r,scale:o,clip:a}=t,l=LA(e,n,i);for(const{source:c,target:h,start:u,end:d}of l){const{style:{backgroundColor:f=r}={}}=c,p=n!==!0;s.save(),s.fillStyle=f,qA(s,o,a,p&&jc(i,u,d)),s.beginPath();const m=!!e.pathSegment(s,c);let y;if(p){m?s.closePath():Gf(s,n,d,i);const g=!!n.pathSegment(s,h,{move:m,reverse:!0});y=m&&g,y||Gf(s,n,u,i)}s.closePath(),s.fill(y?"evenodd":"nonzero"),s.restore()}}function qA(s,t,e,n){const i=t.chart.chartArea,{property:r,start:o,end:a}=n||{};if(r==="x"||r==="y"){let l,c,h,u;r==="x"?(l=o,c=i.top,h=a,u=i.bottom):(l=i.left,c=o,h=i.right,u=a),s.beginPath(),e&&(l=Math.max(l,e.left),h=Math.min(h,e.right),c=Math.max(c,e.top),u=Math.min(u,e.bottom)),s.rect(l,c,h-l,u-c),s.clip()}}function Gf(s,t,e,n){const i=t.interpolate(e,n);i&&s.lineTo(i.x,i.y)}var YA={id:"filler",afterDatasetsUpdate(s,t,e){const n=(s.data.datasets||[]).length,i=[];let r,o,a,l;for(o=0;o<n;++o)r=s.getDatasetMeta(o),a=r.dataset,l=null,a&&a.options&&a instanceof ml&&(l={visible:s.isDatasetVisible(o),index:o,fill:PA(a,o,n),chart:s,axis:r.controller.options.indexAxis,scale:r.vScale,line:a}),r.$filler=l,i.push(l);for(o=0;o<n;++o)l=i[o],!(!l||l.fill===!1)&&(l.fill=RA(i,o,e.propagate))},beforeDraw(s,t,e){const n=e.drawTime==="beforeDraw",i=s.getSortedVisibleDatasetMetas(),r=s.chartArea;for(let o=i.length-1;o>=0;--o){const a=i[o].$filler;a&&(a.line.updateControlPoints(r,a.axis),n&&a.fill&&mc(s.ctx,a,r))}},beforeDatasetsDraw(s,t,e){if(e.drawTime!=="beforeDatasetsDraw")return;const n=s.getSortedVisibleDatasetMetas();for(let i=n.length-1;i>=0;--i){const r=n[i].$filler;Uf(r)&&mc(s.ctx,r,s.chartArea)}},beforeDatasetDraw(s,t,e){const n=t.meta.$filler;!Uf(n)||e.drawTime!=="beforeDatasetDraw"||mc(s.ctx,n,s.chartArea)},defaults:{propagate:!0,drawTime:"beforeDatasetDraw"}};const Xf=(s,t)=>{let{boxHeight:e=t,boxWidth:n=t}=s;return s.usePointStyle&&(e=Math.min(e,t),n=s.pointStyleWidth||Math.min(n,t)),{boxWidth:n,boxHeight:e,itemHeight:Math.max(t,e)}},jA=(s,t)=>s!==null&&t!==null&&s.datasetIndex===t.datasetIndex&&s.index===t.index;class qf extends Hn{constructor(t){super(),this._added=!1,this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1,this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this.legendItems=void 0,this.columnSizes=void 0,this.lineWidths=void 0,this.maxHeight=void 0,this.maxWidth=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.height=void 0,this.width=void 0,this._margins=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(t,e,n){this.maxWidth=t,this.maxHeight=e,this._margins=n,this.setDimensions(),this.buildLabels(),this.fit()}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=this._margins.left,this.right=this.width):(this.height=this.maxHeight,this.top=this._margins.top,this.bottom=this.height)}buildLabels(){const t=this.options.labels||{};let e=jt(t.generateLabels,[this.chart],this)||[];t.filter&&(e=e.filter(n=>t.filter(n,this.chart.data))),t.sort&&(e=e.sort((n,i)=>t.sort(n,i,this.chart.data))),this.options.reverse&&e.reverse(),this.legendItems=e}fit(){const{options:t,ctx:e}=this;if(!t.display){this.width=this.height=0;return}const n=t.labels,i=de(n.font),r=i.size,o=this._computeTitleHeight(),{boxWidth:a,itemHeight:l}=Xf(n,r);let c,h;e.font=i.string,this.isHorizontal()?(c=this.maxWidth,h=this._fitRows(o,r,a,l)+10):(h=this.maxHeight,c=this._fitCols(o,i,a,l)+10),this.width=Math.min(c,t.maxWidth||this.maxWidth),this.height=Math.min(h,t.maxHeight||this.maxHeight)}_fitRows(t,e,n,i){const{ctx:r,maxWidth:o,options:{labels:{padding:a}}}=this,l=this.legendHitBoxes=[],c=this.lineWidths=[0],h=i+a;let u=t;r.textAlign="left",r.textBaseline="middle";let d=-1,f=-h;return this.legendItems.forEach((p,m)=>{const y=n+e/2+r.measureText(p.text).width;(m===0||c[c.length-1]+y+2*a>o)&&(u+=h,c[c.length-(m>0?0:1)]=0,f+=h,d++),l[m]={left:0,top:f,row:d,width:y,height:i},c[c.length-1]+=y+a}),u}_fitCols(t,e,n,i){const{ctx:r,maxHeight:o,options:{labels:{padding:a}}}=this,l=this.legendHitBoxes=[],c=this.columnSizes=[],h=o-t;let u=a,d=0,f=0,p=0,m=0;return this.legendItems.forEach((y,g)=>{const{itemWidth:x,itemHeight:v}=JA(n,e,r,y,i);g>0&&f+v+2*a>h&&(u+=d+a,c.push({width:d,height:f}),p+=d+a,m++,d=f=0),l[g]={left:p,top:f,col:m,width:x,height:v},d=Math.max(d,x),f+=v+a}),u+=d,c.push({width:d,height:f}),u}adjustHitBoxes(){if(!this.options.display)return;const t=this._computeTitleHeight(),{legendHitBoxes:e,options:{align:n,labels:{padding:i},rtl:r}}=this,o=Os(r,this.left,this.width);if(this.isHorizontal()){let a=0,l=Le(n,this.left+i,this.right-this.lineWidths[a]);for(const c of e)a!==c.row&&(a=c.row,l=Le(n,this.left+i,this.right-this.lineWidths[a])),c.top+=this.top+t+i,c.left=o.leftForLtr(o.x(l),c.width),l+=c.width+i}else{let a=0,l=Le(n,this.top+t+i,this.bottom-this.columnSizes[a].height);for(const c of e)c.col!==a&&(a=c.col,l=Le(n,this.top+t+i,this.bottom-this.columnSizes[a].height)),c.top=l,c.left+=this.left+i,c.left=o.leftForLtr(o.x(c.left),c.width),l+=c.height+i}}isHorizontal(){return this.options.position==="top"||this.options.position==="bottom"}draw(){if(this.options.display){const t=this.ctx;hl(t,this),this._draw(),ul(t)}}_draw(){const{options:t,columnSizes:e,lineWidths:n,ctx:i}=this,{align:r,labels:o}=t,a=te.color,l=Os(t.rtl,this.left,this.width),c=de(o.font),{padding:h}=o,u=c.size,d=u/2;let f;this.drawTitle(),i.textAlign=l.textAlign("left"),i.textBaseline="middle",i.lineWidth=.5,i.font=c.string;const{boxWidth:p,boxHeight:m,itemHeight:y}=Xf(o,u),g=function(w,b,E){if(isNaN(p)||p<=0||isNaN(m)||m<0)return;i.save();const P=Pt(E.lineWidth,1);if(i.fillStyle=Pt(E.fillStyle,a),i.lineCap=Pt(E.lineCap,"butt"),i.lineDashOffset=Pt(E.lineDashOffset,0),i.lineJoin=Pt(E.lineJoin,"miter"),i.lineWidth=P,i.strokeStyle=Pt(E.strokeStyle,a),i.setLineDash(Pt(E.lineDash,[])),o.usePointStyle){const R={radius:m*Math.SQRT2/2,pointStyle:E.pointStyle,rotation:E.rotation,borderWidth:P},C=l.xPlus(w,p/2),U=b+d;gx(i,R,C,U,o.pointStyleWidth&&p)}else{const R=b+Math.max((u-m)/2,0),C=l.leftForLtr(w,p),U=Hi(E.borderRadius);i.beginPath(),Object.values(U).some(k=>k!==0)?so(i,{x:C,y:R,w:p,h:m,radius:U}):i.rect(C,R,p,m),i.fill(),P!==0&&i.stroke()}i.restore()},x=function(w,b,E){Ki(i,E.text,w,b+y/2,c,{strikethrough:E.hidden,textAlign:l.textAlign(E.textAlign)})},v=this.isHorizontal(),_=this._computeTitleHeight();v?f={x:Le(r,this.left+h,this.right-n[0]),y:this.top+h+_,line:0}:f={x:this.left+h,y:Le(r,this.top+_+h,this.bottom-e[0].height),line:0},Sx(this.ctx,t.textDirection);const M=y+h;this.legendItems.forEach((w,b)=>{i.strokeStyle=w.fontColor,i.fillStyle=w.fontColor;const E=i.measureText(w.text).width,P=l.textAlign(w.textAlign||(w.textAlign=o.textAlign)),R=p+d+E;let C=f.x,U=f.y;l.setWidth(this.width),v?b>0&&C+R+h>this.right&&(U=f.y+=M,f.line++,C=f.x=Le(r,this.left+h,this.right-n[f.line])):b>0&&U+M>this.bottom&&(C=f.x=C+e[f.line].width+h,f.line++,U=f.y=Le(r,this.top+_+h,this.bottom-e[f.line].height));const k=l.x(C);if(g(k,U,w),C=x1(P,C+p+d,v?C+R:this.right,t.rtl),x(l.x(C),U,w),v)f.x+=R+h;else if(typeof w.text!="string"){const B=c.lineHeight;f.y+=jx(w,B)+h}else f.y+=M}),Tx(this.ctx,t.textDirection)}drawTitle(){const t=this.options,e=t.title,n=de(e.font),i=De(e.padding);if(!e.display)return;const r=Os(t.rtl,this.left,this.width),o=this.ctx,a=e.position,l=n.size/2,c=i.top+l;let h,u=this.left,d=this.width;if(this.isHorizontal())d=Math.max(...this.lineWidths),h=this.top+c,u=Le(t.align,u,this.right-d);else{const p=this.columnSizes.reduce((m,y)=>Math.max(m,y.height),0);h=c+Le(t.align,this.top,this.bottom-p-t.labels.padding-this._computeTitleHeight())}const f=Le(a,u,u+d);o.textAlign=r.textAlign(iu(a)),o.textBaseline="middle",o.strokeStyle=e.color,o.fillStyle=e.color,o.font=n.string,Ki(o,e.text,f,h,n)}_computeTitleHeight(){const t=this.options.title,e=de(t.font),n=De(t.padding);return t.display?e.lineHeight+n.height:0}_getLegendItemAt(t,e){let n,i,r;if(Pn(t,this.left,this.right)&&Pn(e,this.top,this.bottom)){for(r=this.legendHitBoxes,n=0;n<r.length;++n)if(i=r[n],Pn(t,i.left,i.left+i.width)&&Pn(e,i.top,i.top+i.height))return this.legendItems[n]}return null}handleEvent(t){const e=this.options;if(!KA(t.type,e))return;const n=this._getLegendItemAt(t.x,t.y);if(t.type==="mousemove"||t.type==="mouseout"){const i=this._hoveredItem,r=jA(i,n);i&&!r&&jt(e.onLeave,[t,i,this],this),this._hoveredItem=n,n&&!r&&jt(e.onHover,[t,n,this],this)}else n&&jt(e.onClick,[t,n,this],this)}}function JA(s,t,e,n,i){const r=ZA(n,s,t,e),o=$A(i,n,t.lineHeight);return{itemWidth:r,itemHeight:o}}function ZA(s,t,e,n){let i=s.text;return i&&typeof i!="string"&&(i=i.reduce((r,o)=>r.length>o.length?r:o)),t+e.size/2+n.measureText(i).width}function $A(s,t,e){let n=s;return typeof t.text!="string"&&(n=jx(t,e)),n}function jx(s,t){const e=s.text?s.text.length:0;return t*e}function KA(s,t){return!!((s==="mousemove"||s==="mouseout")&&(t.onHover||t.onLeave)||t.onClick&&(s==="click"||s==="mouseup"))}var QA={id:"legend",_element:qf,start(s,t,e){const n=s.legend=new qf({ctx:s.ctx,options:e,chart:s});je.configure(s,n,e),je.addBox(s,n)},stop(s){je.removeBox(s,s.legend),delete s.legend},beforeUpdate(s,t,e){const n=s.legend;je.configure(s,n,e),n.options=e},afterUpdate(s){const t=s.legend;t.buildLabels(),t.adjustHitBoxes()},afterEvent(s,t){t.replay||s.legend.handleEvent(t.event)},defaults:{display:!0,position:"top",align:"center",fullSize:!0,reverse:!1,weight:1e3,onClick(s,t,e){const n=t.datasetIndex,i=e.chart;i.isDatasetVisible(n)?(i.hide(n),t.hidden=!0):(i.show(n),t.hidden=!1)},onHover:null,onLeave:null,labels:{color:s=>s.chart.options.color,boxWidth:40,padding:10,generateLabels(s){const t=s.data.datasets,{labels:{usePointStyle:e,pointStyle:n,textAlign:i,color:r,useBorderRadius:o,borderRadius:a}}=s.legend.options;return s._getSortedDatasetMetas().map(l=>{const c=l.controller.getStyle(e?0:void 0),h=De(c.borderWidth);return{text:t[l.index].label,fillStyle:c.backgroundColor,fontColor:r,hidden:!l.visible,lineCap:c.borderCapStyle,lineDash:c.borderDash,lineDashOffset:c.borderDashOffset,lineJoin:c.borderJoinStyle,lineWidth:(h.width+h.height)/4,strokeStyle:c.borderColor,pointStyle:n||c.pointStyle,rotation:c.rotation,textAlign:i||c.textAlign,borderRadius:o&&(a||c.borderRadius),datasetIndex:l.index}},this)}},title:{color:s=>s.chart.options.color,display:!1,position:"center",text:""}},descriptors:{_scriptable:s=>!s.startsWith("on"),labels:{_scriptable:s=>!["generateLabels","filter","sort"].includes(s)}}};class Jx extends Hn{constructor(t){super(),this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this._padding=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(t,e){const n=this.options;if(this.left=0,this.top=0,!n.display){this.width=this.height=this.right=this.bottom=0;return}this.width=this.right=t,this.height=this.bottom=e;const i=$t(n.text)?n.text.length:1;this._padding=De(n.padding);const r=i*de(n.font).lineHeight+this._padding.height;this.isHorizontal()?this.height=r:this.width=r}isHorizontal(){const t=this.options.position;return t==="top"||t==="bottom"}_drawArgs(t){const{top:e,left:n,bottom:i,right:r,options:o}=this,a=o.align;let l=0,c,h,u;return this.isHorizontal()?(h=Le(a,n,r),u=e+t,c=r-n):(o.position==="left"?(h=n+t,u=Le(a,i,e),l=Vt*-.5):(h=r-t,u=Le(a,e,i),l=Vt*.5),c=i-e),{titleX:h,titleY:u,maxWidth:c,rotation:l}}draw(){const t=this.ctx,e=this.options;if(!e.display)return;const n=de(e.font),r=n.lineHeight/2+this._padding.top,{titleX:o,titleY:a,maxWidth:l,rotation:c}=this._drawArgs(r);Ki(t,e.text,0,0,n,{color:e.color,maxWidth:l,rotation:c,textAlign:iu(e.align),textBaseline:"middle",translation:[o,a]})}}function t2(s,t){const e=new Jx({ctx:s.ctx,options:t,chart:s});je.configure(s,e,t),je.addBox(s,e),s.titleBlock=e}var e2={id:"title",_element:Jx,start(s,t,e){t2(s,e)},stop(s){const t=s.titleBlock;je.removeBox(s,t),delete s.titleBlock},beforeUpdate(s,t,e){const n=s.titleBlock;je.configure(s,n,e),n.options=e},defaults:{align:"center",display:!1,font:{weight:"bold"},fullSize:!0,padding:10,position:"top",text:"",weight:2e3},defaultRoutes:{color:"color"},descriptors:{_scriptable:!0,_indexable:!1}};const Lr={average(s){if(!s.length)return!1;let t,e,n=new Set,i=0,r=0;for(t=0,e=s.length;t<e;++t){const a=s[t].element;if(a&&a.hasValue()){const l=a.tooltipPosition();n.add(l.x),i+=l.y,++r}}return r===0||n.size===0?!1:{x:[...n].reduce((a,l)=>a+l)/n.size,y:i/r}},nearest(s,t){if(!s.length)return!1;let e=t.x,n=t.y,i=Number.POSITIVE_INFINITY,r,o,a;for(r=0,o=s.length;r<o;++r){const l=s[r].element;if(l&&l.hasValue()){const c=l.getCenterPoint(),h=Vc(t,c);h<i&&(i=h,a=l)}}if(a){const l=a.tooltipPosition();e=l.x,n=l.y}return{x:e,y:n}}};function hn(s,t){return t&&($t(t)?Array.prototype.push.apply(s,t):s.push(t)),s}function An(s){return(typeof s=="string"||s instanceof String)&&s.indexOf(`
`)>-1?s.split(`
`):s}function n2(s,t){const{element:e,datasetIndex:n,index:i}=t,r=s.getDatasetMeta(n).controller,{label:o,value:a}=r.getLabelAndValue(i);return{chart:s,label:o,parsed:r.getParsed(i),raw:s.data.datasets[n].data[i],formattedValue:a,dataset:r.getDataset(),dataIndex:i,datasetIndex:n,element:e}}function Yf(s,t){const e=s.chart.ctx,{body:n,footer:i,title:r}=s,{boxWidth:o,boxHeight:a}=t,l=de(t.bodyFont),c=de(t.titleFont),h=de(t.footerFont),u=r.length,d=i.length,f=n.length,p=De(t.padding);let m=p.height,y=0,g=n.reduce((_,M)=>_+M.before.length+M.lines.length+M.after.length,0);if(g+=s.beforeBody.length+s.afterBody.length,u&&(m+=u*c.lineHeight+(u-1)*t.titleSpacing+t.titleMarginBottom),g){const _=t.displayColors?Math.max(a,l.lineHeight):l.lineHeight;m+=f*_+(g-f)*l.lineHeight+(g-1)*t.bodySpacing}d&&(m+=t.footerMarginTop+d*h.lineHeight+(d-1)*t.footerSpacing);let x=0;const v=function(_){y=Math.max(y,e.measureText(_).width+x)};return e.save(),e.font=c.string,Gt(s.title,v),e.font=l.string,Gt(s.beforeBody.concat(s.afterBody),v),x=t.displayColors?o+2+t.boxPadding:0,Gt(n,_=>{Gt(_.before,v),Gt(_.lines,v),Gt(_.after,v)}),x=0,e.font=h.string,Gt(s.footer,v),e.restore(),y+=p.width,{width:y,height:m}}function i2(s,t){const{y:e,height:n}=t;return e<n/2?"top":e>s.height-n/2?"bottom":"center"}function s2(s,t,e,n){const{x:i,width:r}=n,o=e.caretSize+e.caretPadding;if(s==="left"&&i+r+o>t.width||s==="right"&&i-r-o<0)return!0}function r2(s,t,e,n){const{x:i,width:r}=e,{width:o,chartArea:{left:a,right:l}}=s;let c="center";return n==="center"?c=i<=(a+l)/2?"left":"right":i<=r/2?c="left":i>=o-r/2&&(c="right"),s2(c,s,t,e)&&(c="center"),c}function jf(s,t,e){const n=e.yAlign||t.yAlign||i2(s,e);return{xAlign:e.xAlign||t.xAlign||r2(s,t,e,n),yAlign:n}}function o2(s,t){let{x:e,width:n}=s;return t==="right"?e-=n:t==="center"&&(e-=n/2),e}function a2(s,t,e){let{y:n,height:i}=s;return t==="top"?n+=e:t==="bottom"?n-=i+e:n-=i/2,n}function Jf(s,t,e,n){const{caretSize:i,caretPadding:r,cornerRadius:o}=s,{xAlign:a,yAlign:l}=e,c=i+r,{topLeft:h,topRight:u,bottomLeft:d,bottomRight:f}=Hi(o);let p=o2(t,a);const m=a2(t,l,c);return l==="center"?a==="left"?p+=c:a==="right"&&(p-=c):a==="left"?p-=Math.max(h,d)+i:a==="right"&&(p+=Math.max(u,f)+i),{x:Re(p,0,n.width-t.width),y:Re(m,0,n.height-t.height)}}function ba(s,t,e){const n=De(e.padding);return t==="center"?s.x+s.width/2:t==="right"?s.x+s.width-n.right:s.x+n.left}function Zf(s){return hn([],An(s))}function l2(s,t,e){return mi(s,{tooltip:t,tooltipItems:e,type:"tooltip"})}function $f(s,t){const e=t&&t.dataset&&t.dataset.tooltip&&t.dataset.tooltip.callbacks;return e?s.override(e):s}const Zx={beforeTitle:Tn,title(s){if(s.length>0){const t=s[0],e=t.chart.data.labels,n=e?e.length:0;if(this&&this.options&&this.options.mode==="dataset")return t.dataset.label||"";if(t.label)return t.label;if(n>0&&t.dataIndex<n)return e[t.dataIndex]}return""},afterTitle:Tn,beforeBody:Tn,beforeLabel:Tn,label(s){if(this&&this.options&&this.options.mode==="dataset")return s.label+": "+s.formattedValue||s.formattedValue;let t=s.dataset.label||"";t&&(t+=": ");const e=s.formattedValue;return zt(e)||(t+=e),t},labelColor(s){const e=s.chart.getDatasetMeta(s.datasetIndex).controller.getStyle(s.dataIndex);return{borderColor:e.borderColor,backgroundColor:e.backgroundColor,borderWidth:e.borderWidth,borderDash:e.borderDash,borderDashOffset:e.borderDashOffset,borderRadius:0}},labelTextColor(){return this.options.bodyColor},labelPointStyle(s){const e=s.chart.getDatasetMeta(s.datasetIndex).controller.getStyle(s.dataIndex);return{pointStyle:e.pointStyle,rotation:e.rotation}},afterLabel:Tn,afterBody:Tn,beforeFooter:Tn,footer:Tn,afterFooter:Tn};function Oe(s,t,e,n){const i=s[t].call(e,n);return typeof i>"u"?Zx[t].call(e,n):i}class Kf extends Hn{static positioners=Lr;constructor(t){super(),this.opacity=0,this._active=[],this._eventPosition=void 0,this._size=void 0,this._cachedAnimations=void 0,this._tooltipItems=[],this.$animations=void 0,this.$context=void 0,this.chart=t.chart,this.options=t.options,this.dataPoints=void 0,this.title=void 0,this.beforeBody=void 0,this.body=void 0,this.afterBody=void 0,this.footer=void 0,this.xAlign=void 0,this.yAlign=void 0,this.x=void 0,this.y=void 0,this.height=void 0,this.width=void 0,this.caretX=void 0,this.caretY=void 0,this.labelColors=void 0,this.labelPointStyles=void 0,this.labelTextColors=void 0}initialize(t){this.options=t,this._cachedAnimations=void 0,this.$context=void 0}_resolveAnimations(){const t=this._cachedAnimations;if(t)return t;const e=this.chart,n=this.options.setContext(this.getContext()),i=n.enabled&&e.options.animation&&n.animations,r=new Rx(this.chart,i);return i._cacheable&&(this._cachedAnimations=Object.freeze(r)),r}getContext(){return this.$context||(this.$context=l2(this.chart.getContext(),this,this._tooltipItems))}getTitle(t,e){const{callbacks:n}=e,i=Oe(n,"beforeTitle",this,t),r=Oe(n,"title",this,t),o=Oe(n,"afterTitle",this,t);let a=[];return a=hn(a,An(i)),a=hn(a,An(r)),a=hn(a,An(o)),a}getBeforeBody(t,e){return Zf(Oe(e.callbacks,"beforeBody",this,t))}getBody(t,e){const{callbacks:n}=e,i=[];return Gt(t,r=>{const o={before:[],lines:[],after:[]},a=$f(n,r);hn(o.before,An(Oe(a,"beforeLabel",this,r))),hn(o.lines,Oe(a,"label",this,r)),hn(o.after,An(Oe(a,"afterLabel",this,r))),i.push(o)}),i}getAfterBody(t,e){return Zf(Oe(e.callbacks,"afterBody",this,t))}getFooter(t,e){const{callbacks:n}=e,i=Oe(n,"beforeFooter",this,t),r=Oe(n,"footer",this,t),o=Oe(n,"afterFooter",this,t);let a=[];return a=hn(a,An(i)),a=hn(a,An(r)),a=hn(a,An(o)),a}_createItems(t){const e=this._active,n=this.chart.data,i=[],r=[],o=[];let a=[],l,c;for(l=0,c=e.length;l<c;++l)a.push(n2(this.chart,e[l]));return t.filter&&(a=a.filter((h,u,d)=>t.filter(h,u,d,n))),t.itemSort&&(a=a.sort((h,u)=>t.itemSort(h,u,n))),Gt(a,h=>{const u=$f(t.callbacks,h);i.push(Oe(u,"labelColor",this,h)),r.push(Oe(u,"labelPointStyle",this,h)),o.push(Oe(u,"labelTextColor",this,h))}),this.labelColors=i,this.labelPointStyles=r,this.labelTextColors=o,this.dataPoints=a,a}update(t,e){const n=this.options.setContext(this.getContext()),i=this._active;let r,o=[];if(!i.length)this.opacity!==0&&(r={opacity:0});else{const a=Lr[n.position].call(this,i,this._eventPosition);o=this._createItems(n),this.title=this.getTitle(o,n),this.beforeBody=this.getBeforeBody(o,n),this.body=this.getBody(o,n),this.afterBody=this.getAfterBody(o,n),this.footer=this.getFooter(o,n);const l=this._size=Yf(this,n),c=Object.assign({},a,l),h=jf(this.chart,n,c),u=Jf(n,c,h,this.chart);this.xAlign=h.xAlign,this.yAlign=h.yAlign,r={opacity:1,x:u.x,y:u.y,width:l.width,height:l.height,caretX:a.x,caretY:a.y}}this._tooltipItems=o,this.$context=void 0,r&&this._resolveAnimations().update(this,r),t&&n.external&&n.external.call(this,{chart:this.chart,tooltip:this,replay:e})}drawCaret(t,e,n,i){const r=this.getCaretPosition(t,n,i);e.lineTo(r.x1,r.y1),e.lineTo(r.x2,r.y2),e.lineTo(r.x3,r.y3)}getCaretPosition(t,e,n){const{xAlign:i,yAlign:r}=this,{caretSize:o,cornerRadius:a}=n,{topLeft:l,topRight:c,bottomLeft:h,bottomRight:u}=Hi(a),{x:d,y:f}=t,{width:p,height:m}=e;let y,g,x,v,_,M;return r==="center"?(_=f+m/2,i==="left"?(y=d,g=y-o,v=_+o,M=_-o):(y=d+p,g=y+o,v=_-o,M=_+o),x=y):(i==="left"?g=d+Math.max(l,h)+o:i==="right"?g=d+p-Math.max(c,u)-o:g=this.caretX,r==="top"?(v=f,_=v-o,y=g-o,x=g+o):(v=f+m,_=v+o,y=g+o,x=g-o),M=v),{x1:y,x2:g,x3:x,y1:v,y2:_,y3:M}}drawTitle(t,e,n){const i=this.title,r=i.length;let o,a,l;if(r){const c=Os(n.rtl,this.x,this.width);for(t.x=ba(this,n.titleAlign,n),e.textAlign=c.textAlign(n.titleAlign),e.textBaseline="middle",o=de(n.titleFont),a=n.titleSpacing,e.fillStyle=n.titleColor,e.font=o.string,l=0;l<r;++l)e.fillText(i[l],c.x(t.x),t.y+o.lineHeight/2),t.y+=o.lineHeight+a,l+1===r&&(t.y+=n.titleMarginBottom-a)}}_drawColorBox(t,e,n,i,r){const o=this.labelColors[n],a=this.labelPointStyles[n],{boxHeight:l,boxWidth:c}=r,h=de(r.bodyFont),u=ba(this,"left",r),d=i.x(u),f=l<h.lineHeight?(h.lineHeight-l)/2:0,p=e.y+f;if(r.usePointStyle){const m={radius:Math.min(c,l)/2,pointStyle:a.pointStyle,rotation:a.rotation,borderWidth:1},y=i.leftForLtr(d,c)+c/2,g=p+l/2;t.strokeStyle=r.multiKeyBackground,t.fillStyle=r.multiKeyBackground,Gc(t,m,y,g),t.strokeStyle=o.borderColor,t.fillStyle=o.backgroundColor,Gc(t,m,y,g)}else{t.lineWidth=kt(o.borderWidth)?Math.max(...Object.values(o.borderWidth)):o.borderWidth||1,t.strokeStyle=o.borderColor,t.setLineDash(o.borderDash||[]),t.lineDashOffset=o.borderDashOffset||0;const m=i.leftForLtr(d,c),y=i.leftForLtr(i.xPlus(d,1),c-2),g=Hi(o.borderRadius);Object.values(g).some(x=>x!==0)?(t.beginPath(),t.fillStyle=r.multiKeyBackground,so(t,{x:m,y:p,w:c,h:l,radius:g}),t.fill(),t.stroke(),t.fillStyle=o.backgroundColor,t.beginPath(),so(t,{x:y,y:p+1,w:c-2,h:l-2,radius:g}),t.fill()):(t.fillStyle=r.multiKeyBackground,t.fillRect(m,p,c,l),t.strokeRect(m,p,c,l),t.fillStyle=o.backgroundColor,t.fillRect(y,p+1,c-2,l-2))}t.fillStyle=this.labelTextColors[n]}drawBody(t,e,n){const{body:i}=this,{bodySpacing:r,bodyAlign:o,displayColors:a,boxHeight:l,boxWidth:c,boxPadding:h}=n,u=de(n.bodyFont);let d=u.lineHeight,f=0;const p=Os(n.rtl,this.x,this.width),m=function(E){e.fillText(E,p.x(t.x+f),t.y+d/2),t.y+=d+r},y=p.textAlign(o);let g,x,v,_,M,w,b;for(e.textAlign=o,e.textBaseline="middle",e.font=u.string,t.x=ba(this,y,n),e.fillStyle=n.bodyColor,Gt(this.beforeBody,m),f=a&&y!=="right"?o==="center"?c/2+h:c+2+h:0,_=0,w=i.length;_<w;++_){for(g=i[_],x=this.labelTextColors[_],e.fillStyle=x,Gt(g.before,m),v=g.lines,a&&v.length&&(this._drawColorBox(e,t,_,p,n),d=Math.max(u.lineHeight,l)),M=0,b=v.length;M<b;++M)m(v[M]),d=u.lineHeight;Gt(g.after,m)}f=0,d=u.lineHeight,Gt(this.afterBody,m),t.y-=r}drawFooter(t,e,n){const i=this.footer,r=i.length;let o,a;if(r){const l=Os(n.rtl,this.x,this.width);for(t.x=ba(this,n.footerAlign,n),t.y+=n.footerMarginTop,e.textAlign=l.textAlign(n.footerAlign),e.textBaseline="middle",o=de(n.footerFont),e.fillStyle=n.footerColor,e.font=o.string,a=0;a<r;++a)e.fillText(i[a],l.x(t.x),t.y+o.lineHeight/2),t.y+=o.lineHeight+n.footerSpacing}}drawBackground(t,e,n,i){const{xAlign:r,yAlign:o}=this,{x:a,y:l}=t,{width:c,height:h}=n,{topLeft:u,topRight:d,bottomLeft:f,bottomRight:p}=Hi(i.cornerRadius);e.fillStyle=i.backgroundColor,e.strokeStyle=i.borderColor,e.lineWidth=i.borderWidth,e.beginPath(),e.moveTo(a+u,l),o==="top"&&this.drawCaret(t,e,n,i),e.lineTo(a+c-d,l),e.quadraticCurveTo(a+c,l,a+c,l+d),o==="center"&&r==="right"&&this.drawCaret(t,e,n,i),e.lineTo(a+c,l+h-p),e.quadraticCurveTo(a+c,l+h,a+c-p,l+h),o==="bottom"&&this.drawCaret(t,e,n,i),e.lineTo(a+f,l+h),e.quadraticCurveTo(a,l+h,a,l+h-f),o==="center"&&r==="left"&&this.drawCaret(t,e,n,i),e.lineTo(a,l+u),e.quadraticCurveTo(a,l,a+u,l),e.closePath(),e.fill(),i.borderWidth>0&&e.stroke()}_updateAnimationTarget(t){const e=this.chart,n=this.$animations,i=n&&n.x,r=n&&n.y;if(i||r){const o=Lr[t.position].call(this,this._active,this._eventPosition);if(!o)return;const a=this._size=Yf(this,t),l=Object.assign({},o,this._size),c=jf(e,t,l),h=Jf(t,l,c,e);(i._to!==h.x||r._to!==h.y)&&(this.xAlign=c.xAlign,this.yAlign=c.yAlign,this.width=a.width,this.height=a.height,this.caretX=o.x,this.caretY=o.y,this._resolveAnimations().update(this,h))}}_willRender(){return!!this.opacity}draw(t){const e=this.options.setContext(this.getContext());let n=this.opacity;if(!n)return;this._updateAnimationTarget(e);const i={width:this.width,height:this.height},r={x:this.x,y:this.y};n=Math.abs(n)<.001?0:n;const o=De(e.padding),a=this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length;e.enabled&&a&&(t.save(),t.globalAlpha=n,this.drawBackground(r,t,i,e),Sx(t,e.textDirection),r.y+=o.top,this.drawTitle(r,t,e),this.drawBody(r,t,e),this.drawFooter(r,t,e),Tx(t,e.textDirection),t.restore())}getActiveElements(){return this._active||[]}setActiveElements(t,e){const n=this._active,i=t.map(({datasetIndex:a,index:l})=>{const c=this.chart.getDatasetMeta(a);if(!c)throw new Error("Cannot find a dataset at index "+a);return{datasetIndex:a,element:c.data[l],index:l}}),r=!Ia(n,i),o=this._positionChanged(i,e);(r||o)&&(this._active=i,this._eventPosition=e,this._ignoreReplayEvents=!0,this.update(!0))}handleEvent(t,e,n=!0){if(e&&this._ignoreReplayEvents)return!1;this._ignoreReplayEvents=!1;const i=this.options,r=this._active||[],o=this._getActiveElements(t,r,e,n),a=this._positionChanged(o,t),l=e||!Ia(o,r)||a;return l&&(this._active=o,(i.enabled||i.external)&&(this._eventPosition={x:t.x,y:t.y},this.update(!0,e))),l}_getActiveElements(t,e,n,i){const r=this.options;if(t.type==="mouseout")return[];if(!i)return e.filter(a=>this.chart.data.datasets[a.datasetIndex]&&this.chart.getDatasetMeta(a.datasetIndex).controller.getParsed(a.index)!==void 0);const o=this.chart.getElementsAtEventForMode(t,r.mode,r,n);return r.reverse&&o.reverse(),o}_positionChanged(t,e){const{caretX:n,caretY:i,options:r}=this,o=Lr[r.position].call(this,t,e);return o!==!1&&(n!==o.x||i!==o.y)}}var c2={id:"tooltip",_element:Kf,positioners:Lr,afterInit(s,t,e){e&&(s.tooltip=new Kf({chart:s,options:e}))},beforeUpdate(s,t,e){s.tooltip&&s.tooltip.initialize(e)},reset(s,t,e){s.tooltip&&s.tooltip.initialize(e)},afterDraw(s){const t=s.tooltip;if(t&&t._willRender()){const e={tooltip:t};if(s.notifyPlugins("beforeTooltipDraw",{...e,cancelable:!0})===!1)return;t.draw(s.ctx),s.notifyPlugins("afterTooltipDraw",e)}},afterEvent(s,t){if(s.tooltip){const e=t.replay;s.tooltip.handleEvent(t.event,e,t.inChartArea)&&(t.changed=!0)}},defaults:{enabled:!0,external:null,position:"average",backgroundColor:"rgba(0,0,0,0.8)",titleColor:"#fff",titleFont:{weight:"bold"},titleSpacing:2,titleMarginBottom:6,titleAlign:"left",bodyColor:"#fff",bodySpacing:2,bodyFont:{},bodyAlign:"left",footerColor:"#fff",footerSpacing:2,footerMarginTop:6,footerFont:{weight:"bold"},footerAlign:"left",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:(s,t)=>t.bodyFont.size,boxWidth:(s,t)=>t.bodyFont.size,multiKeyBackground:"#fff",displayColors:!0,boxPadding:0,borderColor:"rgba(0,0,0,0)",borderWidth:0,animation:{duration:400,easing:"easeOutQuart"},animations:{numbers:{type:"number",properties:["x","y","width","height","caretX","caretY"]},opacity:{easing:"linear",duration:200}},callbacks:Zx},defaultRoutes:{bodyFont:"font",footerFont:"font",titleFont:"font"},descriptors:{_scriptable:s=>s!=="filter"&&s!=="itemSort"&&s!=="external",_indexable:!1,callbacks:{_scriptable:!1,_indexable:!1},animation:{_fallback:!1},animations:{_fallback:"animation"}},additionalOptionScopes:["interaction"]};const h2=(s,t,e,n)=>(typeof t=="string"?(e=s.push(t)-1,n.unshift({index:e,label:t})):isNaN(t)&&(e=null),e);function u2(s,t,e,n){const i=s.indexOf(t);if(i===-1)return h2(s,t,e,n);const r=s.lastIndexOf(t);return i!==r?e:i}const d2=(s,t)=>s===null?null:Re(Math.round(s),0,t);function Qf(s){const t=this.getLabels();return s>=0&&s<t.length?t[s]:s}class f2 extends cr{static id="category";static defaults={ticks:{callback:Qf}};constructor(t){super(t),this._startValue=void 0,this._valueRange=0,this._addedLabels=[]}init(t){const e=this._addedLabels;if(e.length){const n=this.getLabels();for(const{index:i,label:r}of e)n[i]===r&&n.splice(i,1);this._addedLabels=[]}super.init(t)}parse(t,e){if(zt(t))return null;const n=this.getLabels();return e=isFinite(e)&&n[e]===t?e:u2(n,t,Pt(e,t),this._addedLabels),d2(e,n.length-1)}determineDataLimits(){const{minDefined:t,maxDefined:e}=this.getUserBounds();let{min:n,max:i}=this.getMinMax(!0);this.options.bounds==="ticks"&&(t||(n=0),e||(i=this.getLabels().length-1)),this.min=n,this.max=i}buildTicks(){const t=this.min,e=this.max,n=this.options.offset,i=[];let r=this.getLabels();r=t===0&&e===r.length-1?r:r.slice(t,e+1),this._valueRange=Math.max(r.length-(n?0:1),1),this._startValue=this.min-(n?.5:0);for(let o=t;o<=e;o++)i.push({value:o});return i}getLabelForValue(t){return Qf.call(this,t)}configure(){super.configure(),this.isHorizontal()||(this._reversePixels=!this._reversePixels)}getPixelForValue(t){return typeof t!="number"&&(t=this.parse(t)),t===null?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getValueForPixel(t){return Math.round(this._startValue+this.getDecimalForPixel(t)*this._valueRange)}getBasePixel(){return this.bottom}}function p2(s,t){const e=[],{bounds:i,step:r,min:o,max:a,precision:l,count:c,maxTicks:h,maxDigits:u,includeBounds:d}=s,f=r||1,p=h-1,{min:m,max:y}=t,g=!zt(o),x=!zt(a),v=!zt(c),_=(y-m)/(u+1);let M=Jd((y-m)/p/f)*f,w,b,E,P;if(M<1e-14&&!g&&!x)return[{value:m},{value:y}];P=Math.ceil(y/M)-Math.floor(m/M),P>p&&(M=Jd(P*M/p/f)*f),zt(l)||(w=Math.pow(10,l),M=Math.ceil(M*w)/w),i==="ticks"?(b=Math.floor(m/M)*M,E=Math.ceil(y/M)*M):(b=m,E=y),g&&x&&r&&c1((a-o)/r,M/1e3)?(P=Math.round(Math.min((a-o)/M,h)),M=(a-o)/P,b=o,E=a):v?(b=g?o:b,E=x?a:E,P=c-1,M=(E-b)/P):(P=(E-b)/M,Fr(P,Math.round(P),M/1e3)?P=Math.round(P):P=Math.ceil(P));const R=Math.max(Zd(M),Zd(b));w=Math.pow(10,zt(l)?R:l),b=Math.round(b*w)/w,E=Math.round(E*w)/w;let C=0;for(g&&(d&&b!==o?(e.push({value:o}),b<o&&C++,Fr(Math.round((b+C*M)*w)/w,o,tp(o,_,s))&&C++):b<o&&C++);C<P;++C){const U=Math.round((b+C*M)*w)/w;if(x&&U>a)break;e.push({value:U})}return x&&d&&E!==a?e.length&&Fr(e[e.length-1].value,a,tp(a,_,s))?e[e.length-1].value=a:e.push({value:a}):(!x||E===a)&&e.push({value:E}),e}function tp(s,t,{horizontal:e,minRotation:n}){const i=en(n),r=(e?Math.sin(i):Math.cos(i))||.001,o=.75*t*(""+s).length;return Math.min(t/r,o)}class Jc extends cr{constructor(t){super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._endValue=void 0,this._valueRange=0}parse(t,e){return zt(t)||(typeof t=="number"||t instanceof Number)&&!isFinite(+t)?null:+t}handleTickRangeOptions(){const{beginAtZero:t}=this.options,{minDefined:e,maxDefined:n}=this.getUserBounds();let{min:i,max:r}=this;const o=l=>i=e?i:l,a=l=>r=n?r:l;if(t){const l=gn(i),c=gn(r);l<0&&c<0?a(0):l>0&&c>0&&o(0)}if(i===r){let l=r===0?1:Math.abs(r*.05);a(r+l),t||o(i-l)}this.min=i,this.max=r}getTickLimit(){const t=this.options.ticks;let{maxTicksLimit:e,stepSize:n}=t,i;return n?(i=Math.ceil(this.max/n)-Math.floor(this.min/n)+1,i>1e3&&(console.warn(`scales.${this.id}.ticks.stepSize: ${n} would result generating up to ${i} ticks. Limiting to 1000.`),i=1e3)):(i=this.computeTickLimit(),e=e||11),e&&(i=Math.min(e,i)),i}computeTickLimit(){return Number.POSITIVE_INFINITY}buildTicks(){const t=this.options,e=t.ticks;let n=this.getTickLimit();n=Math.max(2,n);const i={maxTicks:n,bounds:t.bounds,min:t.min,max:t.max,precision:e.precision,step:e.stepSize,count:e.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:e.minRotation||0,includeBounds:e.includeBounds!==!1},r=this._range||this,o=p2(i,r);return t.bounds==="ticks"&&h1(o,this,"value"),t.reverse?(o.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),o}configure(){const t=this.ticks;let e=this.min,n=this.max;if(super.configure(),this.options.offset&&t.length){const i=(n-e)/Math.max(t.length-1,1)/2;e-=i,n+=i}this._startValue=e,this._endValue=n,this._valueRange=n-e}getLabelForValue(t){return cl(t,this.chart.options.locale,this.options.ticks.format)}}class m2 extends Jc{static id="linear";static defaults={ticks:{callback:ru.formatters.numeric}};determineDataLimits(){const{min:t,max:e}=this.getMinMax(!0);this.min=xe(t)?t:0,this.max=xe(e)?e:1,this.handleTickRangeOptions()}computeTickLimit(){const t=this.isHorizontal(),e=t?this.width:this.height,n=en(this.options.ticks.minRotation),i=(t?Math.sin(n):Math.cos(n))||.001,r=this._resolveTickFontOptions(0);return Math.ceil(e/Math.min(40,r.lineHeight/i))}getPixelForValue(t){return t===null?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getValueForPixel(t){return this._startValue+this.getDecimalForPixel(t)*this._valueRange}}function Zc(s){const t=s.ticks;if(t.display&&s.display){const e=De(t.backdropPadding);return Pt(t.font&&t.font.size,te.font.size)+e.height}return 0}function g2(s,t,e){return e=$t(e)?e:[e],{w:L1(s,t.string,e),h:e.length*t.lineHeight}}function ep(s,t,e,n,i){return s===n||s===i?{start:t-e/2,end:t+e/2}:s<n||s>i?{start:t-e,end:t}:{start:t,end:t+e}}function x2(s){const t={l:s.left+s._padding.left,r:s.right-s._padding.right,t:s.top+s._padding.top,b:s.bottom-s._padding.bottom},e=Object.assign({},t),n=[],i=[],r=s._pointLabels.length,o=s.options.pointLabels,a=o.centerPointLabels?Vt/r:0;for(let l=0;l<r;l++){const c=o.setContext(s.getPointLabelContext(l));i[l]=c.padding;const h=s.getPointPosition(l,s.drawingArea+i[l],a),u=de(c.font),d=g2(s.ctx,u,s._pointLabels[l]);n[l]=d;const f=Ce(s.getIndexAngle(l)+a),p=Math.round(eu(f)),m=ep(p,h.x,d.w,0,180),y=ep(p,h.y,d.h,90,270);y2(e,t,f,m,y)}s.setCenterPoint(t.l-e.l,e.r-t.r,t.t-e.t,e.b-t.b),s._pointLabelItems=b2(s,n,i)}function y2(s,t,e,n,i){const r=Math.abs(Math.sin(e)),o=Math.abs(Math.cos(e));let a=0,l=0;n.start<t.l?(a=(t.l-n.start)/r,s.l=Math.min(s.l,t.l-a)):n.end>t.r&&(a=(n.end-t.r)/r,s.r=Math.max(s.r,t.r+a)),i.start<t.t?(l=(t.t-i.start)/o,s.t=Math.min(s.t,t.t-l)):i.end>t.b&&(l=(i.end-t.b)/o,s.b=Math.max(s.b,t.b+l))}function _2(s,t,e){const n=s.drawingArea,{extra:i,additionalAngle:r,padding:o,size:a}=e,l=s.getPointPosition(t,n+i+o,r),c=Math.round(eu(Ce(l.angle+oe))),h=S2(l.y,a.h,c),u=M2(c),d=w2(l.x,a.w,u);return{visible:!0,x:l.x,y:h,textAlign:u,left:d,top:h,right:d+a.w,bottom:h+a.h}}function v2(s,t){if(!t)return!0;const{left:e,top:n,right:i,bottom:r}=s;return!(Dn({x:e,y:n},t)||Dn({x:e,y:r},t)||Dn({x:i,y:n},t)||Dn({x:i,y:r},t))}function b2(s,t,e){const n=[],i=s._pointLabels.length,r=s.options,{centerPointLabels:o,display:a}=r.pointLabels,l={extra:Zc(r)/2,additionalAngle:o?Vt/i:0};let c;for(let h=0;h<i;h++){l.padding=e[h],l.size=t[h];const u=_2(s,h,l);n.push(u),a==="auto"&&(u.visible=v2(u,c),u.visible&&(c=u))}return n}function M2(s){return s===0||s===180?"center":s<180?"left":"right"}function w2(s,t,e){return e==="right"?s-=t:e==="center"&&(s-=t/2),s}function S2(s,t,e){return e===90||e===270?s-=t/2:(e>270||e<90)&&(s-=t),s}function T2(s,t,e){const{left:n,top:i,right:r,bottom:o}=e,{backdropColor:a}=t;if(!zt(a)){const l=Hi(t.borderRadius),c=De(t.backdropPadding);s.fillStyle=a;const h=n-c.left,u=i-c.top,d=r-n+c.width,f=o-i+c.height;Object.values(l).some(p=>p!==0)?(s.beginPath(),so(s,{x:h,y:u,w:d,h:f,radius:l}),s.fill()):s.fillRect(h,u,d,f)}}function E2(s,t){const{ctx:e,options:{pointLabels:n}}=s;for(let i=t-1;i>=0;i--){const r=s._pointLabelItems[i];if(!r.visible)continue;const o=n.setContext(s.getPointLabelContext(i));T2(e,o,r);const a=de(o.font),{x:l,y:c,textAlign:h}=r;Ki(e,s._pointLabels[i],l,c+a.lineHeight/2,a,{color:o.color,textAlign:h,textBaseline:"middle"})}}function $x(s,t,e,n){const{ctx:i}=s;if(e)i.arc(s.xCenter,s.yCenter,t,0,Zt);else{let r=s.getPointPosition(0,t);i.moveTo(r.x,r.y);for(let o=1;o<n;o++)r=s.getPointPosition(o,t),i.lineTo(r.x,r.y)}}function A2(s,t,e,n,i){const r=s.ctx,o=t.circular,{color:a,lineWidth:l}=t;!o&&!n||!a||!l||e<0||(r.save(),r.strokeStyle=a,r.lineWidth=l,r.setLineDash(i.dash||[]),r.lineDashOffset=i.dashOffset,r.beginPath(),$x(s,e,o,n),r.closePath(),r.stroke(),r.restore())}function L2(s,t,e){return mi(s,{label:e,index:t,type:"pointLabel"})}class C2 extends Jc{static id="radialLinear";static defaults={display:!0,animate:!0,position:"chartArea",angleLines:{display:!0,lineWidth:1,borderDash:[],borderDashOffset:0},grid:{circular:!1},startAngle:0,ticks:{showLabelBackdrop:!0,callback:ru.formatters.numeric},pointLabels:{backdropColor:void 0,backdropPadding:2,display:!0,font:{size:10},callback(t){return t},padding:5,centerPointLabels:!1}};static defaultRoutes={"angleLines.color":"borderColor","pointLabels.color":"color","ticks.color":"color"};static descriptors={angleLines:{_fallback:"grid"}};constructor(t){super(t),this.xCenter=void 0,this.yCenter=void 0,this.drawingArea=void 0,this._pointLabels=[],this._pointLabelItems=[]}setDimensions(){const t=this._padding=De(Zc(this.options)/2),e=this.width=this.maxWidth-t.width,n=this.height=this.maxHeight-t.height;this.xCenter=Math.floor(this.left+e/2+t.left),this.yCenter=Math.floor(this.top+n/2+t.top),this.drawingArea=Math.floor(Math.min(e,n)/2)}determineDataLimits(){const{min:t,max:e}=this.getMinMax(!1);this.min=xe(t)&&!isNaN(t)?t:0,this.max=xe(e)&&!isNaN(e)?e:0,this.handleTickRangeOptions()}computeTickLimit(){return Math.ceil(this.drawingArea/Zc(this.options))}generateTickLabels(t){Jc.prototype.generateTickLabels.call(this,t),this._pointLabels=this.getLabels().map((e,n)=>{const i=jt(this.options.pointLabels.callback,[e,n],this);return i||i===0?i:""}).filter((e,n)=>this.chart.getDataVisibility(n))}fit(){const t=this.options;t.display&&t.pointLabels.display?x2(this):this.setCenterPoint(0,0,0,0)}setCenterPoint(t,e,n,i){this.xCenter+=Math.floor((t-e)/2),this.yCenter+=Math.floor((n-i)/2),this.drawingArea-=Math.min(this.drawingArea/2,Math.max(t,e,n,i))}getIndexAngle(t){const e=Zt/(this._pointLabels.length||1),n=this.options.startAngle||0;return Ce(t*e+en(n))}getDistanceFromCenterForValue(t){if(zt(t))return NaN;const e=this.drawingArea/(this.max-this.min);return this.options.reverse?(this.max-t)*e:(t-this.min)*e}getValueForDistanceFromCenter(t){if(zt(t))return NaN;const e=t/(this.drawingArea/(this.max-this.min));return this.options.reverse?this.max-e:this.min+e}getPointLabelContext(t){const e=this._pointLabels||[];if(t>=0&&t<e.length){const n=e[t];return L2(this.getContext(),t,n)}}getPointPosition(t,e,n=0){const i=this.getIndexAngle(t)-oe+n;return{x:Math.cos(i)*e+this.xCenter,y:Math.sin(i)*e+this.yCenter,angle:i}}getPointPositionForValue(t,e){return this.getPointPosition(t,this.getDistanceFromCenterForValue(e))}getBasePosition(t){return this.getPointPositionForValue(t||0,this.getBaseValue())}getPointLabelPosition(t){const{left:e,top:n,right:i,bottom:r}=this._pointLabelItems[t];return{left:e,top:n,right:i,bottom:r}}drawBackground(){const{backgroundColor:t,grid:{circular:e}}=this.options;if(t){const n=this.ctx;n.save(),n.beginPath(),$x(this,this.getDistanceFromCenterForValue(this._endValue),e,this._pointLabels.length),n.closePath(),n.fillStyle=t,n.fill(),n.restore()}}drawGrid(){const t=this.ctx,e=this.options,{angleLines:n,grid:i,border:r}=e,o=this._pointLabels.length;let a,l,c;if(e.pointLabels.display&&E2(this,o),i.display&&this.ticks.forEach((h,u)=>{if(u!==0||u===0&&this.min<0){l=this.getDistanceFromCenterForValue(h.value);const d=this.getContext(u),f=i.setContext(d),p=r.setContext(d);A2(this,f,l,o,p)}}),n.display){for(t.save(),a=o-1;a>=0;a--){const h=n.setContext(this.getPointLabelContext(a)),{color:u,lineWidth:d}=h;!d||!u||(t.lineWidth=d,t.strokeStyle=u,t.setLineDash(h.borderDash),t.lineDashOffset=h.borderDashOffset,l=this.getDistanceFromCenterForValue(e.reverse?this.min:this.max),c=this.getPointPosition(a,l),t.beginPath(),t.moveTo(this.xCenter,this.yCenter),t.lineTo(c.x,c.y),t.stroke())}t.restore()}}drawBorder(){}drawLabels(){const t=this.ctx,e=this.options,n=e.ticks;if(!n.display)return;const i=this.getIndexAngle(0);let r,o;t.save(),t.translate(this.xCenter,this.yCenter),t.rotate(i),t.textAlign="center",t.textBaseline="middle",this.ticks.forEach((a,l)=>{if(l===0&&this.min>=0&&!e.reverse)return;const c=n.setContext(this.getContext(l)),h=de(c.font);if(r=this.getDistanceFromCenterForValue(this.ticks[l].value),c.showLabelBackdrop){t.font=h.string,o=t.measureText(a.label).width,t.fillStyle=c.backdropColor;const u=De(c.backdropPadding);t.fillRect(-o/2-u.left,-r-h.size/2-u.top,o+u.width,h.size+u.height)}Ki(t,a.label,0,-r,h,{color:c.color,strokeColor:c.textStrokeColor,strokeWidth:c.textStrokeWidth})}),t.restore()}drawTitle(){}}const xl={millisecond:{common:!0,size:1,steps:1e3},second:{common:!0,size:1e3,steps:60},minute:{common:!0,size:6e4,steps:60},hour:{common:!0,size:36e5,steps:24},day:{common:!0,size:864e5,steps:30},week:{common:!1,size:6048e5,steps:4},month:{common:!0,size:2628e6,steps:12},quarter:{common:!1,size:7884e6,steps:4},year:{common:!0,size:3154e7}},ze=Object.keys(xl);function np(s,t){return s-t}function ip(s,t){if(zt(t))return null;const e=s._adapter,{parser:n,round:i,isoWeekday:r}=s._parseOpts;let o=t;return typeof n=="function"&&(o=n(o)),xe(o)||(o=typeof n=="string"?e.parse(o,n):e.parse(o)),o===null?null:(i&&(o=i==="week"&&(Ks(r)||r===!0)?e.startOf(o,"isoWeek",r):e.startOf(o,i)),+o)}function sp(s,t,e,n){const i=ze.length;for(let r=ze.indexOf(s);r<i-1;++r){const o=xl[ze[r]],a=o.steps?o.steps:Number.MAX_SAFE_INTEGER;if(o.common&&Math.ceil((e-t)/(a*o.size))<=n)return ze[r]}return ze[i-1]}function R2(s,t,e,n,i){for(let r=ze.length-1;r>=ze.indexOf(e);r--){const o=ze[r];if(xl[o].common&&s._adapter.diff(i,n,o)>=t-1)return o}return ze[e?ze.indexOf(e):0]}function P2(s){for(let t=ze.indexOf(s)+1,e=ze.length;t<e;++t)if(xl[ze[t]].common)return ze[t]}function rp(s,t,e){if(!e)s[t]=!0;else if(e.length){const{lo:n,hi:i}=nu(e,t),r=e[n]>=t?e[n]:e[i];s[r]=!0}}function D2(s,t,e,n){const i=s._adapter,r=+i.startOf(t[0].value,n),o=t[t.length-1].value;let a,l;for(a=r;a<=o;a=+i.add(a,1,n))l=e[a],l>=0&&(t[l].major=!0);return t}function op(s,t,e){const n=[],i={},r=t.length;let o,a;for(o=0;o<r;++o)a=t[o],i[a]=o,n.push({value:a,major:!1});return r===0||!e?n:D2(s,n,i,e)}class ap extends cr{static id="time";static defaults={bounds:"data",adapters:{},time:{parser:!1,unit:!1,round:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{}},ticks:{source:"auto",callback:!1,major:{enabled:!1}}};constructor(t){super(t),this._cache={data:[],labels:[],all:[]},this._unit="day",this._majorUnit=void 0,this._offsets={},this._normalized=!1,this._parseOpts=void 0}init(t,e={}){const n=t.time||(t.time={}),i=this._adapter=new ZT._date(t.adapters.date);i.init(e),Ir(n.displayFormats,i.formats()),this._parseOpts={parser:n.parser,round:n.round,isoWeekday:n.isoWeekday},super.init(t),this._normalized=e.normalized}parse(t,e){return t===void 0?null:ip(this,t)}beforeLayout(){super.beforeLayout(),this._cache={data:[],labels:[],all:[]}}determineDataLimits(){const t=this.options,e=this._adapter,n=t.time.unit||"day";let{min:i,max:r,minDefined:o,maxDefined:a}=this.getUserBounds();function l(c){!o&&!isNaN(c.min)&&(i=Math.min(i,c.min)),!a&&!isNaN(c.max)&&(r=Math.max(r,c.max))}(!o||!a)&&(l(this._getLabelBounds()),(t.bounds!=="ticks"||t.ticks.source!=="labels")&&l(this.getMinMax(!1))),i=xe(i)&&!isNaN(i)?i:+e.startOf(Date.now(),n),r=xe(r)&&!isNaN(r)?r:+e.endOf(Date.now(),n)+1,this.min=Math.min(i,r-1),this.max=Math.max(i+1,r)}_getLabelBounds(){const t=this.getLabelTimestamps();let e=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY;return t.length&&(e=t[0],n=t[t.length-1]),{min:e,max:n}}buildTicks(){const t=this.options,e=t.time,n=t.ticks,i=n.source==="labels"?this.getLabelTimestamps():this._generate();t.bounds==="ticks"&&i.length&&(this.min=this._userMin||i[0],this.max=this._userMax||i[i.length-1]);const r=this.min,o=this.max,a=p1(i,r,o);return this._unit=e.unit||(n.autoSkip?sp(e.minUnit,this.min,this.max,this._getLabelCapacity(r)):R2(this,a.length,e.minUnit,this.min,this.max)),this._majorUnit=!n.major.enabled||this._unit==="year"?void 0:P2(this._unit),this.initOffsets(i),t.reverse&&a.reverse(),op(this,a,this._majorUnit)}afterAutoSkip(){this.options.offsetAfterAutoskip&&this.initOffsets(this.ticks.map(t=>+t.value))}initOffsets(t=[]){let e=0,n=0,i,r;this.options.offset&&t.length&&(i=this.getDecimalForValue(t[0]),t.length===1?e=1-i:e=(this.getDecimalForValue(t[1])-i)/2,r=this.getDecimalForValue(t[t.length-1]),t.length===1?n=r:n=(r-this.getDecimalForValue(t[t.length-2]))/2);const o=t.length<3?.5:.25;e=Re(e,0,o),n=Re(n,0,o),this._offsets={start:e,end:n,factor:1/(e+1+n)}}_generate(){const t=this._adapter,e=this.min,n=this.max,i=this.options,r=i.time,o=r.unit||sp(r.minUnit,e,n,this._getLabelCapacity(e)),a=Pt(i.ticks.stepSize,1),l=o==="week"?r.isoWeekday:!1,c=Ks(l)||l===!0,h={};let u=e,d,f;if(c&&(u=+t.startOf(u,"isoWeek",l)),u=+t.startOf(u,c?"day":o),t.diff(n,e,o)>1e5*a)throw new Error(e+" and "+n+" are too far apart with stepSize of "+a+" "+o);const p=i.ticks.source==="data"&&this.getDataTimestamps();for(d=u,f=0;d<n;d=+t.add(d,a,o),f++)rp(h,d,p);return(d===n||i.bounds==="ticks"||f===1)&&rp(h,d,p),Object.keys(h).sort(np).map(m=>+m)}getLabelForValue(t){const e=this._adapter,n=this.options.time;return n.tooltipFormat?e.format(t,n.tooltipFormat):e.format(t,n.displayFormats.datetime)}format(t,e){const i=this.options.time.displayFormats,r=this._unit,o=e||i[r];return this._adapter.format(t,o)}_tickFormatFunction(t,e,n,i){const r=this.options,o=r.ticks.callback;if(o)return jt(o,[t,e,n],this);const a=r.time.displayFormats,l=this._unit,c=this._majorUnit,h=l&&a[l],u=c&&a[c],d=n[e],f=c&&u&&d&&d.major;return this._adapter.format(t,i||(f?u:h))}generateTickLabels(t){let e,n,i;for(e=0,n=t.length;e<n;++e)i=t[e],i.label=this._tickFormatFunction(i.value,e,t)}getDecimalForValue(t){return t===null?NaN:(t-this.min)/(this.max-this.min)}getPixelForValue(t){const e=this._offsets,n=this.getDecimalForValue(t);return this.getPixelForDecimal((e.start+n)*e.factor)}getValueForPixel(t){const e=this._offsets,n=this.getDecimalForPixel(t)/e.factor-e.end;return this.min+n*(this.max-this.min)}_getLabelSize(t){const e=this.options.ticks,n=this.ctx.measureText(t).width,i=en(this.isHorizontal()?e.maxRotation:e.minRotation),r=Math.cos(i),o=Math.sin(i),a=this._resolveTickFontOptions(0).size;return{w:n*r+a*o,h:n*o+a*r}}_getLabelCapacity(t){const e=this.options.time,n=e.displayFormats,i=n[e.unit]||n.millisecond,r=this._tickFormatFunction(t,0,op(this,[t],this._majorUnit),i),o=this._getLabelSize(r),a=Math.floor(this.isHorizontal()?this.width/o.w:this.height/o.h)-1;return a>0?a:1}getDataTimestamps(){let t=this._cache.data||[],e,n;if(t.length)return t;const i=this.getMatchingVisibleMetas();if(this._normalized&&i.length)return this._cache.data=i[0].controller.getAllParsedValues(this);for(e=0,n=i.length;e<n;++e)t=t.concat(i[e].controller.getAllParsedValues(this));return this._cache.data=this.normalize(t)}getLabelTimestamps(){const t=this._cache.labels||[];let e,n;if(t.length)return t;const i=this.getLabels();for(e=0,n=i.length;e<n;++e)t.push(ip(this,i[e]));return this._cache.labels=this._normalized?t:this.normalize(t)}normalize(t){return ux(t.sort(np))}}function Ma(s,t,e){let n=0,i=s.length-1,r,o,a,l;e?(t>=s[n].pos&&t<=s[i].pos&&({lo:n,hi:i}=ki(s,"pos",t)),{pos:r,time:a}=s[n],{pos:o,time:l}=s[i]):(t>=s[n].time&&t<=s[i].time&&({lo:n,hi:i}=ki(s,"time",t)),{time:r,pos:a}=s[n],{time:o,pos:l}=s[i]);const c=o-r;return c?a+(l-a)*(t-r)/c:a}class J2 extends ap{static id="timeseries";static defaults=ap.defaults;constructor(t){super(t),this._table=[],this._minPos=void 0,this._tableRange=void 0}initOffsets(){const t=this._getTimestampsForTable(),e=this._table=this.buildLookupTable(t);this._minPos=Ma(e,this.min),this._tableRange=Ma(e,this.max)-this._minPos,super.initOffsets(t)}buildLookupTable(t){const{min:e,max:n}=this,i=[],r=[];let o,a,l,c,h;for(o=0,a=t.length;o<a;++o)c=t[o],c>=e&&c<=n&&i.push(c);if(i.length<2)return[{time:e,pos:0},{time:n,pos:1}];for(o=0,a=i.length;o<a;++o)h=i[o+1],l=i[o-1],c=i[o],Math.round((h+l)/2)!==c&&r.push({time:c,pos:o/(a-1)});return r}_generate(){const t=this.min,e=this.max;let n=super.getDataTimestamps();return(!n.includes(t)||!n.length)&&n.splice(0,0,t),(!n.includes(e)||n.length===1)&&n.push(e),n.sort((i,r)=>i-r)}_getTimestampsForTable(){let t=this._cache.all||[];if(t.length)return t;const e=this.getDataTimestamps(),n=this.getLabelTimestamps();return e.length&&n.length?t=this.normalize(e.concat(n)):t=e.length?e:n,t=this._cache.all=t,t}getDecimalForValue(t){return(Ma(this._table,t)-this._minPos)/this._tableRange}getValueForPixel(t){const e=this._offsets,n=this.getDecimalForPixel(t)/e.factor-e.end;return Ma(this._table,n*this._tableRange+this._minPos,!0)}}const Kx="label";function lp(s,t){typeof s=="function"?s(t):s&&(s.current=t)}function I2(s,t){const e=s.options;e&&t&&Object.assign(e,t)}function Qx(s,t){s.labels=t}function t0(s,t){let e=arguments.length>2&&arguments[2]!==void 0?arguments[2]:Kx;const n=[];s.datasets=t.map(i=>{const r=s.datasets.find(o=>o[e]===i[e]);return!r||!i.data||n.includes(r)?{...i}:(n.push(r),Object.assign(r,i),r)})}function F2(s){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Kx;const e={labels:[],datasets:[]};return Qx(e,s.labels),t0(e,s.datasets,t),e}function k2(s,t){const{height:e=150,width:n=300,redraw:i=!1,datasetIdKey:r,type:o,data:a,options:l,plugins:c=[],fallbackContent:h,updateMode:u,...d}=s,f=Ye.useRef(null),p=Ye.useRef(null),m=()=>{f.current&&(p.current=new pl(f.current,{type:o,data:F2(a,r),options:l&&{...l},plugins:c}),lp(t,p.current))},y=()=>{lp(t,null),p.current&&(p.current.destroy(),p.current=null)};return Ye.useEffect(()=>{!i&&p.current&&l&&I2(p.current,l)},[i,l]),Ye.useEffect(()=>{!i&&p.current&&Qx(p.current.config.data,a.labels)},[i,a.labels]),Ye.useEffect(()=>{!i&&p.current&&a.datasets&&t0(p.current.config.data,a.datasets,r)},[i,a.datasets]),Ye.useEffect(()=>{p.current&&(i?(y(),setTimeout(m)):p.current.update(u))},[i,l,a.labels,a.datasets,u]),Ye.useEffect(()=>{p.current&&(y(),setTimeout(m))},[o]),Ye.useEffect(()=>(m(),()=>y()),[]),cp.createElement("canvas",{ref:f,role:"img",height:e,width:n,...d},h)}const B2=Ye.forwardRef(k2);function ls(s,t){return pl.register(t),Ye.forwardRef((e,n)=>cp.createElement(B2,{...e,ref:n,type:s}))}const O2=ls("line",XT),z2=ls("bar",WT),N2=ls("radar",jT),H2=ls("doughnut",Ix),U2=ls("polarArea",qT),V2=ls("pie",YT),W2=ls("scatter",JT);pl.register(C2,bA,ml,YA,c2,QA,uA,f2,m2,AA,e2);const Z2=()=>{const s=Ye.useRef(null);Ye.useEffect(()=>{let i=null;return s.current&&(i=CS({el:s.current,THREE:SS,mouseControls:!0,touchControls:!0,gyroControls:!1,minHeight:200,minWidth:200,scale:1,scaleMobile:1,color:4162552,backgroundColor:16317180,size:.8})),()=>{i&&i.destroy()}},[]);const t={aiSkills:{type:"scatter",data:{datasets:[{label:"AI/ML Skills",data:[{x:1,y:3,label:"Machine Learning"},{x:2,y:2,label:"Deep Learning"},{x:3,y:4,label:"Computer Vision"},{x:4,y:5,label:"LLM Integration"},{x:5,y:7,label:"Data Analysis"},{x:6,y:6,label:"Model Deployment"}],backgroundColor:"rgba(196, 230, 4, 0.7)",borderColor:"rgba(183, 214, 7, 0.81)",borderWidth:2,pointRadius:8,pointHoverRadius:10}]},options:{responsive:!0,maintainAspectRatio:!1,aspectRatio:1,scales:{x:{type:"linear",position:"bottom",min:0,max:7,title:{display:!0,text:"Skill Categories"}},y:{min:0,max:10,title:{display:!0,text:"Expertise Level"}}},plugins:{tooltip:{callbacks:{label:function(i){return i.raw.label+": "+i.parsed.y}}},legend:{position:"right",labels:{boxWidth:12,padding:15}}}}},languages:{type:"radar",data:{labels:["Java","C#","Python","SQL","JavaScript","XML","HTML","CSS","R"],datasets:[{label:"Expertise Level",data:[6,6,5,7,7,6,8,8,5],backgroundColor:"rgba(79, 70, 229, 0.2)",borderColor:"rgba(79, 70, 229, 1)",borderWidth:2,pointBackgroundColor:"rgba(79, 70, 229, 1)",pointRadius:4}]},options:{responsive:!0,maintainAspectRatio:!1,aspectRatio:1,scales:{r:{angleLines:{display:!0},suggestedMin:0,suggestedMax:10}},plugins:{legend:{position:"right",labels:{boxWidth:12,padding:15}}}}},frameworks:{type:"pie",data:{labels:["Spring Boot","RestAssured","React","Tailwind CSS","Lucid React","Vite","JUnit","TestNG","Maven","Selenium","Appium"],datasets:[{data:[6,5,6,5,6,4,6,5,5,5,4],backgroundColor:["rgba(126, 34, 206, 0.7)","rgba(107, 33, 168, 0.7)","rgba(88, 28, 135, 0.7)","rgba(76, 29, 149, 0.7)","rgba(91, 33, 182, 0.7)","rgba(109, 40, 217, 0.7)","rgba(124, 58, 237, 0.7)","rgba(139, 92, 246, 0.7)","rgba(107, 33, 150, 0.7)","rgba(107, 7, 243, 0.7)","rgba(139, 92, 246, 0.7)"],borderColor:"rgba(255, 255, 255, 1)",borderWidth:1}]},options:{responsive:!0,maintainAspectRatio:!1,aspectRatio:1,plugins:{legend:{position:"right",labels:{boxWidth:12,padding:15}}}}},testing:{type:"polarArea",data:{labels:["Selenium","HP QC/QTP","Jira","Confluence","Smartsheet","Excel","Power BI","Tableau","Postman","BugZilla","Jupyter"],datasets:[{data:[6,5,8,7,6,7,5,6,6,6,6],backgroundColor:["rgba(236, 72, 153, 0.7)","rgba(219, 39, 119, 0.7)","rgba(190, 24, 93, 0.7)","rgba(157, 23, 77, 0.7)","rgba(131, 24, 67, 0.7)","rgba(236, 72, 153, 0.5)","rgba(249, 168, 212, 0.7)","rgba(244, 114, 182, 0.7)","rgba(240, 171, 252, 0.7)","rgba(253, 164, 175, 0.7)"],borderColor:"rgba(255, 255, 255, 1)",borderWidth:1}]},options:{responsive:!0,maintainAspectRatio:!1,aspectRatio:1,plugins:{legend:{position:"right",labels:{boxWidth:12,padding:15}}}}},databases:{type:"bar",data:{labels:["Excel","Oracle","SQL Server","MySQL","DB2","Teradata","Derby","Squirrel","NoSQL","Snowflake","R","DataBricks"],datasets:[{label:"Expertise Level",data:[8,4,7,6,6,5,4,5,3,6,3,2],backgroundColor:"rgba(37, 99, 235, 0.7)",borderColor:"rgba(37, 99, 235, 1)",borderWidth:1}]},options:{responsive:!0,maintainAspectRatio:!1,aspectRatio:1,scales:{y:{beginAtZero:!0,max:10}},plugins:{legend:{position:"right",labels:{boxWidth:12,padding:15}}}}},servers:{type:"doughnut",data:{labels:["Windows 7-11","Linux","macOS","Windows Server","Apache Tomcat","IIS","WebSphere","Raspberry Pi"],datasets:[{data:[9,7,8,6,5,5,4,7],backgroundColor:["rgba(22, 163, 74, 0.7)","rgba(21, 128, 61, 0.7)","rgba(22, 101, 52, 0.7)","rgba(20, 83, 45, 0.7)","rgba(74, 222, 128, 0.7)","rgba(134, 239, 172, 0.7)","rgba(187, 247, 208, 0.7)","rgba(220, 252, 231, 0.7)"],borderColor:"rgba(255, 255, 255, 1)",borderWidth:1}]},options:{responsive:!0,maintainAspectRatio:!1,aspectRatio:1,plugins:{legend:{position:"right",labels:{boxWidth:12,padding:15}}}}},networking:{type:"line",data:{labels:["DHCP","VPN","FTP","DNS","Subnet Mask","IPv4/6","LAN/WAN","WEP/WPA"],datasets:[{label:"Expertise Level",data:[7,8,6,8,7,6,7,6],fill:!0,backgroundColor:"rgba(234, 179, 8, 0.2)",borderColor:"rgba(234, 179, 8, 1)",tension:.3,pointBackgroundColor:"rgba(234, 179, 8, 1)",pointRadius:5}]},options:{responsive:!0,maintainAspectRatio:!1,aspectRatio:1,scales:{y:{beginAtZero:!0,max:10}},plugins:{legend:{position:"right",labels:{boxWidth:12,padding:15}}}}}},e={radar:N2,pie:V2,polarArea:U2,bar:z2,doughnut:H2,line:O2,scatter:W2},n=[{id:"aiSkills",title:"AI/ML Skills",color:"text-teal-700"},{id:"languages",title:"Programming Languages",color:"text-indigo-700"},{id:"frameworks",title:"Frameworks & Testing",color:"text-purple-700"},{id:"testing",title:"Testing & Analysis Tools",color:"text-pink-700"},{id:"databases",title:"Databases",color:"text-blue-700"},{id:"servers",title:"Servers & OS",color:"text-green-700"},{id:"networking",title:"Networking",color:"text-yellow-600"}];return Gn.jsxs("div",{className:"relative min-h-screen",children:[Gn.jsx("div",{ref:s,className:"fixed top-0 left-0 w-full h-full -z-10 opacity-50"}),Gn.jsx("div",{className:"space-y-8 relative z-10 p-6",children:Gn.jsx("div",{className:"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8",children:n.map(({id:i,title:r,color:o})=>{const a=e[t[i].type];return Gn.jsxs("div",{className:"bg-white p-6 rounded-xl shadow-md transition-all duration-300 hover:-translate-y-1 hover:shadow-lg",children:[Gn.jsx("h2",{className:`text-2xl font-bold text-center mb-6 ${o}`,children:r}),Gn.jsxs("div",{className:"h-80 w-full",children:["  ",Gn.jsx(a,{data:t[i].data,options:t[i].options})]})]},i)})})})]})};export{Z2 as default};
//# sourceMappingURL=TechnicalSkills-Cr1scDGr.js.map
